/*
 * HashiCorp Vault API
 *
 * HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.
 *
 * The version of the OpenAPI document: 1.13.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Threading;
using System.Threading.Tasks;
using Vault.Client;
using Vault.Model;

namespace Vault.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISystemSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Disable the audit device at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The name of the backend. Cannot be delimited. Example: \&quot;mysql\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemAuditPath(string path);
        /// <summary>
        /// Disable the auth method at the given auth path
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Cannot be delimited. Example: \&quot;user\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemAuthPath(string path);
        /// <summary>
        /// Disable auditing of the given request header.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemConfigAuditingRequestHeadersHeader(string header);
        /// <summary>
        /// Remove any CORS settings.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemConfigCors();
        /// <summary>
        /// Remove a UI header.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header">The name of the header.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemConfigUiHeadersHeader(string header);
        /// <summary>
        /// Cancels any in-progress root generation attempt.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemGenerateRoot();
        /// <summary>
        /// Cancels any in-progress root generation attempt.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemGenerateRootAttempt();
        /// <summary>
        /// Revert the all loggers to use log level provided in config.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemLoggers();
        /// <summary>
        /// Revert a single logger to use log level provided in config.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the logger to be modified.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemLoggersName(string name);
        /// <summary>
        /// Disable the mount point specified at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemMountsPath(string path);
        /// <summary>
        /// Remove the plugin with the given name.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemPluginsCatalogName(string name);
        /// <summary>
        /// Remove the plugin with the given name.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="type">The type of the plugin, may be auth, secret, or database</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemPluginsCatalogTypeName(string name, string type);
        /// <summary>
        /// Delete the ACL policy with the given name.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemPoliciesAclName(string name);
        /// <summary>
        /// Delete a password policy.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the password policy.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemPoliciesPasswordName(string name);
        /// <summary>
        /// Delete the policy with the given name.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemPolicyName(string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the quota rule.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemQuotasRateLimitName(string name);
        /// <summary>
        /// Delete the key with given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemRaw();
        /// <summary>
        /// Delete the key with given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemRawPath(string path);
        /// <summary>
        /// Delete the backup copy of PGP-encrypted unseal keys.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemRekeyBackup();
        /// <summary>
        /// Cancels any in-progress rekey.
        /// </summary>
        /// <remarks>
        /// This clears the rekey settings as well as any progress made. This must be called to change the parameters of the rekey. Note: verification is still a part of a rekey. If rekeying is canceled during the verification flow, the current unseal keys remain valid.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemRekeyInit();
        /// <summary>
        /// Allows fetching or deleting the backup of the rotated unseal keys.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemRekeyRecoveryKeyBackup();
        /// <summary>
        /// Cancel any in-progress rekey verification operation.
        /// </summary>
        /// <remarks>
        /// This clears any progress made and resets the nonce. Unlike a &#x60;DELETE&#x60; against &#x60;sys/rekey/init&#x60;, this only resets the current verification operation, not the entire rekey atttempt.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteSystemRekeyVerify();
        /// <summary>
        /// Return a list of configured UI headers.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListSystemConfigUiHeaders(string list);
        /// <summary>
        /// Returns a list of lease ids.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListSystemLeasesLookup(string list);
        /// <summary>
        /// Returns a list of lease ids.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to list leases under. Example: \&quot;aws/creds/deploy\&quot;</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListSystemLeasesLookupPrefix(string prefix, string list);
        /// <summary>
        /// List the plugins in the catalog.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="type">The type of the plugin, may be auth, secret, or database</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListSystemPluginsCatalogType(string type, string list);
        /// <summary>
        /// List the configured access control policies.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListSystemPoliciesAcl(string list);
        /// <summary>
        /// List the existing password policies.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListSystemPoliciesPassword(string list);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListSystemQuotasRateLimit(string list);
        /// <summary>
        /// Returns map of historical version change entries
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListSystemVersionHistory(string list);
        /// <summary>
        /// List the enabled audit devices.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemAudit();
        /// <summary>
        /// List the currently enabled credential backends.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemAuth();
        /// <summary>
        /// Read the configuration of the auth engine at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Cannot be delimited. Example: \&quot;user\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemAuthPath(string path);
        /// <summary>
        /// Reads the given auth path&#39;s configuration.
        /// </summary>
        /// <remarks>
        /// This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via &#x60;sys/mounts/auth/[auth-path]/tune&#x60;.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Tune the configuration parameters for an auth path.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemAuthPathTune(string path);
        /// <summary>
        /// List the request headers that are configured to be audited.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemConfigAuditingRequestHeaders();
        /// <summary>
        /// List the information for the given request header.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemConfigAuditingRequestHeadersHeader(string header);
        /// <summary>
        /// Return the current CORS settings.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemConfigCors();
        /// <summary>
        /// Return a sanitized version of the Vault server configuration.
        /// </summary>
        /// <remarks>
        /// The sanitized output strips configuration values in the storage, HA storage, and seals stanzas, which may contain sensitive values such as API tokens. It also removes any token or secret fields in other stanzas, such as the circonus_api_token from telemetry.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemConfigStateSanitized();
        /// <summary>
        /// Return the given UI header&#39;s configuration
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header">The name of the header.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemConfigUiHeadersHeader(string header);
        /// <summary>
        /// Read the configuration and progress of the current root generation attempt.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemGenerateRoot();
        /// <summary>
        /// Read the configuration and progress of the current root generation attempt.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemGenerateRootAttempt();
        /// <summary>
        /// Check the HA status of a Vault cluster
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemHaStatus();
        /// <summary>
        /// Returns the health status of Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemHealth();
        /// <summary>
        /// Information about the host instance that this Vault server is running on.
        /// </summary>
        /// <remarks>
        /// Information about the host instance that this Vault server is running on.   The information that gets collected includes host hardware information, and CPU,   disk, and memory utilization
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemHostInfo();
        /// <summary>
        /// reports in-flight requests
        /// </summary>
        /// <remarks>
        /// This path responds to the following HTTP methods.   GET /    Returns a map of in-flight requests.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemInFlightReq();
        /// <summary>
        /// Returns the initialization status of Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemInit();
        /// <summary>
        /// Report the client count metrics, for this namespace and all child namespaces.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemInternalCountersActivity();
        /// <summary>
        /// Report the client count metrics, for this namespace and all child namespaces.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemInternalCountersActivityExport();
        /// <summary>
        /// Report the number of clients for this month, for this namespace and all child namespaces.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemInternalCountersActivityMonthly();
        /// <summary>
        /// Read the client count tracking configuration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemInternalCountersConfig();
        /// <summary>
        /// Backwards compatibility is not guaranteed for this API
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemInternalCountersEntities();
        /// <summary>
        /// Backwards compatibility is not guaranteed for this API
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemInternalCountersRequests();
        /// <summary>
        /// Backwards compatibility is not guaranteed for this API
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemInternalCountersTokens();
        /// <summary>
        /// Expose the route entry and mount entry tables present in the router
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">Name of subtree being observed</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemInternalInspectRouterTag(string tag);
        /// <summary>
        /// Generate an OpenAPI 3 document of all mounted paths.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemInternalSpecsOpenapi();
        /// <summary>
        /// Lists enabled feature flags.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemInternalUiFeatureFlags();
        /// <summary>
        /// Lists all enabled and visible auth and secrets mounts.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemInternalUiMounts();
        /// <summary>
        /// Return information about the given mount.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path of the mount.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemInternalUiMountsPath(string path);
        /// <summary>
        /// Backwards compatibility is not guaranteed for this API
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemInternalUiNamespaces();
        /// <summary>
        /// Backwards compatibility is not guaranteed for this API
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemInternalUiResultantAcl();
        /// <summary>
        /// Provides information about the backend encryption key.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemKeyStatus();
        /// <summary>
        /// Returns the high availability status and current leader instance of Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemLeader();
        /// <summary>
        /// List leases associated with this Vault cluster
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemLeases();
        /// <summary>
        /// Count of leases associated with this Vault cluster
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemLeasesCount();
        /// <summary>
        /// Export the metrics aggregated for telemetry purpose.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="format">Format to export metrics into. Currently accepts only \&quot;prometheus\&quot;. (optional, default to &quot;&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemMetrics(string format = "");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="logFormat">Output format of logs. Supported values are \&quot;standard\&quot; and \&quot;json\&quot;. The default is \&quot;standard\&quot;. (optional, default to &quot;standard&quot;)</param>
        /// <param name="logLevel">Log level to view system logs at. Currently supported values are \&quot;trace\&quot;, \&quot;debug\&quot;, \&quot;info\&quot;, \&quot;warn\&quot;, \&quot;error\&quot;. (optional, default to &quot;info&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemMonitor(string logFormat = "standard", string logLevel = "info");
        /// <summary>
        /// List the currently mounted backends.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemMounts();
        /// <summary>
        /// Read the configuration of the secret engine at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemMountsPath(string path);
        /// <summary>
        /// Tune backend configuration parameters for this mount.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemMountsPathTune(string path);
        /// <summary>
        /// Lists all the plugins known to Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPluginsCatalog();
        /// <summary>
        /// Return the configuration data for the plugin with the given name.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPluginsCatalogName(string name);
        /// <summary>
        /// Return the configuration data for the plugin with the given name.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="type">The type of the plugin, may be auth, secret, or database</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPluginsCatalogTypeName(string name, string type);
        /// <summary>
        /// Retrieve information about the named ACL policy.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPoliciesAclName(string name);
        /// <summary>
        /// Retrieve an existing password policy.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the password policy.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPoliciesPasswordName(string name);
        /// <summary>
        /// Generate a password from an existing password policy.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the password policy.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPoliciesPasswordNameGenerate(string name);
        /// <summary>
        /// List the configured access control policies.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPolicy(string list = "false");
        /// <summary>
        /// Retrieve the policy body for the named policy.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPolicyName(string name);
        /// <summary>
        /// Returns an HTML page listing the available profiles.
        /// </summary>
        /// <remarks>
        /// Returns an HTML page listing the available  profiles. This should be mainly accessed via browsers or applications that can  render pages.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPprof();
        /// <summary>
        /// Returns a sampling of all past memory allocations.
        /// </summary>
        /// <remarks>
        /// Returns a sampling of all past memory allocations.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPprofAllocs();
        /// <summary>
        /// Returns stack traces that led to blocking on synchronization primitives
        /// </summary>
        /// <remarks>
        /// Returns stack traces that led to blocking on synchronization primitives
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPprofBlock();
        /// <summary>
        /// Returns the running program&#39;s command line.
        /// </summary>
        /// <remarks>
        /// Returns the running program&#39;s command line, with arguments separated by NUL bytes.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPprofCmdline();
        /// <summary>
        /// Returns stack traces of all current goroutines.
        /// </summary>
        /// <remarks>
        /// Returns stack traces of all current goroutines.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPprofGoroutine();
        /// <summary>
        /// Returns a sampling of memory allocations of live object.
        /// </summary>
        /// <remarks>
        /// Returns a sampling of memory allocations of live object.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPprofHeap();
        /// <summary>
        /// Returns stack traces of holders of contended mutexes
        /// </summary>
        /// <remarks>
        /// Returns stack traces of holders of contended mutexes
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPprofMutex();
        /// <summary>
        /// Returns a pprof-formatted cpu profile payload.
        /// </summary>
        /// <remarks>
        /// Returns a pprof-formatted cpu profile payload. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPprofProfile();
        /// <summary>
        /// Returns the program counters listed in the request.
        /// </summary>
        /// <remarks>
        /// Returns the program counters listed in the request.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPprofSymbol();
        /// <summary>
        /// Returns stack traces that led to the creation of new OS threads
        /// </summary>
        /// <remarks>
        /// Returns stack traces that led to the creation of new OS threads
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPprofThreadcreate();
        /// <summary>
        /// Returns the execution trace in binary form.
        /// </summary>
        /// <remarks>
        /// Returns  the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemPprofTrace();
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemQuotasConfig();
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the quota rule.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemQuotasRateLimitName(string name);
        /// <summary>
        /// Read the value of the key at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemRaw(string list = "false");
        /// <summary>
        /// Read the value of the key at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path"></param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemRawPath(string path, string list = "false");
        /// <summary>
        /// Return the backup copy of PGP-encrypted unseal keys.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemRekeyBackup();
        /// <summary>
        /// Reads the configuration and progress of the current rekey attempt.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemRekeyInit();
        /// <summary>
        /// Allows fetching or deleting the backup of the rotated unseal keys.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemRekeyRecoveryKeyBackup();
        /// <summary>
        /// Read the configuration and progress of the current rekey verification attempt.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemRekeyVerify();
        /// <summary>
        /// Check status of a mount migration
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="migrationId">The ID of the migration operation</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemRemountStatusMigrationId(string migrationId);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemReplicationStatus();
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemRotateConfig();
        /// <summary>
        /// Check the seal status of a Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemSealStatus();
        /// <summary>
        /// Look up wrapping properties for the requester&#39;s token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadSystemWrappingLookup();
        /// <summary>
        /// The hash of the given string via the given audit backend
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The name of the backend. Cannot be delimited. Example: \&quot;mysql\&quot;</param>
        /// <param name="systemAuditHashRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemAuditHashPath(string path, SystemAuditHashRequest systemAuditHashRequest);
        /// <summary>
        /// Enable a new audit device at the supplied path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The name of the backend. Cannot be delimited. Example: \&quot;mysql\&quot;</param>
        /// <param name="systemAuditRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemAuditPath(string path, SystemAuditRequest systemAuditRequest);
        /// <summary>
        /// Enables a new auth method.
        /// </summary>
        /// <remarks>
        /// After enabling, the auth method can be accessed and configured via the auth path specified as part of the URL. This auth path will be nested under the auth prefix.  For example, enable the \&quot;foo\&quot; auth method will make it accessible at /auth/foo.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Cannot be delimited. Example: \&quot;user\&quot;</param>
        /// <param name="systemAuthRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemAuthPath(string path, SystemAuthRequest systemAuthRequest);
        /// <summary>
        /// Tune configuration parameters for a given auth path.
        /// </summary>
        /// <remarks>
        /// This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via &#x60;sys/mounts/auth/[auth-path]/tune&#x60;.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Tune the configuration parameters for an auth path.</param>
        /// <param name="systemAuthTuneRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemAuthPathTune(string path, SystemAuthTuneRequest systemAuthTuneRequest);
        /// <summary>
        /// Fetches the capabilities of the given token on the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemCapabilitiesRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemCapabilities(SystemCapabilitiesRequest systemCapabilitiesRequest);
        /// <summary>
        /// Fetches the capabilities of the token associated with the given token, on the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemCapabilitiesAccessorRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemCapabilitiesAccessor(SystemCapabilitiesAccessorRequest systemCapabilitiesAccessorRequest);
        /// <summary>
        /// Fetches the capabilities of the given token on the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemCapabilitiesSelfRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemCapabilitiesSelf(SystemCapabilitiesSelfRequest systemCapabilitiesSelfRequest);
        /// <summary>
        /// Enable auditing of a header.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header"></param>
        /// <param name="systemConfigAuditingRequestHeadersRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemConfigAuditingRequestHeadersHeader(string header, SystemConfigAuditingRequestHeadersRequest systemConfigAuditingRequestHeadersRequest);
        /// <summary>
        /// Configure the CORS settings.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemConfigCorsRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemConfigCors(SystemConfigCorsRequest systemConfigCorsRequest);
        /// <summary>
        /// Reload the given subsystem
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="subsystem"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemConfigReloadSubsystem(string subsystem);
        /// <summary>
        /// Configure the values to be returned for the UI header.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header">The name of the header.</param>
        /// <param name="systemConfigUiHeadersRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemConfigUiHeadersHeader(string header, SystemConfigUiHeadersRequest systemConfigUiHeadersRequest);
        /// <summary>
        /// Initializes a new root generation attempt.
        /// </summary>
        /// <remarks>
        /// Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemGenerateRootRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemGenerateRoot(SystemGenerateRootRequest systemGenerateRootRequest);
        /// <summary>
        /// Initializes a new root generation attempt.
        /// </summary>
        /// <remarks>
        /// Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemGenerateRootAttemptRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemGenerateRootAttempt(SystemGenerateRootAttemptRequest systemGenerateRootAttemptRequest);
        /// <summary>
        /// Enter a single unseal key share to progress the root generation attempt.
        /// </summary>
        /// <remarks>
        /// If the threshold number of unseal key shares is reached, Vault will complete the root generation and issue the new token. Otherwise, this API must be called multiple times until that threshold is met. The attempt nonce must be provided with each call.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemGenerateRootUpdateRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemGenerateRootUpdate(SystemGenerateRootUpdateRequest systemGenerateRootUpdateRequest);
        /// <summary>
        /// Initialize a new Vault.
        /// </summary>
        /// <remarks>
        /// The Vault must not have been previously initialized. The recovery options, as well as the stored shares option, are only available when using Vault HSM.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemInitRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemInit(SystemInitRequest systemInitRequest);
        /// <summary>
        /// Enable or disable collection of client count, set retention period, or set default reporting period.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemInternalCountersConfigRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemInternalCountersConfig(SystemInternalCountersConfigRequest systemInternalCountersConfigRequest);
        /// <summary>
        /// Retrieve lease metadata.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemLeasesLookupRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemLeasesLookup(SystemLeasesLookupRequest systemLeasesLookupRequest);
        /// <summary>
        /// Renews a lease, requesting to extend the lease.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemLeasesRenewRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemLeasesRenew(SystemLeasesRenewRequest systemLeasesRenewRequest);
        /// <summary>
        /// Renews a lease, requesting to extend the lease.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlLeaseId">The lease identifier to renew. This is included with a lease.</param>
        /// <param name="systemLeasesRenewLeaseRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemLeasesRenewUrlLeaseId(string urlLeaseId, SystemLeasesRenewLeaseRequest systemLeasesRenewLeaseRequest);
        /// <summary>
        /// Revokes a lease immediately.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemLeasesRevokeRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemLeasesRevoke(SystemLeasesRevokeRequest systemLeasesRevokeRequest);
        /// <summary>
        /// Revokes all secrets or tokens generated under a given prefix immediately
        /// </summary>
        /// <remarks>
        /// Unlike &#x60;/sys/leases/revoke-prefix&#x60;, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.  By ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to revoke keys under. Example: \&quot;prod/aws/ops\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemLeasesRevokeForcePrefix(string prefix);
        /// <summary>
        /// Revokes all secrets (via a lease ID prefix) or tokens (via the tokens&#39; path property) generated under a given prefix immediately.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to revoke keys under. Example: \&quot;prod/aws/ops\&quot;</param>
        /// <param name="systemLeasesRevokePrefixRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemLeasesRevokePrefixPrefix(string prefix, SystemLeasesRevokePrefixRequest systemLeasesRevokePrefixRequest);
        /// <summary>
        /// Revokes a lease immediately.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlLeaseId">The lease identifier to renew. This is included with a lease.</param>
        /// <param name="systemLeasesRevokeLeaseRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemLeasesRevokeUrlLeaseId(string urlLeaseId, SystemLeasesRevokeLeaseRequest systemLeasesRevokeLeaseRequest);
        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemLeasesTidy();
        /// <summary>
        /// Modify the log level for all existing loggers.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemLoggersRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemLoggers(SystemLoggersRequest systemLoggersRequest);
        /// <summary>
        /// Modify the log level of a single logger.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the logger to be modified.</param>
        /// <param name="systemLoggersRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemLoggersName(string name, SystemLoggersRequest systemLoggersRequest);
        /// <summary>
        /// Validates the login for the given MFA methods. Upon successful validation, it returns an auth response containing the client token
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemMfaValidateRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemMfaValidate(SystemMfaValidateRequest systemMfaValidateRequest);
        /// <summary>
        /// Enable a new secrets engine at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <param name="systemMountsRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemMountsPath(string path, SystemMountsRequest systemMountsRequest);
        /// <summary>
        /// Tune backend configuration parameters for this mount.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <param name="systemMountsTuneRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemMountsPathTune(string path, SystemMountsTuneRequest systemMountsTuneRequest);
        /// <summary>
        /// Register a new plugin, or updates an existing one with the supplied name.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="systemPluginsCatalogRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemPluginsCatalogName(string name, SystemPluginsCatalogRequest systemPluginsCatalogRequest);
        /// <summary>
        /// Register a new plugin, or updates an existing one with the supplied name.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="type">The type of the plugin, may be auth, secret, or database</param>
        /// <param name="systemPluginsCatalogRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemPluginsCatalogTypeName(string name, string type, SystemPluginsCatalogRequest systemPluginsCatalogRequest);
        /// <summary>
        /// Reload mounted plugin backends.
        /// </summary>
        /// <remarks>
        /// Either the plugin name (&#x60;plugin&#x60;) or the desired plugin backend mounts (&#x60;mounts&#x60;) must be provided, but not both. In the case that the plugin name is provided, all mounted paths that use that plugin backend will be reloaded.  If (&#x60;scope&#x60;) is provided and is (&#x60;global&#x60;), the plugin(s) are reloaded globally.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemPluginsReloadBackendRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemPluginsReloadBackend(SystemPluginsReloadBackendRequest systemPluginsReloadBackendRequest);
        /// <summary>
        /// Add a new or update an existing ACL policy.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <param name="systemPoliciesAclRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemPoliciesAclName(string name, SystemPoliciesAclRequest systemPoliciesAclRequest);
        /// <summary>
        /// Add a new or update an existing password policy.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the password policy.</param>
        /// <param name="systemPoliciesPasswordRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemPoliciesPasswordName(string name, SystemPoliciesPasswordRequest systemPoliciesPasswordRequest);
        /// <summary>
        /// Add a new or update an existing policy.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <param name="systemPolicyRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemPolicyName(string name, SystemPolicyRequest systemPolicyRequest);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemQuotasConfigRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemQuotasConfig(SystemQuotasConfigRequest systemQuotasConfigRequest);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the quota rule.</param>
        /// <param name="systemQuotasRateLimitRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemQuotasRateLimitName(string name, SystemQuotasRateLimitRequest systemQuotasRateLimitRequest);
        /// <summary>
        /// Update the value of the key at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRawRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemRaw(SystemRawRequest systemRawRequest);
        /// <summary>
        /// Update the value of the key at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path"></param>
        /// <param name="systemRawRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemRawPath(string path, SystemRawRequest systemRawRequest);
        /// <summary>
        /// Initializes a new rekey attempt.
        /// </summary>
        /// <remarks>
        /// Only a single rekey attempt can take place at a time, and changing the parameters of a rekey requires canceling and starting a new rekey, which will also provide a new nonce.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRekeyInitRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemRekeyInit(SystemRekeyInitRequest systemRekeyInitRequest);
        /// <summary>
        /// Enter a single unseal key share to progress the rekey of the Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRekeyUpdateRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemRekeyUpdate(SystemRekeyUpdateRequest systemRekeyUpdateRequest);
        /// <summary>
        /// Enter a single new key share to progress the rekey verification operation.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRekeyVerifyRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemRekeyVerify(SystemRekeyVerifyRequest systemRekeyVerifyRequest);
        /// <summary>
        /// Initiate a mount migration
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRemountRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemRemount(SystemRemountRequest systemRemountRequest);
        /// <summary>
        /// Renews a lease, requesting to extend the lease.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRenewRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemRenew(SystemRenewRequest systemRenewRequest);
        /// <summary>
        /// Renews a lease, requesting to extend the lease.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlLeaseId">The lease identifier to renew. This is included with a lease.</param>
        /// <param name="systemRenewLeaseRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemRenewUrlLeaseId(string urlLeaseId, SystemRenewLeaseRequest systemRenewLeaseRequest);
        /// <summary>
        /// Revokes a lease immediately.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRevokeRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemRevoke(SystemRevokeRequest systemRevokeRequest);
        /// <summary>
        /// Revokes all secrets or tokens generated under a given prefix immediately
        /// </summary>
        /// <remarks>
        /// Unlike &#x60;/sys/leases/revoke-prefix&#x60;, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.  By ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to revoke keys under. Example: \&quot;prod/aws/ops\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemRevokeForcePrefix(string prefix);
        /// <summary>
        /// Revokes all secrets (via a lease ID prefix) or tokens (via the tokens&#39; path property) generated under a given prefix immediately.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to revoke keys under. Example: \&quot;prod/aws/ops\&quot;</param>
        /// <param name="systemRevokePrefixRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemRevokePrefixPrefix(string prefix, SystemRevokePrefixRequest systemRevokePrefixRequest);
        /// <summary>
        /// Revokes a lease immediately.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlLeaseId">The lease identifier to renew. This is included with a lease.</param>
        /// <param name="systemRevokeLeaseRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemRevokeUrlLeaseId(string urlLeaseId, SystemRevokeLeaseRequest systemRevokeLeaseRequest);
        /// <summary>
        /// Rotates the backend encryption key used to persist data.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemRotate();
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRotateConfigRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemRotateConfig(SystemRotateConfigRequest systemRotateConfigRequest);
        /// <summary>
        /// Seal the Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemSeal();
        /// <summary>
        /// Cause the node to give up active status.
        /// </summary>
        /// <remarks>
        /// This endpoint forces the node to give up active status. If the node does not have active status, this endpoint does nothing. Note that the node will sleep for ten seconds before attempting to grab the active lock again, but if no standby nodes grab the active lock in the interim, the same node may become the active node again.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemStepDown();
        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemToolsHashRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemToolsHash(SystemToolsHashRequest systemToolsHashRequest);
        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="systemToolsHashRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemToolsHashUrlalgorithm(string urlalgorithm, SystemToolsHashRequest systemToolsHashRequest);
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemToolsRandomRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemToolsRandom(SystemToolsRandomRequest systemToolsRandomRequest);
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="systemToolsRandomRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemToolsRandomSource(string source, SystemToolsRandomRequest systemToolsRandomRequest);
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="systemToolsRandomRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemToolsRandomSourceUrlbytes(string source, string urlbytes, SystemToolsRandomRequest systemToolsRandomRequest);
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="systemToolsRandomRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemToolsRandomUrlbytes(string urlbytes, SystemToolsRandomRequest systemToolsRandomRequest);
        /// <summary>
        /// Unseal the Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemUnsealRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemUnseal(SystemUnsealRequest systemUnsealRequest);
        /// <summary>
        /// Look up wrapping properties for the given token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemWrappingLookupRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemWrappingLookup(SystemWrappingLookupRequest systemWrappingLookupRequest);
        /// <summary>
        /// Rotates a response-wrapped token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemWrappingRewrapRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemWrappingRewrap(SystemWrappingRewrapRequest systemWrappingRewrapRequest);
        /// <summary>
        /// Unwraps a response-wrapped token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemWrappingUnwrapRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemWrappingUnwrap(SystemWrappingUnwrapRequest systemWrappingUnwrapRequest);
        /// <summary>
        /// Response-wraps an arbitrary JSON object.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateSystemWrappingWrap();
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISystemAsync : IApiAccessor
    {
        #region Asynchronous Operations
   
        /// <summary>
        /// Disable the audit device at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The name of the backend. Cannot be delimited. Example: \&quot;mysql\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemAuditPathAsync(string path, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Disable the auth method at the given auth path
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Cannot be delimited. Example: \&quot;user\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemAuthPathAsync(string path, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Disable auditing of the given request header.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemConfigAuditingRequestHeadersHeaderAsync(string header, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Remove any CORS settings.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemConfigCorsAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Remove a UI header.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header">The name of the header.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemConfigUiHeadersHeaderAsync(string header, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Cancels any in-progress root generation attempt.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemGenerateRootAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Cancels any in-progress root generation attempt.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemGenerateRootAttemptAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Revert the all loggers to use log level provided in config.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemLoggersAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Revert a single logger to use log level provided in config.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the logger to be modified.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemLoggersNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Disable the mount point specified at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemMountsPathAsync(string path, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Remove the plugin with the given name.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemPluginsCatalogNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Remove the plugin with the given name.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="type">The type of the plugin, may be auth, secret, or database</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemPluginsCatalogTypeNameAsync(string name, string type, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete the ACL policy with the given name.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemPoliciesAclNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete a password policy.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the password policy.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemPoliciesPasswordNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete the policy with the given name.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemPolicyNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the quota rule.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemQuotasRateLimitNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete the key with given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemRawAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete the key with given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemRawPathAsync(string path, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete the backup copy of PGP-encrypted unseal keys.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemRekeyBackupAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Cancels any in-progress rekey.
        /// </summary>
        /// <remarks>
        /// This clears the rekey settings as well as any progress made. This must be called to change the parameters of the rekey. Note: verification is still a part of a rekey. If rekeying is canceled during the verification flow, the current unseal keys remain valid.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemRekeyInitAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Allows fetching or deleting the backup of the rotated unseal keys.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemRekeyRecoveryKeyBackupAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Cancel any in-progress rekey verification operation.
        /// </summary>
        /// <remarks>
        /// This clears any progress made and resets the nonce. Unlike a &#x60;DELETE&#x60; against &#x60;sys/rekey/init&#x60;, this only resets the current verification operation, not the entire rekey atttempt.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteSystemRekeyVerifyAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Return a list of configured UI headers.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListSystemConfigUiHeadersAsync(string list, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns a list of lease ids.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListSystemLeasesLookupAsync(string list, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns a list of lease ids.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to list leases under. Example: \&quot;aws/creds/deploy\&quot;</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListSystemLeasesLookupPrefixAsync(string prefix, string list, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List the plugins in the catalog.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="type">The type of the plugin, may be auth, secret, or database</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListSystemPluginsCatalogTypeAsync(string type, string list, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List the configured access control policies.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListSystemPoliciesAclAsync(string list, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List the existing password policies.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListSystemPoliciesPasswordAsync(string list, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListSystemQuotasRateLimitAsync(string list, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns map of historical version change entries
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListSystemVersionHistoryAsync(string list, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List the enabled audit devices.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemAuditAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List the currently enabled credential backends.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemAuthAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the configuration of the auth engine at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Cannot be delimited. Example: \&quot;user\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemAuthPathAsync(string path, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Reads the given auth path&#39;s configuration.
        /// </summary>
        /// <remarks>
        /// This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via &#x60;sys/mounts/auth/[auth-path]/tune&#x60;.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Tune the configuration parameters for an auth path.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemAuthPathTuneAsync(string path, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List the request headers that are configured to be audited.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemConfigAuditingRequestHeadersAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List the information for the given request header.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemConfigAuditingRequestHeadersHeaderAsync(string header, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Return the current CORS settings.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemConfigCorsAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Return a sanitized version of the Vault server configuration.
        /// </summary>
        /// <remarks>
        /// The sanitized output strips configuration values in the storage, HA storage, and seals stanzas, which may contain sensitive values such as API tokens. It also removes any token or secret fields in other stanzas, such as the circonus_api_token from telemetry.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemConfigStateSanitizedAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Return the given UI header&#39;s configuration
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header">The name of the header.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemConfigUiHeadersHeaderAsync(string header, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the configuration and progress of the current root generation attempt.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemGenerateRootAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the configuration and progress of the current root generation attempt.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemGenerateRootAttemptAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check the HA status of a Vault cluster
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemHaStatusAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the health status of Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemHealthAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Information about the host instance that this Vault server is running on.
        /// </summary>
        /// <remarks>
        /// Information about the host instance that this Vault server is running on.   The information that gets collected includes host hardware information, and CPU,   disk, and memory utilization
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemHostInfoAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// reports in-flight requests
        /// </summary>
        /// <remarks>
        /// This path responds to the following HTTP methods.   GET /    Returns a map of in-flight requests.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemInFlightReqAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the initialization status of Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemInitAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Report the client count metrics, for this namespace and all child namespaces.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemInternalCountersActivityAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Report the client count metrics, for this namespace and all child namespaces.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemInternalCountersActivityExportAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Report the number of clients for this month, for this namespace and all child namespaces.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemInternalCountersActivityMonthlyAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the client count tracking configuration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemInternalCountersConfigAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Backwards compatibility is not guaranteed for this API
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemInternalCountersEntitiesAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Backwards compatibility is not guaranteed for this API
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemInternalCountersRequestsAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Backwards compatibility is not guaranteed for this API
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemInternalCountersTokensAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Expose the route entry and mount entry tables present in the router
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">Name of subtree being observed</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemInternalInspectRouterTagAsync(string tag, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate an OpenAPI 3 document of all mounted paths.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemInternalSpecsOpenapiAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Lists enabled feature flags.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemInternalUiFeatureFlagsAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Lists all enabled and visible auth and secrets mounts.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemInternalUiMountsAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Return information about the given mount.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path of the mount.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemInternalUiMountsPathAsync(string path, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Backwards compatibility is not guaranteed for this API
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemInternalUiNamespacesAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Backwards compatibility is not guaranteed for this API
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemInternalUiResultantAclAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Provides information about the backend encryption key.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemKeyStatusAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the high availability status and current leader instance of Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemLeaderAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List leases associated with this Vault cluster
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemLeasesAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Count of leases associated with this Vault cluster
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemLeasesCountAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Export the metrics aggregated for telemetry purpose.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="format">Format to export metrics into. Currently accepts only \&quot;prometheus\&quot;. (optional, default to &quot;&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemMetricsAsync(string format = "", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="logFormat">Output format of logs. Supported values are \&quot;standard\&quot; and \&quot;json\&quot;. The default is \&quot;standard\&quot;. (optional, default to &quot;standard&quot;)</param>
        /// <param name="logLevel">Log level to view system logs at. Currently supported values are \&quot;trace\&quot;, \&quot;debug\&quot;, \&quot;info\&quot;, \&quot;warn\&quot;, \&quot;error\&quot;. (optional, default to &quot;info&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemMonitorAsync(string logFormat = "standard", string logLevel = "info", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List the currently mounted backends.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemMountsAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the configuration of the secret engine at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemMountsPathAsync(string path, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Tune backend configuration parameters for this mount.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemMountsPathTuneAsync(string path, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Lists all the plugins known to Vault
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPluginsCatalogAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Return the configuration data for the plugin with the given name.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPluginsCatalogNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Return the configuration data for the plugin with the given name.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="type">The type of the plugin, may be auth, secret, or database</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPluginsCatalogTypeNameAsync(string name, string type, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Retrieve information about the named ACL policy.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPoliciesAclNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Retrieve an existing password policy.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the password policy.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPoliciesPasswordNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a password from an existing password policy.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the password policy.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPoliciesPasswordNameGenerateAsync(string name, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List the configured access control policies.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPolicyAsync(string list = "false", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Retrieve the policy body for the named policy.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPolicyNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns an HTML page listing the available profiles.
        /// </summary>
        /// <remarks>
        /// Returns an HTML page listing the available  profiles. This should be mainly accessed via browsers or applications that can  render pages.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPprofAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns a sampling of all past memory allocations.
        /// </summary>
        /// <remarks>
        /// Returns a sampling of all past memory allocations.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPprofAllocsAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns stack traces that led to blocking on synchronization primitives
        /// </summary>
        /// <remarks>
        /// Returns stack traces that led to blocking on synchronization primitives
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPprofBlockAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the running program&#39;s command line.
        /// </summary>
        /// <remarks>
        /// Returns the running program&#39;s command line, with arguments separated by NUL bytes.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPprofCmdlineAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns stack traces of all current goroutines.
        /// </summary>
        /// <remarks>
        /// Returns stack traces of all current goroutines.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPprofGoroutineAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns a sampling of memory allocations of live object.
        /// </summary>
        /// <remarks>
        /// Returns a sampling of memory allocations of live object.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPprofHeapAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns stack traces of holders of contended mutexes
        /// </summary>
        /// <remarks>
        /// Returns stack traces of holders of contended mutexes
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPprofMutexAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns a pprof-formatted cpu profile payload.
        /// </summary>
        /// <remarks>
        /// Returns a pprof-formatted cpu profile payload. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPprofProfileAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the program counters listed in the request.
        /// </summary>
        /// <remarks>
        /// Returns the program counters listed in the request.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPprofSymbolAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns stack traces that led to the creation of new OS threads
        /// </summary>
        /// <remarks>
        /// Returns stack traces that led to the creation of new OS threads
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPprofThreadcreateAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the execution trace in binary form.
        /// </summary>
        /// <remarks>
        /// Returns  the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemPprofTraceAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemQuotasConfigAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the quota rule.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemQuotasRateLimitNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the value of the key at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemRawAsync(string list = "false", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the value of the key at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path"></param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemRawPathAsync(string path, string list = "false", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Return the backup copy of PGP-encrypted unseal keys.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemRekeyBackupAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Reads the configuration and progress of the current rekey attempt.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemRekeyInitAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Allows fetching or deleting the backup of the rotated unseal keys.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemRekeyRecoveryKeyBackupAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the configuration and progress of the current rekey verification attempt.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemRekeyVerifyAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check status of a mount migration
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="migrationId">The ID of the migration operation</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemRemountStatusMigrationIdAsync(string migrationId, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemReplicationStatusAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemRotateConfigAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Check the seal status of a Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemSealStatusAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Look up wrapping properties for the requester&#39;s token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadSystemWrappingLookupAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// The hash of the given string via the given audit backend
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The name of the backend. Cannot be delimited. Example: \&quot;mysql\&quot;</param>
        /// <param name="systemAuditHashRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemAuditHashPathAsync(string path, SystemAuditHashRequest systemAuditHashRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Enable a new audit device at the supplied path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The name of the backend. Cannot be delimited. Example: \&quot;mysql\&quot;</param>
        /// <param name="systemAuditRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemAuditPathAsync(string path, SystemAuditRequest systemAuditRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Enables a new auth method.
        /// </summary>
        /// <remarks>
        /// After enabling, the auth method can be accessed and configured via the auth path specified as part of the URL. This auth path will be nested under the auth prefix.  For example, enable the \&quot;foo\&quot; auth method will make it accessible at /auth/foo.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Cannot be delimited. Example: \&quot;user\&quot;</param>
        /// <param name="systemAuthRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemAuthPathAsync(string path, SystemAuthRequest systemAuthRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Tune configuration parameters for a given auth path.
        /// </summary>
        /// <remarks>
        /// This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via &#x60;sys/mounts/auth/[auth-path]/tune&#x60;.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Tune the configuration parameters for an auth path.</param>
        /// <param name="systemAuthTuneRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemAuthPathTuneAsync(string path, SystemAuthTuneRequest systemAuthTuneRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Fetches the capabilities of the given token on the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemCapabilitiesRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemCapabilitiesAsync(SystemCapabilitiesRequest systemCapabilitiesRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Fetches the capabilities of the token associated with the given token, on the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemCapabilitiesAccessorRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemCapabilitiesAccessorAsync(SystemCapabilitiesAccessorRequest systemCapabilitiesAccessorRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Fetches the capabilities of the given token on the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemCapabilitiesSelfRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemCapabilitiesSelfAsync(SystemCapabilitiesSelfRequest systemCapabilitiesSelfRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Enable auditing of a header.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header"></param>
        /// <param name="systemConfigAuditingRequestHeadersRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemConfigAuditingRequestHeadersHeaderAsync(string header, SystemConfigAuditingRequestHeadersRequest systemConfigAuditingRequestHeadersRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the CORS settings.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemConfigCorsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemConfigCorsAsync(SystemConfigCorsRequest systemConfigCorsRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Reload the given subsystem
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="subsystem"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemConfigReloadSubsystemAsync(string subsystem, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the values to be returned for the UI header.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header">The name of the header.</param>
        /// <param name="systemConfigUiHeadersRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemConfigUiHeadersHeaderAsync(string header, SystemConfigUiHeadersRequest systemConfigUiHeadersRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Initializes a new root generation attempt.
        /// </summary>
        /// <remarks>
        /// Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemGenerateRootRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemGenerateRootAsync(SystemGenerateRootRequest systemGenerateRootRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Initializes a new root generation attempt.
        /// </summary>
        /// <remarks>
        /// Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemGenerateRootAttemptRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemGenerateRootAttemptAsync(SystemGenerateRootAttemptRequest systemGenerateRootAttemptRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Enter a single unseal key share to progress the root generation attempt.
        /// </summary>
        /// <remarks>
        /// If the threshold number of unseal key shares is reached, Vault will complete the root generation and issue the new token. Otherwise, this API must be called multiple times until that threshold is met. The attempt nonce must be provided with each call.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemGenerateRootUpdateRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemGenerateRootUpdateAsync(SystemGenerateRootUpdateRequest systemGenerateRootUpdateRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Initialize a new Vault.
        /// </summary>
        /// <remarks>
        /// The Vault must not have been previously initialized. The recovery options, as well as the stored shares option, are only available when using Vault HSM.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemInitRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemInitAsync(SystemInitRequest systemInitRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Enable or disable collection of client count, set retention period, or set default reporting period.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemInternalCountersConfigRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemInternalCountersConfigAsync(SystemInternalCountersConfigRequest systemInternalCountersConfigRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Retrieve lease metadata.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemLeasesLookupRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemLeasesLookupAsync(SystemLeasesLookupRequest systemLeasesLookupRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Renews a lease, requesting to extend the lease.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemLeasesRenewRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemLeasesRenewAsync(SystemLeasesRenewRequest systemLeasesRenewRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Renews a lease, requesting to extend the lease.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlLeaseId">The lease identifier to renew. This is included with a lease.</param>
        /// <param name="systemLeasesRenewLeaseRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemLeasesRenewUrlLeaseIdAsync(string urlLeaseId, SystemLeasesRenewLeaseRequest systemLeasesRenewLeaseRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Revokes a lease immediately.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemLeasesRevokeRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemLeasesRevokeAsync(SystemLeasesRevokeRequest systemLeasesRevokeRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Revokes all secrets or tokens generated under a given prefix immediately
        /// </summary>
        /// <remarks>
        /// Unlike &#x60;/sys/leases/revoke-prefix&#x60;, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.  By ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to revoke keys under. Example: \&quot;prod/aws/ops\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemLeasesRevokeForcePrefixAsync(string prefix, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Revokes all secrets (via a lease ID prefix) or tokens (via the tokens&#39; path property) generated under a given prefix immediately.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to revoke keys under. Example: \&quot;prod/aws/ops\&quot;</param>
        /// <param name="systemLeasesRevokePrefixRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemLeasesRevokePrefixPrefixAsync(string prefix, SystemLeasesRevokePrefixRequest systemLeasesRevokePrefixRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Revokes a lease immediately.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlLeaseId">The lease identifier to renew. This is included with a lease.</param>
        /// <param name="systemLeasesRevokeLeaseRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemLeasesRevokeUrlLeaseIdAsync(string urlLeaseId, SystemLeasesRevokeLeaseRequest systemLeasesRevokeLeaseRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemLeasesTidyAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Modify the log level for all existing loggers.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemLoggersRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemLoggersAsync(SystemLoggersRequest systemLoggersRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Modify the log level of a single logger.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the logger to be modified.</param>
        /// <param name="systemLoggersRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemLoggersNameAsync(string name, SystemLoggersRequest systemLoggersRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Validates the login for the given MFA methods. Upon successful validation, it returns an auth response containing the client token
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemMfaValidateRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemMfaValidateAsync(SystemMfaValidateRequest systemMfaValidateRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Enable a new secrets engine at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <param name="systemMountsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemMountsPathAsync(string path, SystemMountsRequest systemMountsRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Tune backend configuration parameters for this mount.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <param name="systemMountsTuneRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemMountsPathTuneAsync(string path, SystemMountsTuneRequest systemMountsTuneRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register a new plugin, or updates an existing one with the supplied name.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="systemPluginsCatalogRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemPluginsCatalogNameAsync(string name, SystemPluginsCatalogRequest systemPluginsCatalogRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register a new plugin, or updates an existing one with the supplied name.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="type">The type of the plugin, may be auth, secret, or database</param>
        /// <param name="systemPluginsCatalogRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemPluginsCatalogTypeNameAsync(string name, string type, SystemPluginsCatalogRequest systemPluginsCatalogRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Reload mounted plugin backends.
        /// </summary>
        /// <remarks>
        /// Either the plugin name (&#x60;plugin&#x60;) or the desired plugin backend mounts (&#x60;mounts&#x60;) must be provided, but not both. In the case that the plugin name is provided, all mounted paths that use that plugin backend will be reloaded.  If (&#x60;scope&#x60;) is provided and is (&#x60;global&#x60;), the plugin(s) are reloaded globally.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemPluginsReloadBackendRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemPluginsReloadBackendAsync(SystemPluginsReloadBackendRequest systemPluginsReloadBackendRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Add a new or update an existing ACL policy.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <param name="systemPoliciesAclRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemPoliciesAclNameAsync(string name, SystemPoliciesAclRequest systemPoliciesAclRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Add a new or update an existing password policy.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the password policy.</param>
        /// <param name="systemPoliciesPasswordRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemPoliciesPasswordNameAsync(string name, SystemPoliciesPasswordRequest systemPoliciesPasswordRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Add a new or update an existing policy.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <param name="systemPolicyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemPolicyNameAsync(string name, SystemPolicyRequest systemPolicyRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemQuotasConfigRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemQuotasConfigAsync(SystemQuotasConfigRequest systemQuotasConfigRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the quota rule.</param>
        /// <param name="systemQuotasRateLimitRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemQuotasRateLimitNameAsync(string name, SystemQuotasRateLimitRequest systemQuotasRateLimitRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Update the value of the key at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRawRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemRawAsync(SystemRawRequest systemRawRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Update the value of the key at the given path.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path"></param>
        /// <param name="systemRawRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemRawPathAsync(string path, SystemRawRequest systemRawRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Initializes a new rekey attempt.
        /// </summary>
        /// <remarks>
        /// Only a single rekey attempt can take place at a time, and changing the parameters of a rekey requires canceling and starting a new rekey, which will also provide a new nonce.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRekeyInitRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemRekeyInitAsync(SystemRekeyInitRequest systemRekeyInitRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Enter a single unseal key share to progress the rekey of the Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRekeyUpdateRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemRekeyUpdateAsync(SystemRekeyUpdateRequest systemRekeyUpdateRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Enter a single new key share to progress the rekey verification operation.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRekeyVerifyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemRekeyVerifyAsync(SystemRekeyVerifyRequest systemRekeyVerifyRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Initiate a mount migration
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRemountRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemRemountAsync(SystemRemountRequest systemRemountRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Renews a lease, requesting to extend the lease.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRenewRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemRenewAsync(SystemRenewRequest systemRenewRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Renews a lease, requesting to extend the lease.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlLeaseId">The lease identifier to renew. This is included with a lease.</param>
        /// <param name="systemRenewLeaseRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemRenewUrlLeaseIdAsync(string urlLeaseId, SystemRenewLeaseRequest systemRenewLeaseRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Revokes a lease immediately.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRevokeRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemRevokeAsync(SystemRevokeRequest systemRevokeRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Revokes all secrets or tokens generated under a given prefix immediately
        /// </summary>
        /// <remarks>
        /// Unlike &#x60;/sys/leases/revoke-prefix&#x60;, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.  By ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to revoke keys under. Example: \&quot;prod/aws/ops\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemRevokeForcePrefixAsync(string prefix, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Revokes all secrets (via a lease ID prefix) or tokens (via the tokens&#39; path property) generated under a given prefix immediately.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to revoke keys under. Example: \&quot;prod/aws/ops\&quot;</param>
        /// <param name="systemRevokePrefixRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemRevokePrefixPrefixAsync(string prefix, SystemRevokePrefixRequest systemRevokePrefixRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Revokes a lease immediately.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlLeaseId">The lease identifier to renew. This is included with a lease.</param>
        /// <param name="systemRevokeLeaseRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemRevokeUrlLeaseIdAsync(string urlLeaseId, SystemRevokeLeaseRequest systemRevokeLeaseRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Rotates the backend encryption key used to persist data.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemRotateAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRotateConfigRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemRotateConfigAsync(SystemRotateConfigRequest systemRotateConfigRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Seal the Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemSealAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Cause the node to give up active status.
        /// </summary>
        /// <remarks>
        /// This endpoint forces the node to give up active status. If the node does not have active status, this endpoint does nothing. Note that the node will sleep for ten seconds before attempting to grab the active lock again, but if no standby nodes grab the active lock in the interim, the same node may become the active node again.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemStepDownAsync(CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemToolsHashRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemToolsHashAsync(SystemToolsHashRequest systemToolsHashRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a hash sum for input data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="systemToolsHashRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemToolsHashUrlalgorithmAsync(string urlalgorithm, SystemToolsHashRequest systemToolsHashRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemToolsRandomRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemToolsRandomAsync(SystemToolsRandomRequest systemToolsRandomRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="systemToolsRandomRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemToolsRandomSourceAsync(string source, SystemToolsRandomRequest systemToolsRandomRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="systemToolsRandomRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemToolsRandomSourceUrlbytesAsync(string source, string urlbytes, SystemToolsRandomRequest systemToolsRandomRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate random bytes
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="systemToolsRandomRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemToolsRandomUrlbytesAsync(string urlbytes, SystemToolsRandomRequest systemToolsRandomRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Unseal the Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemUnsealRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemUnsealAsync(SystemUnsealRequest systemUnsealRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Look up wrapping properties for the given token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemWrappingLookupRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemWrappingLookupAsync(SystemWrappingLookupRequest systemWrappingLookupRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Rotates a response-wrapped token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemWrappingRewrapRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemWrappingRewrapAsync(SystemWrappingRewrapRequest systemWrappingRewrapRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Unwraps a response-wrapped token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemWrappingUnwrapRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemWrappingUnwrapAsync(SystemWrappingUnwrapRequest systemWrappingUnwrapRequest, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Response-wraps an arbitrary JSON object.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateSystemWrappingWrapAsync(CancellationToken cancellationToken = default(CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISystem : ISystemSync, ISystemAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class System : ISystem
    {
        private Vault.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Constructor for System
        /// </summary>
        public System(ApiClient apiClient)
        {
            if (apiClient == null) throw new ArgumentNullException("ApiClient");
            
            this.Configuration = apiClient.Configuration;
            this.Client = apiClient;
            this.AsynchronousClient = apiClient;
            this.ExceptionFactory = Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Vault.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Vault.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Vault.Client.Configuration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Vault.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }


        /// <summary>
        /// Disable the audit device at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The name of the backend. Cannot be delimited. Example: \&quot;mysql\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemAuditPath(string path)
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->DeleteSystemAuditPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/audit/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemAuditPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Disable the audit device at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The name of the backend. Cannot be delimited. Example: \&quot;mysql\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemAuditPathAsync(string path, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->DeleteSystemAuditPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/audit/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemAuditPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Disable the auth method at the given auth path 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Cannot be delimited. Example: \&quot;user\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemAuthPath(string path)
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->DeleteSystemAuthPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/auth/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemAuthPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Disable the auth method at the given auth path 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Cannot be delimited. Example: \&quot;user\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemAuthPathAsync(string path, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->DeleteSystemAuthPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/auth/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemAuthPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Disable auditing of the given request header. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemConfigAuditingRequestHeadersHeader(string header)
        {
            // verify the required parameter 'header' is set
            if (header == null)
                throw new VaultApiException(400, "Missing required parameter 'header' when calling System->DeleteSystemConfigAuditingRequestHeadersHeader");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("header", ClientUtils.ParameterToString(header)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/config/auditing/request-headers/{header}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemConfigAuditingRequestHeadersHeader", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Disable auditing of the given request header. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemConfigAuditingRequestHeadersHeaderAsync(string header, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'header' is set
            if (header == null)
                throw new VaultApiException(400, "Missing required parameter 'header' when calling System->DeleteSystemConfigAuditingRequestHeadersHeader");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("header", ClientUtils.ParameterToString(header)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/config/auditing/request-headers/{header}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemConfigAuditingRequestHeadersHeader", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Remove any CORS settings. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemConfigCors()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/config/cors", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemConfigCors", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Remove any CORS settings. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemConfigCorsAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/config/cors", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemConfigCors", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Remove a UI header. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header">The name of the header.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemConfigUiHeadersHeader(string header)
        {
            // verify the required parameter 'header' is set
            if (header == null)
                throw new VaultApiException(400, "Missing required parameter 'header' when calling System->DeleteSystemConfigUiHeadersHeader");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("header", ClientUtils.ParameterToString(header)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/config/ui/headers/{header}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemConfigUiHeadersHeader", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Remove a UI header. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header">The name of the header.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemConfigUiHeadersHeaderAsync(string header, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'header' is set
            if (header == null)
                throw new VaultApiException(400, "Missing required parameter 'header' when calling System->DeleteSystemConfigUiHeadersHeader");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("header", ClientUtils.ParameterToString(header)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/config/ui/headers/{header}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemConfigUiHeadersHeader", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Cancels any in-progress root generation attempt. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemGenerateRoot()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/generate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemGenerateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Cancels any in-progress root generation attempt. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemGenerateRootAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/generate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemGenerateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Cancels any in-progress root generation attempt. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemGenerateRootAttempt()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/generate-root/attempt", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemGenerateRootAttempt", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Cancels any in-progress root generation attempt. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemGenerateRootAttemptAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/generate-root/attempt", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemGenerateRootAttempt", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revert the all loggers to use log level provided in config. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemLoggers()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/loggers", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemLoggers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revert the all loggers to use log level provided in config. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemLoggersAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/loggers", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemLoggers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revert a single logger to use log level provided in config. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the logger to be modified.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemLoggersName(string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->DeleteSystemLoggersName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/loggers/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemLoggersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revert a single logger to use log level provided in config. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the logger to be modified.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemLoggersNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->DeleteSystemLoggersName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/loggers/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemLoggersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Disable the mount point specified at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemMountsPath(string path)
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->DeleteSystemMountsPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/mounts/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemMountsPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Disable the mount point specified at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemMountsPathAsync(string path, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->DeleteSystemMountsPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/mounts/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemMountsPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Remove the plugin with the given name. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemPluginsCatalogName(string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->DeleteSystemPluginsCatalogName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/plugins/catalog/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemPluginsCatalogName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Remove the plugin with the given name. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemPluginsCatalogNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->DeleteSystemPluginsCatalogName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/plugins/catalog/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemPluginsCatalogName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Remove the plugin with the given name. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="type">The type of the plugin, may be auth, secret, or database</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemPluginsCatalogTypeName(string name, string type)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->DeleteSystemPluginsCatalogTypeName");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling System->DeleteSystemPluginsCatalogTypeName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/plugins/catalog/{type}/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemPluginsCatalogTypeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Remove the plugin with the given name. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="type">The type of the plugin, may be auth, secret, or database</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemPluginsCatalogTypeNameAsync(string name, string type, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->DeleteSystemPluginsCatalogTypeName");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling System->DeleteSystemPluginsCatalogTypeName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/plugins/catalog/{type}/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemPluginsCatalogTypeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete the ACL policy with the given name. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemPoliciesAclName(string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->DeleteSystemPoliciesAclName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/policies/acl/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemPoliciesAclName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete the ACL policy with the given name. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemPoliciesAclNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->DeleteSystemPoliciesAclName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/policies/acl/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemPoliciesAclName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete a password policy. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the password policy.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemPoliciesPasswordName(string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->DeleteSystemPoliciesPasswordName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/policies/password/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemPoliciesPasswordName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete a password policy. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the password policy.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemPoliciesPasswordNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->DeleteSystemPoliciesPasswordName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/policies/password/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemPoliciesPasswordName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete the policy with the given name. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemPolicyName(string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->DeleteSystemPolicyName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/policy/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemPolicyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete the policy with the given name. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemPolicyNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->DeleteSystemPolicyName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/policy/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemPolicyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the quota rule.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemQuotasRateLimitName(string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->DeleteSystemQuotasRateLimitName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/quotas/rate-limit/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemQuotasRateLimitName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the quota rule.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemQuotasRateLimitNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->DeleteSystemQuotasRateLimitName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/quotas/rate-limit/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemQuotasRateLimitName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete the key with given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemRaw()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/raw", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemRaw", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete the key with given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemRawAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/raw", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemRaw", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete the key with given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemRawPath(string path)
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->DeleteSystemRawPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/raw/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemRawPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete the key with given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemRawPathAsync(string path, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->DeleteSystemRawPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/raw/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemRawPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete the backup copy of PGP-encrypted unseal keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemRekeyBackup()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/rekey/backup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemRekeyBackup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete the backup copy of PGP-encrypted unseal keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemRekeyBackupAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/rekey/backup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemRekeyBackup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Cancels any in-progress rekey. This clears the rekey settings as well as any progress made. This must be called to change the parameters of the rekey. Note: verification is still a part of a rekey. If rekeying is canceled during the verification flow, the current unseal keys remain valid.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemRekeyInit()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/rekey/init", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemRekeyInit", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Cancels any in-progress rekey. This clears the rekey settings as well as any progress made. This must be called to change the parameters of the rekey. Note: verification is still a part of a rekey. If rekeying is canceled during the verification flow, the current unseal keys remain valid.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemRekeyInitAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/rekey/init", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemRekeyInit", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Allows fetching or deleting the backup of the rotated unseal keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemRekeyRecoveryKeyBackup()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/rekey/recovery-key-backup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemRekeyRecoveryKeyBackup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Allows fetching or deleting the backup of the rotated unseal keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemRekeyRecoveryKeyBackupAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/rekey/recovery-key-backup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemRekeyRecoveryKeyBackup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Cancel any in-progress rekey verification operation. This clears any progress made and resets the nonce. Unlike a &#x60;DELETE&#x60; against &#x60;sys/rekey/init&#x60;, this only resets the current verification operation, not the entire rekey atttempt.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteSystemRekeyVerify()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Delete<Object>("/sys/rekey/verify", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemRekeyVerify", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Cancel any in-progress rekey verification operation. This clears any progress made and resets the nonce. Unlike a &#x60;DELETE&#x60; against &#x60;sys/rekey/init&#x60;, this only resets the current verification operation, not the entire rekey atttempt.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteSystemRekeyVerifyAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/sys/rekey/verify", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteSystemRekeyVerify", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Return a list of configured UI headers. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListSystemConfigUiHeaders(string list)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling System->ListSystemConfigUiHeaders");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/config/ui/headers/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSystemConfigUiHeaders", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Return a list of configured UI headers. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListSystemConfigUiHeadersAsync(string list, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling System->ListSystemConfigUiHeaders");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/config/ui/headers/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSystemConfigUiHeaders", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns a list of lease ids. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListSystemLeasesLookup(string list)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling System->ListSystemLeasesLookup");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/leases/lookup/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSystemLeasesLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns a list of lease ids. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListSystemLeasesLookupAsync(string list, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling System->ListSystemLeasesLookup");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/leases/lookup/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSystemLeasesLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns a list of lease ids. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to list leases under. Example: \&quot;aws/creds/deploy\&quot;</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListSystemLeasesLookupPrefix(string prefix, string list)
        {
            // verify the required parameter 'prefix' is set
            if (prefix == null)
                throw new VaultApiException(400, "Missing required parameter 'prefix' when calling System->ListSystemLeasesLookupPrefix");

            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling System->ListSystemLeasesLookupPrefix");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("prefix", ClientUtils.ParameterToString(prefix)); // path parameter
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/leases/lookup/{prefix}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSystemLeasesLookupPrefix", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns a list of lease ids. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to list leases under. Example: \&quot;aws/creds/deploy\&quot;</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListSystemLeasesLookupPrefixAsync(string prefix, string list, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'prefix' is set
            if (prefix == null)
                throw new VaultApiException(400, "Missing required parameter 'prefix' when calling System->ListSystemLeasesLookupPrefix");

            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling System->ListSystemLeasesLookupPrefix");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("prefix", ClientUtils.ParameterToString(prefix)); // path parameter
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/leases/lookup/{prefix}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSystemLeasesLookupPrefix", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the plugins in the catalog. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="type">The type of the plugin, may be auth, secret, or database</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListSystemPluginsCatalogType(string type, string list)
        {
            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling System->ListSystemPluginsCatalogType");

            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling System->ListSystemPluginsCatalogType");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/plugins/catalog/{type}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSystemPluginsCatalogType", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the plugins in the catalog. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="type">The type of the plugin, may be auth, secret, or database</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListSystemPluginsCatalogTypeAsync(string type, string list, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling System->ListSystemPluginsCatalogType");

            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling System->ListSystemPluginsCatalogType");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/plugins/catalog/{type}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSystemPluginsCatalogType", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the configured access control policies. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListSystemPoliciesAcl(string list)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling System->ListSystemPoliciesAcl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/policies/acl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSystemPoliciesAcl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the configured access control policies. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListSystemPoliciesAclAsync(string list, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling System->ListSystemPoliciesAcl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/policies/acl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSystemPoliciesAcl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the existing password policies. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListSystemPoliciesPassword(string list)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling System->ListSystemPoliciesPassword");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/policies/password", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSystemPoliciesPassword", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the existing password policies. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListSystemPoliciesPasswordAsync(string list, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling System->ListSystemPoliciesPassword");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/policies/password", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSystemPoliciesPassword", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListSystemQuotasRateLimit(string list)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling System->ListSystemQuotasRateLimit");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/quotas/rate-limit", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSystemQuotasRateLimit", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListSystemQuotasRateLimitAsync(string list, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling System->ListSystemQuotasRateLimit");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/quotas/rate-limit", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSystemQuotasRateLimit", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns map of historical version change entries 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListSystemVersionHistory(string list)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling System->ListSystemVersionHistory");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/version-history/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSystemVersionHistory", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns map of historical version change entries 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListSystemVersionHistoryAsync(string list, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling System->ListSystemVersionHistory");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/version-history/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListSystemVersionHistory", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the enabled audit devices. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemAudit()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/audit", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemAudit", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the enabled audit devices. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemAuditAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/audit", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemAudit", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the currently enabled credential backends. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemAuth()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/auth", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemAuth", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the currently enabled credential backends. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemAuthAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/auth", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemAuth", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the configuration of the auth engine at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Cannot be delimited. Example: \&quot;user\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemAuthPath(string path)
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->ReadSystemAuthPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/auth/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemAuthPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the configuration of the auth engine at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Cannot be delimited. Example: \&quot;user\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemAuthPathAsync(string path, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->ReadSystemAuthPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/auth/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemAuthPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Reads the given auth path&#39;s configuration. This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via &#x60;sys/mounts/auth/[auth-path]/tune&#x60;.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Tune the configuration parameters for an auth path.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemAuthPathTune(string path)
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->ReadSystemAuthPathTune");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/auth/{path}/tune", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemAuthPathTune", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Reads the given auth path&#39;s configuration. This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via &#x60;sys/mounts/auth/[auth-path]/tune&#x60;.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Tune the configuration parameters for an auth path.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemAuthPathTuneAsync(string path, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->ReadSystemAuthPathTune");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/auth/{path}/tune", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemAuthPathTune", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the request headers that are configured to be audited. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemConfigAuditingRequestHeaders()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/config/auditing/request-headers", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemConfigAuditingRequestHeaders", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the request headers that are configured to be audited. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemConfigAuditingRequestHeadersAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/config/auditing/request-headers", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemConfigAuditingRequestHeaders", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the information for the given request header. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemConfigAuditingRequestHeadersHeader(string header)
        {
            // verify the required parameter 'header' is set
            if (header == null)
                throw new VaultApiException(400, "Missing required parameter 'header' when calling System->ReadSystemConfigAuditingRequestHeadersHeader");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("header", ClientUtils.ParameterToString(header)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/config/auditing/request-headers/{header}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemConfigAuditingRequestHeadersHeader", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the information for the given request header. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemConfigAuditingRequestHeadersHeaderAsync(string header, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'header' is set
            if (header == null)
                throw new VaultApiException(400, "Missing required parameter 'header' when calling System->ReadSystemConfigAuditingRequestHeadersHeader");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("header", ClientUtils.ParameterToString(header)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/config/auditing/request-headers/{header}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemConfigAuditingRequestHeadersHeader", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Return the current CORS settings. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemConfigCors()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/config/cors", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemConfigCors", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Return the current CORS settings. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemConfigCorsAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/config/cors", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemConfigCors", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Return a sanitized version of the Vault server configuration. The sanitized output strips configuration values in the storage, HA storage, and seals stanzas, which may contain sensitive values such as API tokens. It also removes any token or secret fields in other stanzas, such as the circonus_api_token from telemetry.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemConfigStateSanitized()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/config/state/sanitized", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemConfigStateSanitized", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Return a sanitized version of the Vault server configuration. The sanitized output strips configuration values in the storage, HA storage, and seals stanzas, which may contain sensitive values such as API tokens. It also removes any token or secret fields in other stanzas, such as the circonus_api_token from telemetry.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemConfigStateSanitizedAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/config/state/sanitized", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemConfigStateSanitized", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Return the given UI header&#39;s configuration 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header">The name of the header.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemConfigUiHeadersHeader(string header)
        {
            // verify the required parameter 'header' is set
            if (header == null)
                throw new VaultApiException(400, "Missing required parameter 'header' when calling System->ReadSystemConfigUiHeadersHeader");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("header", ClientUtils.ParameterToString(header)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/config/ui/headers/{header}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemConfigUiHeadersHeader", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Return the given UI header&#39;s configuration 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header">The name of the header.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemConfigUiHeadersHeaderAsync(string header, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'header' is set
            if (header == null)
                throw new VaultApiException(400, "Missing required parameter 'header' when calling System->ReadSystemConfigUiHeadersHeader");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("header", ClientUtils.ParameterToString(header)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/config/ui/headers/{header}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemConfigUiHeadersHeader", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the configuration and progress of the current root generation attempt. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemGenerateRoot()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/generate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemGenerateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the configuration and progress of the current root generation attempt. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemGenerateRootAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/generate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemGenerateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the configuration and progress of the current root generation attempt. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemGenerateRootAttempt()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/generate-root/attempt", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemGenerateRootAttempt", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the configuration and progress of the current root generation attempt. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemGenerateRootAttemptAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/generate-root/attempt", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemGenerateRootAttempt", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check the HA status of a Vault cluster 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemHaStatus()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/ha-status", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemHaStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check the HA status of a Vault cluster 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemHaStatusAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/ha-status", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemHaStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the health status of Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemHealth()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/health", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemHealth", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the health status of Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemHealthAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/health", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemHealth", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Information about the host instance that this Vault server is running on. Information about the host instance that this Vault server is running on.   The information that gets collected includes host hardware information, and CPU,   disk, and memory utilization
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemHostInfo()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/host-info", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemHostInfo", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Information about the host instance that this Vault server is running on. Information about the host instance that this Vault server is running on.   The information that gets collected includes host hardware information, and CPU,   disk, and memory utilization
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemHostInfoAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/host-info", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemHostInfo", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// reports in-flight requests This path responds to the following HTTP methods.   GET /    Returns a map of in-flight requests.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemInFlightReq()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/in-flight-req", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInFlightReq", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// reports in-flight requests This path responds to the following HTTP methods.   GET /    Returns a map of in-flight requests.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemInFlightReqAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/in-flight-req", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInFlightReq", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the initialization status of Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemInit()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/init", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInit", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the initialization status of Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemInitAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/init", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInit", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Report the client count metrics, for this namespace and all child namespaces. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemInternalCountersActivity()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/internal/counters/activity", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalCountersActivity", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Report the client count metrics, for this namespace and all child namespaces. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemInternalCountersActivityAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/internal/counters/activity", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalCountersActivity", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Report the client count metrics, for this namespace and all child namespaces. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemInternalCountersActivityExport()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/internal/counters/activity/export", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalCountersActivityExport", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Report the client count metrics, for this namespace and all child namespaces. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemInternalCountersActivityExportAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/internal/counters/activity/export", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalCountersActivityExport", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Report the number of clients for this month, for this namespace and all child namespaces. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemInternalCountersActivityMonthly()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/internal/counters/activity/monthly", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalCountersActivityMonthly", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Report the number of clients for this month, for this namespace and all child namespaces. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemInternalCountersActivityMonthlyAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/internal/counters/activity/monthly", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalCountersActivityMonthly", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the client count tracking configuration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemInternalCountersConfig()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/internal/counters/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalCountersConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the client count tracking configuration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemInternalCountersConfigAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/internal/counters/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalCountersConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Backwards compatibility is not guaranteed for this API 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemInternalCountersEntities()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/internal/counters/entities", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalCountersEntities", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Backwards compatibility is not guaranteed for this API 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemInternalCountersEntitiesAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/internal/counters/entities", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalCountersEntities", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Backwards compatibility is not guaranteed for this API 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemInternalCountersRequests()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/internal/counters/requests", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalCountersRequests", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Backwards compatibility is not guaranteed for this API 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemInternalCountersRequestsAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/internal/counters/requests", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalCountersRequests", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Backwards compatibility is not guaranteed for this API 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemInternalCountersTokens()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/internal/counters/tokens", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalCountersTokens", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Backwards compatibility is not guaranteed for this API 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemInternalCountersTokensAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/internal/counters/tokens", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalCountersTokens", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Expose the route entry and mount entry tables present in the router 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">Name of subtree being observed</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemInternalInspectRouterTag(string tag)
        {
            // verify the required parameter 'tag' is set
            if (tag == null)
                throw new VaultApiException(400, "Missing required parameter 'tag' when calling System->ReadSystemInternalInspectRouterTag");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("tag", ClientUtils.ParameterToString(tag)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/internal/inspect/router/{tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalInspectRouterTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Expose the route entry and mount entry tables present in the router 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">Name of subtree being observed</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemInternalInspectRouterTagAsync(string tag, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tag' is set
            if (tag == null)
                throw new VaultApiException(400, "Missing required parameter 'tag' when calling System->ReadSystemInternalInspectRouterTag");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("tag", ClientUtils.ParameterToString(tag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/internal/inspect/router/{tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalInspectRouterTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate an OpenAPI 3 document of all mounted paths. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemInternalSpecsOpenapi()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/internal/specs/openapi", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalSpecsOpenapi", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate an OpenAPI 3 document of all mounted paths. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemInternalSpecsOpenapiAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/internal/specs/openapi", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalSpecsOpenapi", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists enabled feature flags. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemInternalUiFeatureFlags()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/internal/ui/feature-flags", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalUiFeatureFlags", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists enabled feature flags. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemInternalUiFeatureFlagsAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/internal/ui/feature-flags", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalUiFeatureFlags", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all enabled and visible auth and secrets mounts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemInternalUiMounts()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/internal/ui/mounts", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalUiMounts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all enabled and visible auth and secrets mounts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemInternalUiMountsAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/internal/ui/mounts", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalUiMounts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Return information about the given mount. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path of the mount.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemInternalUiMountsPath(string path)
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->ReadSystemInternalUiMountsPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/internal/ui/mounts/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalUiMountsPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Return information about the given mount. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path of the mount.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemInternalUiMountsPathAsync(string path, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->ReadSystemInternalUiMountsPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/internal/ui/mounts/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalUiMountsPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Backwards compatibility is not guaranteed for this API 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemInternalUiNamespaces()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/internal/ui/namespaces", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalUiNamespaces", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Backwards compatibility is not guaranteed for this API 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemInternalUiNamespacesAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/internal/ui/namespaces", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalUiNamespaces", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Backwards compatibility is not guaranteed for this API 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemInternalUiResultantAcl()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/internal/ui/resultant-acl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalUiResultantAcl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Backwards compatibility is not guaranteed for this API 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemInternalUiResultantAclAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/internal/ui/resultant-acl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemInternalUiResultantAcl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Provides information about the backend encryption key. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemKeyStatus()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/key-status", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemKeyStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Provides information about the backend encryption key. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemKeyStatusAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/key-status", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemKeyStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the high availability status and current leader instance of Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemLeader()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/leader", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemLeader", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the high availability status and current leader instance of Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemLeaderAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/leader", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemLeader", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List leases associated with this Vault cluster 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemLeases()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/leases", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemLeases", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List leases associated with this Vault cluster 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemLeasesAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/leases", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemLeases", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Count of leases associated with this Vault cluster 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemLeasesCount()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/leases/count", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemLeasesCount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Count of leases associated with this Vault cluster 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemLeasesCountAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/leases/count", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemLeasesCount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Export the metrics aggregated for telemetry purpose. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="format">Format to export metrics into. Currently accepts only \&quot;prometheus\&quot;. (optional, default to &quot;&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemMetrics(string format = "")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/metrics", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemMetrics", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Export the metrics aggregated for telemetry purpose. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="format">Format to export metrics into. Currently accepts only \&quot;prometheus\&quot;. (optional, default to &quot;&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemMetricsAsync(string format = "", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/metrics", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemMetrics", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="logFormat">Output format of logs. Supported values are \&quot;standard\&quot; and \&quot;json\&quot;. The default is \&quot;standard\&quot;. (optional, default to &quot;standard&quot;)</param>
        /// <param name="logLevel">Log level to view system logs at. Currently supported values are \&quot;trace\&quot;, \&quot;debug\&quot;, \&quot;info\&quot;, \&quot;warn\&quot;, \&quot;error\&quot;. (optional, default to &quot;info&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemMonitor(string logFormat = "standard", string logLevel = "info")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (logFormat != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "log_format", logFormat));
            }
            if (logLevel != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "log_level", logLevel));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/monitor", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemMonitor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="logFormat">Output format of logs. Supported values are \&quot;standard\&quot; and \&quot;json\&quot;. The default is \&quot;standard\&quot;. (optional, default to &quot;standard&quot;)</param>
        /// <param name="logLevel">Log level to view system logs at. Currently supported values are \&quot;trace\&quot;, \&quot;debug\&quot;, \&quot;info\&quot;, \&quot;warn\&quot;, \&quot;error\&quot;. (optional, default to &quot;info&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemMonitorAsync(string logFormat = "standard", string logLevel = "info", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (logFormat != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "log_format", logFormat));
            }
            if (logLevel != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "log_level", logLevel));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/monitor", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemMonitor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the currently mounted backends. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemMounts()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/mounts", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemMounts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the currently mounted backends. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemMountsAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/mounts", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemMounts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the configuration of the secret engine at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemMountsPath(string path)
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->ReadSystemMountsPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/mounts/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemMountsPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the configuration of the secret engine at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemMountsPathAsync(string path, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->ReadSystemMountsPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/mounts/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemMountsPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Tune backend configuration parameters for this mount. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemMountsPathTune(string path)
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->ReadSystemMountsPathTune");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/mounts/{path}/tune", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemMountsPathTune", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Tune backend configuration parameters for this mount. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemMountsPathTuneAsync(string path, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->ReadSystemMountsPathTune");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/mounts/{path}/tune", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemMountsPathTune", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the plugins known to Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPluginsCatalog()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/plugins/catalog", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPluginsCatalog", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the plugins known to Vault 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPluginsCatalogAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/plugins/catalog", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPluginsCatalog", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Return the configuration data for the plugin with the given name. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPluginsCatalogName(string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->ReadSystemPluginsCatalogName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/plugins/catalog/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPluginsCatalogName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Return the configuration data for the plugin with the given name. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPluginsCatalogNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->ReadSystemPluginsCatalogName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/plugins/catalog/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPluginsCatalogName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Return the configuration data for the plugin with the given name. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="type">The type of the plugin, may be auth, secret, or database</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPluginsCatalogTypeName(string name, string type)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->ReadSystemPluginsCatalogTypeName");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling System->ReadSystemPluginsCatalogTypeName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/plugins/catalog/{type}/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPluginsCatalogTypeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Return the configuration data for the plugin with the given name. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="type">The type of the plugin, may be auth, secret, or database</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPluginsCatalogTypeNameAsync(string name, string type, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->ReadSystemPluginsCatalogTypeName");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling System->ReadSystemPluginsCatalogTypeName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/plugins/catalog/{type}/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPluginsCatalogTypeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve information about the named ACL policy. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPoliciesAclName(string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->ReadSystemPoliciesAclName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/policies/acl/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPoliciesAclName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve information about the named ACL policy. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPoliciesAclNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->ReadSystemPoliciesAclName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/policies/acl/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPoliciesAclName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve an existing password policy. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the password policy.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPoliciesPasswordName(string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->ReadSystemPoliciesPasswordName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/policies/password/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPoliciesPasswordName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve an existing password policy. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the password policy.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPoliciesPasswordNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->ReadSystemPoliciesPasswordName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/policies/password/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPoliciesPasswordName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a password from an existing password policy. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the password policy.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPoliciesPasswordNameGenerate(string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->ReadSystemPoliciesPasswordNameGenerate");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/policies/password/{name}/generate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPoliciesPasswordNameGenerate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a password from an existing password policy. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the password policy.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPoliciesPasswordNameGenerateAsync(string name, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->ReadSystemPoliciesPasswordNameGenerate");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/policies/password/{name}/generate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPoliciesPasswordNameGenerate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the configured access control policies. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPolicy(string list = "false")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/policy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPolicy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List the configured access control policies. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPolicyAsync(string list = "false", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/policy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPolicy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve the policy body for the named policy. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPolicyName(string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->ReadSystemPolicyName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/policy/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPolicyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve the policy body for the named policy. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPolicyNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->ReadSystemPolicyName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/policy/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPolicyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns an HTML page listing the available profiles. Returns an HTML page listing the available  profiles. This should be mainly accessed via browsers or applications that can  render pages.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPprof()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/pprof/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprof", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns an HTML page listing the available profiles. Returns an HTML page listing the available  profiles. This should be mainly accessed via browsers or applications that can  render pages.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPprofAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/pprof/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprof", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns a sampling of all past memory allocations. Returns a sampling of all past memory allocations.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPprofAllocs()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/pprof/allocs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofAllocs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns a sampling of all past memory allocations. Returns a sampling of all past memory allocations.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPprofAllocsAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/pprof/allocs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofAllocs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns stack traces that led to blocking on synchronization primitives Returns stack traces that led to blocking on synchronization primitives
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPprofBlock()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/pprof/block", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofBlock", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns stack traces that led to blocking on synchronization primitives Returns stack traces that led to blocking on synchronization primitives
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPprofBlockAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/pprof/block", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofBlock", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the running program&#39;s command line. Returns the running program&#39;s command line, with arguments separated by NUL bytes.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPprofCmdline()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/pprof/cmdline", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofCmdline", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the running program&#39;s command line. Returns the running program&#39;s command line, with arguments separated by NUL bytes.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPprofCmdlineAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/pprof/cmdline", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofCmdline", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns stack traces of all current goroutines. Returns stack traces of all current goroutines.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPprofGoroutine()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/pprof/goroutine", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofGoroutine", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns stack traces of all current goroutines. Returns stack traces of all current goroutines.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPprofGoroutineAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/pprof/goroutine", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofGoroutine", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns a sampling of memory allocations of live object. Returns a sampling of memory allocations of live object.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPprofHeap()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/pprof/heap", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofHeap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns a sampling of memory allocations of live object. Returns a sampling of memory allocations of live object.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPprofHeapAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/pprof/heap", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofHeap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns stack traces of holders of contended mutexes Returns stack traces of holders of contended mutexes
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPprofMutex()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/pprof/mutex", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofMutex", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns stack traces of holders of contended mutexes Returns stack traces of holders of contended mutexes
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPprofMutexAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/pprof/mutex", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofMutex", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns a pprof-formatted cpu profile payload. Returns a pprof-formatted cpu profile payload. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPprofProfile()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/pprof/profile", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofProfile", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns a pprof-formatted cpu profile payload. Returns a pprof-formatted cpu profile payload. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPprofProfileAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/pprof/profile", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofProfile", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the program counters listed in the request. Returns the program counters listed in the request.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPprofSymbol()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/pprof/symbol", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofSymbol", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the program counters listed in the request. Returns the program counters listed in the request.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPprofSymbolAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/pprof/symbol", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofSymbol", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns stack traces that led to the creation of new OS threads Returns stack traces that led to the creation of new OS threads
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPprofThreadcreate()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/pprof/threadcreate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofThreadcreate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns stack traces that led to the creation of new OS threads Returns stack traces that led to the creation of new OS threads
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPprofThreadcreateAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/pprof/threadcreate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofThreadcreate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the execution trace in binary form. Returns  the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemPprofTrace()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/pprof/trace", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofTrace", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the execution trace in binary form. Returns  the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemPprofTraceAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/pprof/trace", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemPprofTrace", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemQuotasConfig()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/quotas/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemQuotasConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemQuotasConfigAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/quotas/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemQuotasConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the quota rule.</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemQuotasRateLimitName(string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->ReadSystemQuotasRateLimitName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/quotas/rate-limit/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemQuotasRateLimitName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the quota rule.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemQuotasRateLimitNameAsync(string name, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->ReadSystemQuotasRateLimitName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/quotas/rate-limit/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemQuotasRateLimitName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the value of the key at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemRaw(string list = "false")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/raw", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemRaw", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the value of the key at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemRawAsync(string list = "false", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/raw", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemRaw", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the value of the key at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path"></param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemRawPath(string path, string list = "false")
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->ReadSystemRawPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/raw/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemRawPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the value of the key at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path"></param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemRawPathAsync(string path, string list = "false", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->ReadSystemRawPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/raw/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemRawPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Return the backup copy of PGP-encrypted unseal keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemRekeyBackup()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/rekey/backup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemRekeyBackup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Return the backup copy of PGP-encrypted unseal keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemRekeyBackupAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/rekey/backup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemRekeyBackup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Reads the configuration and progress of the current rekey attempt. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemRekeyInit()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/rekey/init", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemRekeyInit", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Reads the configuration and progress of the current rekey attempt. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemRekeyInitAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/rekey/init", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemRekeyInit", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Allows fetching or deleting the backup of the rotated unseal keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemRekeyRecoveryKeyBackup()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/rekey/recovery-key-backup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemRekeyRecoveryKeyBackup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Allows fetching or deleting the backup of the rotated unseal keys. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemRekeyRecoveryKeyBackupAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/rekey/recovery-key-backup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemRekeyRecoveryKeyBackup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the configuration and progress of the current rekey verification attempt. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemRekeyVerify()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/rekey/verify", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemRekeyVerify", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the configuration and progress of the current rekey verification attempt. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemRekeyVerifyAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/rekey/verify", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemRekeyVerify", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check status of a mount migration 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="migrationId">The ID of the migration operation</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemRemountStatusMigrationId(string migrationId)
        {
            // verify the required parameter 'migrationId' is set
            if (migrationId == null)
                throw new VaultApiException(400, "Missing required parameter 'migrationId' when calling System->ReadSystemRemountStatusMigrationId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("migration_id", ClientUtils.ParameterToString(migrationId)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/remount/status/{migration_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemRemountStatusMigrationId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check status of a mount migration 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="migrationId">The ID of the migration operation</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemRemountStatusMigrationIdAsync(string migrationId, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'migrationId' is set
            if (migrationId == null)
                throw new VaultApiException(400, "Missing required parameter 'migrationId' when calling System->ReadSystemRemountStatusMigrationId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("migration_id", ClientUtils.ParameterToString(migrationId)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/remount/status/{migration_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemRemountStatusMigrationId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemReplicationStatus()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/replication/status", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemReplicationStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemReplicationStatusAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/replication/status", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemReplicationStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemRotateConfig()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/rotate/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemRotateConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemRotateConfigAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/rotate/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemRotateConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check the seal status of a Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemSealStatus()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/seal-status", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemSealStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Check the seal status of a Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemSealStatusAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/seal-status", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemSealStatus", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Look up wrapping properties for the requester&#39;s token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadSystemWrappingLookup()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Get<Object>("/sys/wrapping/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemWrappingLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Look up wrapping properties for the requester&#39;s token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadSystemWrappingLookupAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/sys/wrapping/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadSystemWrappingLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// The hash of the given string via the given audit backend 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The name of the backend. Cannot be delimited. Example: \&quot;mysql\&quot;</param>
        /// <param name="systemAuditHashRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemAuditHashPath(string path, SystemAuditHashRequest systemAuditHashRequest)
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->UpdateSystemAuditHashPath");

            // verify the required parameter 'systemAuditHashRequest' is set
            if (systemAuditHashRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemAuditHashRequest' when calling System->UpdateSystemAuditHashPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = systemAuditHashRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/audit-hash/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemAuditHashPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// The hash of the given string via the given audit backend 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The name of the backend. Cannot be delimited. Example: \&quot;mysql\&quot;</param>
        /// <param name="systemAuditHashRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemAuditHashPathAsync(string path, SystemAuditHashRequest systemAuditHashRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->UpdateSystemAuditHashPath");

            // verify the required parameter 'systemAuditHashRequest' is set
            if (systemAuditHashRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemAuditHashRequest' when calling System->UpdateSystemAuditHashPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = systemAuditHashRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/audit-hash/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemAuditHashPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enable a new audit device at the supplied path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The name of the backend. Cannot be delimited. Example: \&quot;mysql\&quot;</param>
        /// <param name="systemAuditRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemAuditPath(string path, SystemAuditRequest systemAuditRequest)
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->UpdateSystemAuditPath");

            // verify the required parameter 'systemAuditRequest' is set
            if (systemAuditRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemAuditRequest' when calling System->UpdateSystemAuditPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = systemAuditRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/audit/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemAuditPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enable a new audit device at the supplied path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The name of the backend. Cannot be delimited. Example: \&quot;mysql\&quot;</param>
        /// <param name="systemAuditRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemAuditPathAsync(string path, SystemAuditRequest systemAuditRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->UpdateSystemAuditPath");

            // verify the required parameter 'systemAuditRequest' is set
            if (systemAuditRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemAuditRequest' when calling System->UpdateSystemAuditPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = systemAuditRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/audit/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemAuditPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enables a new auth method. After enabling, the auth method can be accessed and configured via the auth path specified as part of the URL. This auth path will be nested under the auth prefix.  For example, enable the \&quot;foo\&quot; auth method will make it accessible at /auth/foo.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Cannot be delimited. Example: \&quot;user\&quot;</param>
        /// <param name="systemAuthRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemAuthPath(string path, SystemAuthRequest systemAuthRequest)
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->UpdateSystemAuthPath");

            // verify the required parameter 'systemAuthRequest' is set
            if (systemAuthRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemAuthRequest' when calling System->UpdateSystemAuthPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = systemAuthRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/auth/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemAuthPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enables a new auth method. After enabling, the auth method can be accessed and configured via the auth path specified as part of the URL. This auth path will be nested under the auth prefix.  For example, enable the \&quot;foo\&quot; auth method will make it accessible at /auth/foo.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Cannot be delimited. Example: \&quot;user\&quot;</param>
        /// <param name="systemAuthRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemAuthPathAsync(string path, SystemAuthRequest systemAuthRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->UpdateSystemAuthPath");

            // verify the required parameter 'systemAuthRequest' is set
            if (systemAuthRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemAuthRequest' when calling System->UpdateSystemAuthPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = systemAuthRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/auth/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemAuthPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Tune configuration parameters for a given auth path. This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via &#x60;sys/mounts/auth/[auth-path]/tune&#x60;.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Tune the configuration parameters for an auth path.</param>
        /// <param name="systemAuthTuneRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemAuthPathTune(string path, SystemAuthTuneRequest systemAuthTuneRequest)
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->UpdateSystemAuthPathTune");

            // verify the required parameter 'systemAuthTuneRequest' is set
            if (systemAuthTuneRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemAuthTuneRequest' when calling System->UpdateSystemAuthPathTune");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = systemAuthTuneRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/auth/{path}/tune", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemAuthPathTune", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Tune configuration parameters for a given auth path. This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via &#x60;sys/mounts/auth/[auth-path]/tune&#x60;.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">Tune the configuration parameters for an auth path.</param>
        /// <param name="systemAuthTuneRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemAuthPathTuneAsync(string path, SystemAuthTuneRequest systemAuthTuneRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->UpdateSystemAuthPathTune");

            // verify the required parameter 'systemAuthTuneRequest' is set
            if (systemAuthTuneRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemAuthTuneRequest' when calling System->UpdateSystemAuthPathTune");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = systemAuthTuneRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/auth/{path}/tune", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemAuthPathTune", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Fetches the capabilities of the given token on the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemCapabilitiesRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemCapabilities(SystemCapabilitiesRequest systemCapabilitiesRequest)
        {
            // verify the required parameter 'systemCapabilitiesRequest' is set
            if (systemCapabilitiesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemCapabilitiesRequest' when calling System->UpdateSystemCapabilities");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemCapabilitiesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/capabilities", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemCapabilities", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Fetches the capabilities of the given token on the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemCapabilitiesRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemCapabilitiesAsync(SystemCapabilitiesRequest systemCapabilitiesRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemCapabilitiesRequest' is set
            if (systemCapabilitiesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemCapabilitiesRequest' when calling System->UpdateSystemCapabilities");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemCapabilitiesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/capabilities", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemCapabilities", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Fetches the capabilities of the token associated with the given token, on the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemCapabilitiesAccessorRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemCapabilitiesAccessor(SystemCapabilitiesAccessorRequest systemCapabilitiesAccessorRequest)
        {
            // verify the required parameter 'systemCapabilitiesAccessorRequest' is set
            if (systemCapabilitiesAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemCapabilitiesAccessorRequest' when calling System->UpdateSystemCapabilitiesAccessor");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemCapabilitiesAccessorRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/capabilities-accessor", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemCapabilitiesAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Fetches the capabilities of the token associated with the given token, on the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemCapabilitiesAccessorRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemCapabilitiesAccessorAsync(SystemCapabilitiesAccessorRequest systemCapabilitiesAccessorRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemCapabilitiesAccessorRequest' is set
            if (systemCapabilitiesAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemCapabilitiesAccessorRequest' when calling System->UpdateSystemCapabilitiesAccessor");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemCapabilitiesAccessorRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/capabilities-accessor", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemCapabilitiesAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Fetches the capabilities of the given token on the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemCapabilitiesSelfRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemCapabilitiesSelf(SystemCapabilitiesSelfRequest systemCapabilitiesSelfRequest)
        {
            // verify the required parameter 'systemCapabilitiesSelfRequest' is set
            if (systemCapabilitiesSelfRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemCapabilitiesSelfRequest' when calling System->UpdateSystemCapabilitiesSelf");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemCapabilitiesSelfRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/capabilities-self", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemCapabilitiesSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Fetches the capabilities of the given token on the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemCapabilitiesSelfRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemCapabilitiesSelfAsync(SystemCapabilitiesSelfRequest systemCapabilitiesSelfRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemCapabilitiesSelfRequest' is set
            if (systemCapabilitiesSelfRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemCapabilitiesSelfRequest' when calling System->UpdateSystemCapabilitiesSelf");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemCapabilitiesSelfRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/capabilities-self", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemCapabilitiesSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enable auditing of a header. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header"></param>
        /// <param name="systemConfigAuditingRequestHeadersRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemConfigAuditingRequestHeadersHeader(string header, SystemConfigAuditingRequestHeadersRequest systemConfigAuditingRequestHeadersRequest)
        {
            // verify the required parameter 'header' is set
            if (header == null)
                throw new VaultApiException(400, "Missing required parameter 'header' when calling System->UpdateSystemConfigAuditingRequestHeadersHeader");

            // verify the required parameter 'systemConfigAuditingRequestHeadersRequest' is set
            if (systemConfigAuditingRequestHeadersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemConfigAuditingRequestHeadersRequest' when calling System->UpdateSystemConfigAuditingRequestHeadersHeader");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("header", ClientUtils.ParameterToString(header)); // path parameter
            requestOptions.Data = systemConfigAuditingRequestHeadersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/config/auditing/request-headers/{header}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemConfigAuditingRequestHeadersHeader", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enable auditing of a header. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header"></param>
        /// <param name="systemConfigAuditingRequestHeadersRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemConfigAuditingRequestHeadersHeaderAsync(string header, SystemConfigAuditingRequestHeadersRequest systemConfigAuditingRequestHeadersRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'header' is set
            if (header == null)
                throw new VaultApiException(400, "Missing required parameter 'header' when calling System->UpdateSystemConfigAuditingRequestHeadersHeader");

            // verify the required parameter 'systemConfigAuditingRequestHeadersRequest' is set
            if (systemConfigAuditingRequestHeadersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemConfigAuditingRequestHeadersRequest' when calling System->UpdateSystemConfigAuditingRequestHeadersHeader");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("header", ClientUtils.ParameterToString(header)); // path parameter
            requestOptions.Data = systemConfigAuditingRequestHeadersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/config/auditing/request-headers/{header}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemConfigAuditingRequestHeadersHeader", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the CORS settings. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemConfigCorsRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemConfigCors(SystemConfigCorsRequest systemConfigCorsRequest)
        {
            // verify the required parameter 'systemConfigCorsRequest' is set
            if (systemConfigCorsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemConfigCorsRequest' when calling System->UpdateSystemConfigCors");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemConfigCorsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/config/cors", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemConfigCors", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the CORS settings. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemConfigCorsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemConfigCorsAsync(SystemConfigCorsRequest systemConfigCorsRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemConfigCorsRequest' is set
            if (systemConfigCorsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemConfigCorsRequest' when calling System->UpdateSystemConfigCors");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemConfigCorsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/config/cors", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemConfigCors", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Reload the given subsystem 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="subsystem"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemConfigReloadSubsystem(string subsystem)
        {
            // verify the required parameter 'subsystem' is set
            if (subsystem == null)
                throw new VaultApiException(400, "Missing required parameter 'subsystem' when calling System->UpdateSystemConfigReloadSubsystem");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("subsystem", ClientUtils.ParameterToString(subsystem)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/config/reload/{subsystem}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemConfigReloadSubsystem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Reload the given subsystem 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="subsystem"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemConfigReloadSubsystemAsync(string subsystem, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'subsystem' is set
            if (subsystem == null)
                throw new VaultApiException(400, "Missing required parameter 'subsystem' when calling System->UpdateSystemConfigReloadSubsystem");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("subsystem", ClientUtils.ParameterToString(subsystem)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/config/reload/{subsystem}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemConfigReloadSubsystem", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the values to be returned for the UI header. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header">The name of the header.</param>
        /// <param name="systemConfigUiHeadersRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemConfigUiHeadersHeader(string header, SystemConfigUiHeadersRequest systemConfigUiHeadersRequest)
        {
            // verify the required parameter 'header' is set
            if (header == null)
                throw new VaultApiException(400, "Missing required parameter 'header' when calling System->UpdateSystemConfigUiHeadersHeader");

            // verify the required parameter 'systemConfigUiHeadersRequest' is set
            if (systemConfigUiHeadersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemConfigUiHeadersRequest' when calling System->UpdateSystemConfigUiHeadersHeader");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("header", ClientUtils.ParameterToString(header)); // path parameter
            requestOptions.Data = systemConfigUiHeadersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/config/ui/headers/{header}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemConfigUiHeadersHeader", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the values to be returned for the UI header. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="header">The name of the header.</param>
        /// <param name="systemConfigUiHeadersRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemConfigUiHeadersHeaderAsync(string header, SystemConfigUiHeadersRequest systemConfigUiHeadersRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'header' is set
            if (header == null)
                throw new VaultApiException(400, "Missing required parameter 'header' when calling System->UpdateSystemConfigUiHeadersHeader");

            // verify the required parameter 'systemConfigUiHeadersRequest' is set
            if (systemConfigUiHeadersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemConfigUiHeadersRequest' when calling System->UpdateSystemConfigUiHeadersHeader");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("header", ClientUtils.ParameterToString(header)); // path parameter
            requestOptions.Data = systemConfigUiHeadersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/config/ui/headers/{header}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemConfigUiHeadersHeader", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Initializes a new root generation attempt. Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemGenerateRootRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemGenerateRoot(SystemGenerateRootRequest systemGenerateRootRequest)
        {
            // verify the required parameter 'systemGenerateRootRequest' is set
            if (systemGenerateRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemGenerateRootRequest' when calling System->UpdateSystemGenerateRoot");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemGenerateRootRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/generate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemGenerateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Initializes a new root generation attempt. Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemGenerateRootRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemGenerateRootAsync(SystemGenerateRootRequest systemGenerateRootRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemGenerateRootRequest' is set
            if (systemGenerateRootRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemGenerateRootRequest' when calling System->UpdateSystemGenerateRoot");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemGenerateRootRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/generate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemGenerateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Initializes a new root generation attempt. Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemGenerateRootAttemptRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemGenerateRootAttempt(SystemGenerateRootAttemptRequest systemGenerateRootAttemptRequest)
        {
            // verify the required parameter 'systemGenerateRootAttemptRequest' is set
            if (systemGenerateRootAttemptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemGenerateRootAttemptRequest' when calling System->UpdateSystemGenerateRootAttempt");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemGenerateRootAttemptRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/generate-root/attempt", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemGenerateRootAttempt", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Initializes a new root generation attempt. Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemGenerateRootAttemptRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemGenerateRootAttemptAsync(SystemGenerateRootAttemptRequest systemGenerateRootAttemptRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemGenerateRootAttemptRequest' is set
            if (systemGenerateRootAttemptRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemGenerateRootAttemptRequest' when calling System->UpdateSystemGenerateRootAttempt");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemGenerateRootAttemptRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/generate-root/attempt", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemGenerateRootAttempt", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enter a single unseal key share to progress the root generation attempt. If the threshold number of unseal key shares is reached, Vault will complete the root generation and issue the new token. Otherwise, this API must be called multiple times until that threshold is met. The attempt nonce must be provided with each call.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemGenerateRootUpdateRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemGenerateRootUpdate(SystemGenerateRootUpdateRequest systemGenerateRootUpdateRequest)
        {
            // verify the required parameter 'systemGenerateRootUpdateRequest' is set
            if (systemGenerateRootUpdateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemGenerateRootUpdateRequest' when calling System->UpdateSystemGenerateRootUpdate");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemGenerateRootUpdateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/generate-root/update", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemGenerateRootUpdate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enter a single unseal key share to progress the root generation attempt. If the threshold number of unseal key shares is reached, Vault will complete the root generation and issue the new token. Otherwise, this API must be called multiple times until that threshold is met. The attempt nonce must be provided with each call.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemGenerateRootUpdateRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemGenerateRootUpdateAsync(SystemGenerateRootUpdateRequest systemGenerateRootUpdateRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemGenerateRootUpdateRequest' is set
            if (systemGenerateRootUpdateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemGenerateRootUpdateRequest' when calling System->UpdateSystemGenerateRootUpdate");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemGenerateRootUpdateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/generate-root/update", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemGenerateRootUpdate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Initialize a new Vault. The Vault must not have been previously initialized. The recovery options, as well as the stored shares option, are only available when using Vault HSM.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemInitRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemInit(SystemInitRequest systemInitRequest)
        {
            // verify the required parameter 'systemInitRequest' is set
            if (systemInitRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemInitRequest' when calling System->UpdateSystemInit");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemInitRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/init", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemInit", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Initialize a new Vault. The Vault must not have been previously initialized. The recovery options, as well as the stored shares option, are only available when using Vault HSM.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemInitRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemInitAsync(SystemInitRequest systemInitRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemInitRequest' is set
            if (systemInitRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemInitRequest' when calling System->UpdateSystemInit");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemInitRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/init", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemInit", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enable or disable collection of client count, set retention period, or set default reporting period. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemInternalCountersConfigRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemInternalCountersConfig(SystemInternalCountersConfigRequest systemInternalCountersConfigRequest)
        {
            // verify the required parameter 'systemInternalCountersConfigRequest' is set
            if (systemInternalCountersConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemInternalCountersConfigRequest' when calling System->UpdateSystemInternalCountersConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemInternalCountersConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/internal/counters/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemInternalCountersConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enable or disable collection of client count, set retention period, or set default reporting period. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemInternalCountersConfigRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemInternalCountersConfigAsync(SystemInternalCountersConfigRequest systemInternalCountersConfigRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemInternalCountersConfigRequest' is set
            if (systemInternalCountersConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemInternalCountersConfigRequest' when calling System->UpdateSystemInternalCountersConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemInternalCountersConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/internal/counters/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemInternalCountersConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve lease metadata. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemLeasesLookupRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemLeasesLookup(SystemLeasesLookupRequest systemLeasesLookupRequest)
        {
            // verify the required parameter 'systemLeasesLookupRequest' is set
            if (systemLeasesLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemLeasesLookupRequest' when calling System->UpdateSystemLeasesLookup");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemLeasesLookupRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/leases/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLeasesLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Retrieve lease metadata. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemLeasesLookupRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemLeasesLookupAsync(SystemLeasesLookupRequest systemLeasesLookupRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemLeasesLookupRequest' is set
            if (systemLeasesLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemLeasesLookupRequest' when calling System->UpdateSystemLeasesLookup");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemLeasesLookupRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/leases/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLeasesLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Renews a lease, requesting to extend the lease. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemLeasesRenewRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemLeasesRenew(SystemLeasesRenewRequest systemLeasesRenewRequest)
        {
            // verify the required parameter 'systemLeasesRenewRequest' is set
            if (systemLeasesRenewRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemLeasesRenewRequest' when calling System->UpdateSystemLeasesRenew");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemLeasesRenewRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/leases/renew", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLeasesRenew", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Renews a lease, requesting to extend the lease. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemLeasesRenewRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemLeasesRenewAsync(SystemLeasesRenewRequest systemLeasesRenewRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemLeasesRenewRequest' is set
            if (systemLeasesRenewRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemLeasesRenewRequest' when calling System->UpdateSystemLeasesRenew");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemLeasesRenewRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/leases/renew", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLeasesRenew", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Renews a lease, requesting to extend the lease. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlLeaseId">The lease identifier to renew. This is included with a lease.</param>
        /// <param name="systemLeasesRenewLeaseRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemLeasesRenewUrlLeaseId(string urlLeaseId, SystemLeasesRenewLeaseRequest systemLeasesRenewLeaseRequest)
        {
            // verify the required parameter 'urlLeaseId' is set
            if (urlLeaseId == null)
                throw new VaultApiException(400, "Missing required parameter 'urlLeaseId' when calling System->UpdateSystemLeasesRenewUrlLeaseId");

            // verify the required parameter 'systemLeasesRenewLeaseRequest' is set
            if (systemLeasesRenewLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemLeasesRenewLeaseRequest' when calling System->UpdateSystemLeasesRenewUrlLeaseId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("url_lease_id", ClientUtils.ParameterToString(urlLeaseId)); // path parameter
            requestOptions.Data = systemLeasesRenewLeaseRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/leases/renew/{url_lease_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLeasesRenewUrlLeaseId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Renews a lease, requesting to extend the lease. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlLeaseId">The lease identifier to renew. This is included with a lease.</param>
        /// <param name="systemLeasesRenewLeaseRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemLeasesRenewUrlLeaseIdAsync(string urlLeaseId, SystemLeasesRenewLeaseRequest systemLeasesRenewLeaseRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'urlLeaseId' is set
            if (urlLeaseId == null)
                throw new VaultApiException(400, "Missing required parameter 'urlLeaseId' when calling System->UpdateSystemLeasesRenewUrlLeaseId");

            // verify the required parameter 'systemLeasesRenewLeaseRequest' is set
            if (systemLeasesRenewLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemLeasesRenewLeaseRequest' when calling System->UpdateSystemLeasesRenewUrlLeaseId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("url_lease_id", ClientUtils.ParameterToString(urlLeaseId)); // path parameter
            requestOptions.Data = systemLeasesRenewLeaseRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/leases/renew/{url_lease_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLeasesRenewUrlLeaseId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revokes a lease immediately. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemLeasesRevokeRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemLeasesRevoke(SystemLeasesRevokeRequest systemLeasesRevokeRequest)
        {
            // verify the required parameter 'systemLeasesRevokeRequest' is set
            if (systemLeasesRevokeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemLeasesRevokeRequest' when calling System->UpdateSystemLeasesRevoke");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemLeasesRevokeRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/leases/revoke", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLeasesRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revokes a lease immediately. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemLeasesRevokeRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemLeasesRevokeAsync(SystemLeasesRevokeRequest systemLeasesRevokeRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemLeasesRevokeRequest' is set
            if (systemLeasesRevokeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemLeasesRevokeRequest' when calling System->UpdateSystemLeasesRevoke");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemLeasesRevokeRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/leases/revoke", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLeasesRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revokes all secrets or tokens generated under a given prefix immediately Unlike &#x60;/sys/leases/revoke-prefix&#x60;, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.  By ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to revoke keys under. Example: \&quot;prod/aws/ops\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemLeasesRevokeForcePrefix(string prefix)
        {
            // verify the required parameter 'prefix' is set
            if (prefix == null)
                throw new VaultApiException(400, "Missing required parameter 'prefix' when calling System->UpdateSystemLeasesRevokeForcePrefix");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("prefix", ClientUtils.ParameterToString(prefix)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/leases/revoke-force/{prefix}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLeasesRevokeForcePrefix", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revokes all secrets or tokens generated under a given prefix immediately Unlike &#x60;/sys/leases/revoke-prefix&#x60;, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.  By ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to revoke keys under. Example: \&quot;prod/aws/ops\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemLeasesRevokeForcePrefixAsync(string prefix, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'prefix' is set
            if (prefix == null)
                throw new VaultApiException(400, "Missing required parameter 'prefix' when calling System->UpdateSystemLeasesRevokeForcePrefix");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("prefix", ClientUtils.ParameterToString(prefix)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/leases/revoke-force/{prefix}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLeasesRevokeForcePrefix", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revokes all secrets (via a lease ID prefix) or tokens (via the tokens&#39; path property) generated under a given prefix immediately. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to revoke keys under. Example: \&quot;prod/aws/ops\&quot;</param>
        /// <param name="systemLeasesRevokePrefixRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemLeasesRevokePrefixPrefix(string prefix, SystemLeasesRevokePrefixRequest systemLeasesRevokePrefixRequest)
        {
            // verify the required parameter 'prefix' is set
            if (prefix == null)
                throw new VaultApiException(400, "Missing required parameter 'prefix' when calling System->UpdateSystemLeasesRevokePrefixPrefix");

            // verify the required parameter 'systemLeasesRevokePrefixRequest' is set
            if (systemLeasesRevokePrefixRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemLeasesRevokePrefixRequest' when calling System->UpdateSystemLeasesRevokePrefixPrefix");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("prefix", ClientUtils.ParameterToString(prefix)); // path parameter
            requestOptions.Data = systemLeasesRevokePrefixRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/leases/revoke-prefix/{prefix}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLeasesRevokePrefixPrefix", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revokes all secrets (via a lease ID prefix) or tokens (via the tokens&#39; path property) generated under a given prefix immediately. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to revoke keys under. Example: \&quot;prod/aws/ops\&quot;</param>
        /// <param name="systemLeasesRevokePrefixRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemLeasesRevokePrefixPrefixAsync(string prefix, SystemLeasesRevokePrefixRequest systemLeasesRevokePrefixRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'prefix' is set
            if (prefix == null)
                throw new VaultApiException(400, "Missing required parameter 'prefix' when calling System->UpdateSystemLeasesRevokePrefixPrefix");

            // verify the required parameter 'systemLeasesRevokePrefixRequest' is set
            if (systemLeasesRevokePrefixRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemLeasesRevokePrefixRequest' when calling System->UpdateSystemLeasesRevokePrefixPrefix");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("prefix", ClientUtils.ParameterToString(prefix)); // path parameter
            requestOptions.Data = systemLeasesRevokePrefixRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/leases/revoke-prefix/{prefix}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLeasesRevokePrefixPrefix", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revokes a lease immediately. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlLeaseId">The lease identifier to renew. This is included with a lease.</param>
        /// <param name="systemLeasesRevokeLeaseRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemLeasesRevokeUrlLeaseId(string urlLeaseId, SystemLeasesRevokeLeaseRequest systemLeasesRevokeLeaseRequest)
        {
            // verify the required parameter 'urlLeaseId' is set
            if (urlLeaseId == null)
                throw new VaultApiException(400, "Missing required parameter 'urlLeaseId' when calling System->UpdateSystemLeasesRevokeUrlLeaseId");

            // verify the required parameter 'systemLeasesRevokeLeaseRequest' is set
            if (systemLeasesRevokeLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemLeasesRevokeLeaseRequest' when calling System->UpdateSystemLeasesRevokeUrlLeaseId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("url_lease_id", ClientUtils.ParameterToString(urlLeaseId)); // path parameter
            requestOptions.Data = systemLeasesRevokeLeaseRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/leases/revoke/{url_lease_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLeasesRevokeUrlLeaseId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revokes a lease immediately. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlLeaseId">The lease identifier to renew. This is included with a lease.</param>
        /// <param name="systemLeasesRevokeLeaseRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemLeasesRevokeUrlLeaseIdAsync(string urlLeaseId, SystemLeasesRevokeLeaseRequest systemLeasesRevokeLeaseRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'urlLeaseId' is set
            if (urlLeaseId == null)
                throw new VaultApiException(400, "Missing required parameter 'urlLeaseId' when calling System->UpdateSystemLeasesRevokeUrlLeaseId");

            // verify the required parameter 'systemLeasesRevokeLeaseRequest' is set
            if (systemLeasesRevokeLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemLeasesRevokeLeaseRequest' when calling System->UpdateSystemLeasesRevokeUrlLeaseId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("url_lease_id", ClientUtils.ParameterToString(urlLeaseId)); // path parameter
            requestOptions.Data = systemLeasesRevokeLeaseRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/leases/revoke/{url_lease_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLeasesRevokeUrlLeaseId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemLeasesTidy()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/leases/tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLeasesTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemLeasesTidyAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/leases/tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLeasesTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Modify the log level for all existing loggers. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemLoggersRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemLoggers(SystemLoggersRequest systemLoggersRequest)
        {
            // verify the required parameter 'systemLoggersRequest' is set
            if (systemLoggersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemLoggersRequest' when calling System->UpdateSystemLoggers");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemLoggersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/loggers", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLoggers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Modify the log level for all existing loggers. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemLoggersRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemLoggersAsync(SystemLoggersRequest systemLoggersRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemLoggersRequest' is set
            if (systemLoggersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemLoggersRequest' when calling System->UpdateSystemLoggers");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemLoggersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/loggers", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLoggers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Modify the log level of a single logger. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the logger to be modified.</param>
        /// <param name="systemLoggersRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemLoggersName(string name, SystemLoggersRequest systemLoggersRequest)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->UpdateSystemLoggersName");

            // verify the required parameter 'systemLoggersRequest' is set
            if (systemLoggersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemLoggersRequest' when calling System->UpdateSystemLoggersName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = systemLoggersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/loggers/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLoggersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Modify the log level of a single logger. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the logger to be modified.</param>
        /// <param name="systemLoggersRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemLoggersNameAsync(string name, SystemLoggersRequest systemLoggersRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->UpdateSystemLoggersName");

            // verify the required parameter 'systemLoggersRequest' is set
            if (systemLoggersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemLoggersRequest' when calling System->UpdateSystemLoggersName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = systemLoggersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/loggers/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemLoggersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Validates the login for the given MFA methods. Upon successful validation, it returns an auth response containing the client token 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemMfaValidateRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemMfaValidate(SystemMfaValidateRequest systemMfaValidateRequest)
        {
            // verify the required parameter 'systemMfaValidateRequest' is set
            if (systemMfaValidateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemMfaValidateRequest' when calling System->UpdateSystemMfaValidate");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemMfaValidateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/mfa/validate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemMfaValidate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Validates the login for the given MFA methods. Upon successful validation, it returns an auth response containing the client token 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemMfaValidateRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemMfaValidateAsync(SystemMfaValidateRequest systemMfaValidateRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemMfaValidateRequest' is set
            if (systemMfaValidateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemMfaValidateRequest' when calling System->UpdateSystemMfaValidate");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemMfaValidateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/mfa/validate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemMfaValidate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enable a new secrets engine at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <param name="systemMountsRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemMountsPath(string path, SystemMountsRequest systemMountsRequest)
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->UpdateSystemMountsPath");

            // verify the required parameter 'systemMountsRequest' is set
            if (systemMountsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemMountsRequest' when calling System->UpdateSystemMountsPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = systemMountsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/mounts/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemMountsPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enable a new secrets engine at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <param name="systemMountsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemMountsPathAsync(string path, SystemMountsRequest systemMountsRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->UpdateSystemMountsPath");

            // verify the required parameter 'systemMountsRequest' is set
            if (systemMountsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemMountsRequest' when calling System->UpdateSystemMountsPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = systemMountsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/mounts/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemMountsPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Tune backend configuration parameters for this mount. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <param name="systemMountsTuneRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemMountsPathTune(string path, SystemMountsTuneRequest systemMountsTuneRequest)
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->UpdateSystemMountsPathTune");

            // verify the required parameter 'systemMountsTuneRequest' is set
            if (systemMountsTuneRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemMountsTuneRequest' when calling System->UpdateSystemMountsPathTune");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = systemMountsTuneRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/mounts/{path}/tune", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemMountsPathTune", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Tune backend configuration parameters for this mount. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path">The path to mount to. Example: \&quot;aws/east\&quot;</param>
        /// <param name="systemMountsTuneRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemMountsPathTuneAsync(string path, SystemMountsTuneRequest systemMountsTuneRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->UpdateSystemMountsPathTune");

            // verify the required parameter 'systemMountsTuneRequest' is set
            if (systemMountsTuneRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemMountsTuneRequest' when calling System->UpdateSystemMountsPathTune");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = systemMountsTuneRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/mounts/{path}/tune", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemMountsPathTune", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register a new plugin, or updates an existing one with the supplied name. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="systemPluginsCatalogRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemPluginsCatalogName(string name, SystemPluginsCatalogRequest systemPluginsCatalogRequest)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->UpdateSystemPluginsCatalogName");

            // verify the required parameter 'systemPluginsCatalogRequest' is set
            if (systemPluginsCatalogRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemPluginsCatalogRequest' when calling System->UpdateSystemPluginsCatalogName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = systemPluginsCatalogRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/plugins/catalog/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemPluginsCatalogName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register a new plugin, or updates an existing one with the supplied name. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="systemPluginsCatalogRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemPluginsCatalogNameAsync(string name, SystemPluginsCatalogRequest systemPluginsCatalogRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->UpdateSystemPluginsCatalogName");

            // verify the required parameter 'systemPluginsCatalogRequest' is set
            if (systemPluginsCatalogRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemPluginsCatalogRequest' when calling System->UpdateSystemPluginsCatalogName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = systemPluginsCatalogRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/plugins/catalog/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemPluginsCatalogName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register a new plugin, or updates an existing one with the supplied name. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="type">The type of the plugin, may be auth, secret, or database</param>
        /// <param name="systemPluginsCatalogRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemPluginsCatalogTypeName(string name, string type, SystemPluginsCatalogRequest systemPluginsCatalogRequest)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->UpdateSystemPluginsCatalogTypeName");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling System->UpdateSystemPluginsCatalogTypeName");

            // verify the required parameter 'systemPluginsCatalogRequest' is set
            if (systemPluginsCatalogRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemPluginsCatalogRequest' when calling System->UpdateSystemPluginsCatalogTypeName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter
            requestOptions.Data = systemPluginsCatalogRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/plugins/catalog/{type}/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemPluginsCatalogTypeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register a new plugin, or updates an existing one with the supplied name. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the plugin</param>
        /// <param name="type">The type of the plugin, may be auth, secret, or database</param>
        /// <param name="systemPluginsCatalogRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemPluginsCatalogTypeNameAsync(string name, string type, SystemPluginsCatalogRequest systemPluginsCatalogRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->UpdateSystemPluginsCatalogTypeName");

            // verify the required parameter 'type' is set
            if (type == null)
                throw new VaultApiException(400, "Missing required parameter 'type' when calling System->UpdateSystemPluginsCatalogTypeName");

            // verify the required parameter 'systemPluginsCatalogRequest' is set
            if (systemPluginsCatalogRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemPluginsCatalogRequest' when calling System->UpdateSystemPluginsCatalogTypeName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.PathParameters.Add("type", ClientUtils.ParameterToString(type)); // path parameter
            requestOptions.Data = systemPluginsCatalogRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/plugins/catalog/{type}/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemPluginsCatalogTypeName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Reload mounted plugin backends. Either the plugin name (&#x60;plugin&#x60;) or the desired plugin backend mounts (&#x60;mounts&#x60;) must be provided, but not both. In the case that the plugin name is provided, all mounted paths that use that plugin backend will be reloaded.  If (&#x60;scope&#x60;) is provided and is (&#x60;global&#x60;), the plugin(s) are reloaded globally.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemPluginsReloadBackendRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemPluginsReloadBackend(SystemPluginsReloadBackendRequest systemPluginsReloadBackendRequest)
        {
            // verify the required parameter 'systemPluginsReloadBackendRequest' is set
            if (systemPluginsReloadBackendRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemPluginsReloadBackendRequest' when calling System->UpdateSystemPluginsReloadBackend");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemPluginsReloadBackendRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/plugins/reload/backend", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemPluginsReloadBackend", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Reload mounted plugin backends. Either the plugin name (&#x60;plugin&#x60;) or the desired plugin backend mounts (&#x60;mounts&#x60;) must be provided, but not both. In the case that the plugin name is provided, all mounted paths that use that plugin backend will be reloaded.  If (&#x60;scope&#x60;) is provided and is (&#x60;global&#x60;), the plugin(s) are reloaded globally.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemPluginsReloadBackendRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemPluginsReloadBackendAsync(SystemPluginsReloadBackendRequest systemPluginsReloadBackendRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemPluginsReloadBackendRequest' is set
            if (systemPluginsReloadBackendRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemPluginsReloadBackendRequest' when calling System->UpdateSystemPluginsReloadBackend");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemPluginsReloadBackendRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/plugins/reload/backend", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemPluginsReloadBackend", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Add a new or update an existing ACL policy. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <param name="systemPoliciesAclRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemPoliciesAclName(string name, SystemPoliciesAclRequest systemPoliciesAclRequest)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->UpdateSystemPoliciesAclName");

            // verify the required parameter 'systemPoliciesAclRequest' is set
            if (systemPoliciesAclRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemPoliciesAclRequest' when calling System->UpdateSystemPoliciesAclName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = systemPoliciesAclRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/policies/acl/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemPoliciesAclName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Add a new or update an existing ACL policy. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <param name="systemPoliciesAclRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemPoliciesAclNameAsync(string name, SystemPoliciesAclRequest systemPoliciesAclRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->UpdateSystemPoliciesAclName");

            // verify the required parameter 'systemPoliciesAclRequest' is set
            if (systemPoliciesAclRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemPoliciesAclRequest' when calling System->UpdateSystemPoliciesAclName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = systemPoliciesAclRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/policies/acl/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemPoliciesAclName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Add a new or update an existing password policy. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the password policy.</param>
        /// <param name="systemPoliciesPasswordRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemPoliciesPasswordName(string name, SystemPoliciesPasswordRequest systemPoliciesPasswordRequest)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->UpdateSystemPoliciesPasswordName");

            // verify the required parameter 'systemPoliciesPasswordRequest' is set
            if (systemPoliciesPasswordRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemPoliciesPasswordRequest' when calling System->UpdateSystemPoliciesPasswordName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = systemPoliciesPasswordRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/policies/password/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemPoliciesPasswordName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Add a new or update an existing password policy. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the password policy.</param>
        /// <param name="systemPoliciesPasswordRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemPoliciesPasswordNameAsync(string name, SystemPoliciesPasswordRequest systemPoliciesPasswordRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->UpdateSystemPoliciesPasswordName");

            // verify the required parameter 'systemPoliciesPasswordRequest' is set
            if (systemPoliciesPasswordRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemPoliciesPasswordRequest' when calling System->UpdateSystemPoliciesPasswordName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = systemPoliciesPasswordRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/policies/password/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemPoliciesPasswordName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Add a new or update an existing policy. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <param name="systemPolicyRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemPolicyName(string name, SystemPolicyRequest systemPolicyRequest)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->UpdateSystemPolicyName");

            // verify the required parameter 'systemPolicyRequest' is set
            if (systemPolicyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemPolicyRequest' when calling System->UpdateSystemPolicyName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = systemPolicyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/policy/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemPolicyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Add a new or update an existing policy. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the policy. Example: \&quot;ops\&quot;</param>
        /// <param name="systemPolicyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemPolicyNameAsync(string name, SystemPolicyRequest systemPolicyRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->UpdateSystemPolicyName");

            // verify the required parameter 'systemPolicyRequest' is set
            if (systemPolicyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemPolicyRequest' when calling System->UpdateSystemPolicyName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = systemPolicyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/policy/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemPolicyName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemQuotasConfigRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemQuotasConfig(SystemQuotasConfigRequest systemQuotasConfigRequest)
        {
            // verify the required parameter 'systemQuotasConfigRequest' is set
            if (systemQuotasConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemQuotasConfigRequest' when calling System->UpdateSystemQuotasConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemQuotasConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/quotas/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemQuotasConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemQuotasConfigRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemQuotasConfigAsync(SystemQuotasConfigRequest systemQuotasConfigRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemQuotasConfigRequest' is set
            if (systemQuotasConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemQuotasConfigRequest' when calling System->UpdateSystemQuotasConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemQuotasConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/quotas/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemQuotasConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the quota rule.</param>
        /// <param name="systemQuotasRateLimitRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemQuotasRateLimitName(string name, SystemQuotasRateLimitRequest systemQuotasRateLimitRequest)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->UpdateSystemQuotasRateLimitName");

            // verify the required parameter 'systemQuotasRateLimitRequest' is set
            if (systemQuotasRateLimitRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemQuotasRateLimitRequest' when calling System->UpdateSystemQuotasRateLimitName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = systemQuotasRateLimitRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/quotas/rate-limit/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemQuotasRateLimitName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the quota rule.</param>
        /// <param name="systemQuotasRateLimitRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemQuotasRateLimitNameAsync(string name, SystemQuotasRateLimitRequest systemQuotasRateLimitRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling System->UpdateSystemQuotasRateLimitName");

            // verify the required parameter 'systemQuotasRateLimitRequest' is set
            if (systemQuotasRateLimitRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemQuotasRateLimitRequest' when calling System->UpdateSystemQuotasRateLimitName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = systemQuotasRateLimitRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/quotas/rate-limit/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemQuotasRateLimitName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Update the value of the key at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRawRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemRaw(SystemRawRequest systemRawRequest)
        {
            // verify the required parameter 'systemRawRequest' is set
            if (systemRawRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRawRequest' when calling System->UpdateSystemRaw");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemRawRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/raw", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRaw", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Update the value of the key at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRawRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemRawAsync(SystemRawRequest systemRawRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemRawRequest' is set
            if (systemRawRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRawRequest' when calling System->UpdateSystemRaw");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemRawRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/raw", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRaw", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Update the value of the key at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path"></param>
        /// <param name="systemRawRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemRawPath(string path, SystemRawRequest systemRawRequest)
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->UpdateSystemRawPath");

            // verify the required parameter 'systemRawRequest' is set
            if (systemRawRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRawRequest' when calling System->UpdateSystemRawPath");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = systemRawRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/raw/{path}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRawPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Update the value of the key at the given path. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="path"></param>
        /// <param name="systemRawRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemRawPathAsync(string path, SystemRawRequest systemRawRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'path' is set
            if (path == null)
                throw new VaultApiException(400, "Missing required parameter 'path' when calling System->UpdateSystemRawPath");

            // verify the required parameter 'systemRawRequest' is set
            if (systemRawRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRawRequest' when calling System->UpdateSystemRawPath");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("path", ClientUtils.ParameterToString(path)); // path parameter
            requestOptions.Data = systemRawRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/raw/{path}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRawPath", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Initializes a new rekey attempt. Only a single rekey attempt can take place at a time, and changing the parameters of a rekey requires canceling and starting a new rekey, which will also provide a new nonce.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRekeyInitRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemRekeyInit(SystemRekeyInitRequest systemRekeyInitRequest)
        {
            // verify the required parameter 'systemRekeyInitRequest' is set
            if (systemRekeyInitRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRekeyInitRequest' when calling System->UpdateSystemRekeyInit");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemRekeyInitRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/rekey/init", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRekeyInit", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Initializes a new rekey attempt. Only a single rekey attempt can take place at a time, and changing the parameters of a rekey requires canceling and starting a new rekey, which will also provide a new nonce.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRekeyInitRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemRekeyInitAsync(SystemRekeyInitRequest systemRekeyInitRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemRekeyInitRequest' is set
            if (systemRekeyInitRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRekeyInitRequest' when calling System->UpdateSystemRekeyInit");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemRekeyInitRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/rekey/init", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRekeyInit", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enter a single unseal key share to progress the rekey of the Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRekeyUpdateRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemRekeyUpdate(SystemRekeyUpdateRequest systemRekeyUpdateRequest)
        {
            // verify the required parameter 'systemRekeyUpdateRequest' is set
            if (systemRekeyUpdateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRekeyUpdateRequest' when calling System->UpdateSystemRekeyUpdate");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemRekeyUpdateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/rekey/update", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRekeyUpdate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enter a single unseal key share to progress the rekey of the Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRekeyUpdateRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemRekeyUpdateAsync(SystemRekeyUpdateRequest systemRekeyUpdateRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemRekeyUpdateRequest' is set
            if (systemRekeyUpdateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRekeyUpdateRequest' when calling System->UpdateSystemRekeyUpdate");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemRekeyUpdateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/rekey/update", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRekeyUpdate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enter a single new key share to progress the rekey verification operation. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRekeyVerifyRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemRekeyVerify(SystemRekeyVerifyRequest systemRekeyVerifyRequest)
        {
            // verify the required parameter 'systemRekeyVerifyRequest' is set
            if (systemRekeyVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRekeyVerifyRequest' when calling System->UpdateSystemRekeyVerify");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemRekeyVerifyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/rekey/verify", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRekeyVerify", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enter a single new key share to progress the rekey verification operation. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRekeyVerifyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemRekeyVerifyAsync(SystemRekeyVerifyRequest systemRekeyVerifyRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemRekeyVerifyRequest' is set
            if (systemRekeyVerifyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRekeyVerifyRequest' when calling System->UpdateSystemRekeyVerify");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemRekeyVerifyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/rekey/verify", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRekeyVerify", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Initiate a mount migration 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRemountRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemRemount(SystemRemountRequest systemRemountRequest)
        {
            // verify the required parameter 'systemRemountRequest' is set
            if (systemRemountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRemountRequest' when calling System->UpdateSystemRemount");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemRemountRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/remount", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRemount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Initiate a mount migration 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRemountRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemRemountAsync(SystemRemountRequest systemRemountRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemRemountRequest' is set
            if (systemRemountRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRemountRequest' when calling System->UpdateSystemRemount");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemRemountRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/remount", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRemount", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Renews a lease, requesting to extend the lease. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRenewRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemRenew(SystemRenewRequest systemRenewRequest)
        {
            // verify the required parameter 'systemRenewRequest' is set
            if (systemRenewRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRenewRequest' when calling System->UpdateSystemRenew");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemRenewRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/renew", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRenew", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Renews a lease, requesting to extend the lease. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRenewRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemRenewAsync(SystemRenewRequest systemRenewRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemRenewRequest' is set
            if (systemRenewRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRenewRequest' when calling System->UpdateSystemRenew");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemRenewRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/renew", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRenew", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Renews a lease, requesting to extend the lease. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlLeaseId">The lease identifier to renew. This is included with a lease.</param>
        /// <param name="systemRenewLeaseRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemRenewUrlLeaseId(string urlLeaseId, SystemRenewLeaseRequest systemRenewLeaseRequest)
        {
            // verify the required parameter 'urlLeaseId' is set
            if (urlLeaseId == null)
                throw new VaultApiException(400, "Missing required parameter 'urlLeaseId' when calling System->UpdateSystemRenewUrlLeaseId");

            // verify the required parameter 'systemRenewLeaseRequest' is set
            if (systemRenewLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRenewLeaseRequest' when calling System->UpdateSystemRenewUrlLeaseId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("url_lease_id", ClientUtils.ParameterToString(urlLeaseId)); // path parameter
            requestOptions.Data = systemRenewLeaseRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/renew/{url_lease_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRenewUrlLeaseId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Renews a lease, requesting to extend the lease. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlLeaseId">The lease identifier to renew. This is included with a lease.</param>
        /// <param name="systemRenewLeaseRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemRenewUrlLeaseIdAsync(string urlLeaseId, SystemRenewLeaseRequest systemRenewLeaseRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'urlLeaseId' is set
            if (urlLeaseId == null)
                throw new VaultApiException(400, "Missing required parameter 'urlLeaseId' when calling System->UpdateSystemRenewUrlLeaseId");

            // verify the required parameter 'systemRenewLeaseRequest' is set
            if (systemRenewLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRenewLeaseRequest' when calling System->UpdateSystemRenewUrlLeaseId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("url_lease_id", ClientUtils.ParameterToString(urlLeaseId)); // path parameter
            requestOptions.Data = systemRenewLeaseRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/renew/{url_lease_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRenewUrlLeaseId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revokes a lease immediately. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRevokeRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemRevoke(SystemRevokeRequest systemRevokeRequest)
        {
            // verify the required parameter 'systemRevokeRequest' is set
            if (systemRevokeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRevokeRequest' when calling System->UpdateSystemRevoke");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemRevokeRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/revoke", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revokes a lease immediately. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRevokeRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemRevokeAsync(SystemRevokeRequest systemRevokeRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemRevokeRequest' is set
            if (systemRevokeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRevokeRequest' when calling System->UpdateSystemRevoke");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemRevokeRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/revoke", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revokes all secrets or tokens generated under a given prefix immediately Unlike &#x60;/sys/leases/revoke-prefix&#x60;, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.  By ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to revoke keys under. Example: \&quot;prod/aws/ops\&quot;</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemRevokeForcePrefix(string prefix)
        {
            // verify the required parameter 'prefix' is set
            if (prefix == null)
                throw new VaultApiException(400, "Missing required parameter 'prefix' when calling System->UpdateSystemRevokeForcePrefix");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("prefix", ClientUtils.ParameterToString(prefix)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/revoke-force/{prefix}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRevokeForcePrefix", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revokes all secrets or tokens generated under a given prefix immediately Unlike &#x60;/sys/leases/revoke-prefix&#x60;, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.  By ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to revoke keys under. Example: \&quot;prod/aws/ops\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemRevokeForcePrefixAsync(string prefix, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'prefix' is set
            if (prefix == null)
                throw new VaultApiException(400, "Missing required parameter 'prefix' when calling System->UpdateSystemRevokeForcePrefix");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("prefix", ClientUtils.ParameterToString(prefix)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/revoke-force/{prefix}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRevokeForcePrefix", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revokes all secrets (via a lease ID prefix) or tokens (via the tokens&#39; path property) generated under a given prefix immediately. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to revoke keys under. Example: \&quot;prod/aws/ops\&quot;</param>
        /// <param name="systemRevokePrefixRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemRevokePrefixPrefix(string prefix, SystemRevokePrefixRequest systemRevokePrefixRequest)
        {
            // verify the required parameter 'prefix' is set
            if (prefix == null)
                throw new VaultApiException(400, "Missing required parameter 'prefix' when calling System->UpdateSystemRevokePrefixPrefix");

            // verify the required parameter 'systemRevokePrefixRequest' is set
            if (systemRevokePrefixRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRevokePrefixRequest' when calling System->UpdateSystemRevokePrefixPrefix");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("prefix", ClientUtils.ParameterToString(prefix)); // path parameter
            requestOptions.Data = systemRevokePrefixRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/revoke-prefix/{prefix}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRevokePrefixPrefix", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revokes all secrets (via a lease ID prefix) or tokens (via the tokens&#39; path property) generated under a given prefix immediately. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="prefix">The path to revoke keys under. Example: \&quot;prod/aws/ops\&quot;</param>
        /// <param name="systemRevokePrefixRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemRevokePrefixPrefixAsync(string prefix, SystemRevokePrefixRequest systemRevokePrefixRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'prefix' is set
            if (prefix == null)
                throw new VaultApiException(400, "Missing required parameter 'prefix' when calling System->UpdateSystemRevokePrefixPrefix");

            // verify the required parameter 'systemRevokePrefixRequest' is set
            if (systemRevokePrefixRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRevokePrefixRequest' when calling System->UpdateSystemRevokePrefixPrefix");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("prefix", ClientUtils.ParameterToString(prefix)); // path parameter
            requestOptions.Data = systemRevokePrefixRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/revoke-prefix/{prefix}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRevokePrefixPrefix", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revokes a lease immediately. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlLeaseId">The lease identifier to renew. This is included with a lease.</param>
        /// <param name="systemRevokeLeaseRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemRevokeUrlLeaseId(string urlLeaseId, SystemRevokeLeaseRequest systemRevokeLeaseRequest)
        {
            // verify the required parameter 'urlLeaseId' is set
            if (urlLeaseId == null)
                throw new VaultApiException(400, "Missing required parameter 'urlLeaseId' when calling System->UpdateSystemRevokeUrlLeaseId");

            // verify the required parameter 'systemRevokeLeaseRequest' is set
            if (systemRevokeLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRevokeLeaseRequest' when calling System->UpdateSystemRevokeUrlLeaseId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("url_lease_id", ClientUtils.ParameterToString(urlLeaseId)); // path parameter
            requestOptions.Data = systemRevokeLeaseRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/revoke/{url_lease_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRevokeUrlLeaseId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Revokes a lease immediately. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlLeaseId">The lease identifier to renew. This is included with a lease.</param>
        /// <param name="systemRevokeLeaseRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemRevokeUrlLeaseIdAsync(string urlLeaseId, SystemRevokeLeaseRequest systemRevokeLeaseRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'urlLeaseId' is set
            if (urlLeaseId == null)
                throw new VaultApiException(400, "Missing required parameter 'urlLeaseId' when calling System->UpdateSystemRevokeUrlLeaseId");

            // verify the required parameter 'systemRevokeLeaseRequest' is set
            if (systemRevokeLeaseRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRevokeLeaseRequest' when calling System->UpdateSystemRevokeUrlLeaseId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("url_lease_id", ClientUtils.ParameterToString(urlLeaseId)); // path parameter
            requestOptions.Data = systemRevokeLeaseRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/revoke/{url_lease_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRevokeUrlLeaseId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Rotates the backend encryption key used to persist data. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemRotate()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/rotate", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRotate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Rotates the backend encryption key used to persist data. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemRotateAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/rotate", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRotate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRotateConfigRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemRotateConfig(SystemRotateConfigRequest systemRotateConfigRequest)
        {
            // verify the required parameter 'systemRotateConfigRequest' is set
            if (systemRotateConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRotateConfigRequest' when calling System->UpdateSystemRotateConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemRotateConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/rotate/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRotateConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemRotateConfigRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemRotateConfigAsync(SystemRotateConfigRequest systemRotateConfigRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemRotateConfigRequest' is set
            if (systemRotateConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemRotateConfigRequest' when calling System->UpdateSystemRotateConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemRotateConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/rotate/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemRotateConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Seal the Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemSeal()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/seal", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemSeal", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Seal the Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemSealAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/seal", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemSeal", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Cause the node to give up active status. This endpoint forces the node to give up active status. If the node does not have active status, this endpoint does nothing. Note that the node will sleep for ten seconds before attempting to grab the active lock again, but if no standby nodes grab the active lock in the interim, the same node may become the active node again.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemStepDown()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/step-down", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemStepDown", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Cause the node to give up active status. This endpoint forces the node to give up active status. If the node does not have active status, this endpoint does nothing. Note that the node will sleep for ten seconds before attempting to grab the active lock again, but if no standby nodes grab the active lock in the interim, the same node may become the active node again.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemStepDownAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/step-down", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemStepDown", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemToolsHashRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemToolsHash(SystemToolsHashRequest systemToolsHashRequest)
        {
            // verify the required parameter 'systemToolsHashRequest' is set
            if (systemToolsHashRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemToolsHashRequest' when calling System->UpdateSystemToolsHash");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemToolsHashRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/tools/hash", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemToolsHash", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemToolsHashRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemToolsHashAsync(SystemToolsHashRequest systemToolsHashRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemToolsHashRequest' is set
            if (systemToolsHashRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemToolsHashRequest' when calling System->UpdateSystemToolsHash");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemToolsHashRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/tools/hash", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemToolsHash", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="systemToolsHashRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemToolsHashUrlalgorithm(string urlalgorithm, SystemToolsHashRequest systemToolsHashRequest)
        {
            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling System->UpdateSystemToolsHashUrlalgorithm");

            // verify the required parameter 'systemToolsHashRequest' is set
            if (systemToolsHashRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemToolsHashRequest' when calling System->UpdateSystemToolsHashUrlalgorithm");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = systemToolsHashRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/tools/hash/{urlalgorithm}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemToolsHashUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a hash sum for input data 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlalgorithm">Algorithm to use (POST URL parameter)</param>
        /// <param name="systemToolsHashRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemToolsHashUrlalgorithmAsync(string urlalgorithm, SystemToolsHashRequest systemToolsHashRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'urlalgorithm' is set
            if (urlalgorithm == null)
                throw new VaultApiException(400, "Missing required parameter 'urlalgorithm' when calling System->UpdateSystemToolsHashUrlalgorithm");

            // verify the required parameter 'systemToolsHashRequest' is set
            if (systemToolsHashRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemToolsHashRequest' when calling System->UpdateSystemToolsHashUrlalgorithm");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("urlalgorithm", ClientUtils.ParameterToString(urlalgorithm)); // path parameter
            requestOptions.Data = systemToolsHashRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/tools/hash/{urlalgorithm}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemToolsHashUrlalgorithm", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemToolsRandomRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemToolsRandom(SystemToolsRandomRequest systemToolsRandomRequest)
        {
            // verify the required parameter 'systemToolsRandomRequest' is set
            if (systemToolsRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemToolsRandomRequest' when calling System->UpdateSystemToolsRandom");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemToolsRandomRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/tools/random", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemToolsRandom", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemToolsRandomRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemToolsRandomAsync(SystemToolsRandomRequest systemToolsRandomRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemToolsRandomRequest' is set
            if (systemToolsRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemToolsRandomRequest' when calling System->UpdateSystemToolsRandom");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemToolsRandomRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/tools/random", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemToolsRandom", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="systemToolsRandomRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemToolsRandomSource(string source, SystemToolsRandomRequest systemToolsRandomRequest)
        {
            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling System->UpdateSystemToolsRandomSource");

            // verify the required parameter 'systemToolsRandomRequest' is set
            if (systemToolsRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemToolsRandomRequest' when calling System->UpdateSystemToolsRandomSource");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter
            requestOptions.Data = systemToolsRandomRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/tools/random/{source}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemToolsRandomSource", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="systemToolsRandomRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemToolsRandomSourceAsync(string source, SystemToolsRandomRequest systemToolsRandomRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling System->UpdateSystemToolsRandomSource");

            // verify the required parameter 'systemToolsRandomRequest' is set
            if (systemToolsRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemToolsRandomRequest' when calling System->UpdateSystemToolsRandomSource");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter
            requestOptions.Data = systemToolsRandomRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/tools/random/{source}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemToolsRandomSource", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="systemToolsRandomRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemToolsRandomSourceUrlbytes(string source, string urlbytes, SystemToolsRandomRequest systemToolsRandomRequest)
        {
            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling System->UpdateSystemToolsRandomSourceUrlbytes");

            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling System->UpdateSystemToolsRandomSourceUrlbytes");

            // verify the required parameter 'systemToolsRandomRequest' is set
            if (systemToolsRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemToolsRandomRequest' when calling System->UpdateSystemToolsRandomSourceUrlbytes");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter
            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter
            requestOptions.Data = systemToolsRandomRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/tools/random/{source}/{urlbytes}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemToolsRandomSourceUrlbytes", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="source">Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.</param>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="systemToolsRandomRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemToolsRandomSourceUrlbytesAsync(string source, string urlbytes, SystemToolsRandomRequest systemToolsRandomRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'source' is set
            if (source == null)
                throw new VaultApiException(400, "Missing required parameter 'source' when calling System->UpdateSystemToolsRandomSourceUrlbytes");

            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling System->UpdateSystemToolsRandomSourceUrlbytes");

            // verify the required parameter 'systemToolsRandomRequest' is set
            if (systemToolsRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemToolsRandomRequest' when calling System->UpdateSystemToolsRandomSourceUrlbytes");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("source", ClientUtils.ParameterToString(source)); // path parameter
            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter
            requestOptions.Data = systemToolsRandomRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/tools/random/{source}/{urlbytes}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemToolsRandomSourceUrlbytes", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="systemToolsRandomRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemToolsRandomUrlbytes(string urlbytes, SystemToolsRandomRequest systemToolsRandomRequest)
        {
            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling System->UpdateSystemToolsRandomUrlbytes");

            // verify the required parameter 'systemToolsRandomRequest' is set
            if (systemToolsRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemToolsRandomRequest' when calling System->UpdateSystemToolsRandomUrlbytes");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter
            requestOptions.Data = systemToolsRandomRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/tools/random/{urlbytes}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemToolsRandomUrlbytes", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate random bytes 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlbytes">The number of bytes to generate (POST URL parameter)</param>
        /// <param name="systemToolsRandomRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemToolsRandomUrlbytesAsync(string urlbytes, SystemToolsRandomRequest systemToolsRandomRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'urlbytes' is set
            if (urlbytes == null)
                throw new VaultApiException(400, "Missing required parameter 'urlbytes' when calling System->UpdateSystemToolsRandomUrlbytes");

            // verify the required parameter 'systemToolsRandomRequest' is set
            if (systemToolsRandomRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemToolsRandomRequest' when calling System->UpdateSystemToolsRandomUrlbytes");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("urlbytes", ClientUtils.ParameterToString(urlbytes)); // path parameter
            requestOptions.Data = systemToolsRandomRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/tools/random/{urlbytes}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemToolsRandomUrlbytes", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Unseal the Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemUnsealRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemUnseal(SystemUnsealRequest systemUnsealRequest)
        {
            // verify the required parameter 'systemUnsealRequest' is set
            if (systemUnsealRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemUnsealRequest' when calling System->UpdateSystemUnseal");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemUnsealRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/unseal", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemUnseal", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Unseal the Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemUnsealRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemUnsealAsync(SystemUnsealRequest systemUnsealRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemUnsealRequest' is set
            if (systemUnsealRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemUnsealRequest' when calling System->UpdateSystemUnseal");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemUnsealRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/unseal", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemUnseal", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Look up wrapping properties for the given token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemWrappingLookupRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemWrappingLookup(SystemWrappingLookupRequest systemWrappingLookupRequest)
        {
            // verify the required parameter 'systemWrappingLookupRequest' is set
            if (systemWrappingLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemWrappingLookupRequest' when calling System->UpdateSystemWrappingLookup");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemWrappingLookupRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/wrapping/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemWrappingLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Look up wrapping properties for the given token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemWrappingLookupRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemWrappingLookupAsync(SystemWrappingLookupRequest systemWrappingLookupRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemWrappingLookupRequest' is set
            if (systemWrappingLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemWrappingLookupRequest' when calling System->UpdateSystemWrappingLookup");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemWrappingLookupRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/wrapping/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemWrappingLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Rotates a response-wrapped token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemWrappingRewrapRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemWrappingRewrap(SystemWrappingRewrapRequest systemWrappingRewrapRequest)
        {
            // verify the required parameter 'systemWrappingRewrapRequest' is set
            if (systemWrappingRewrapRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemWrappingRewrapRequest' when calling System->UpdateSystemWrappingRewrap");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemWrappingRewrapRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/wrapping/rewrap", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemWrappingRewrap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Rotates a response-wrapped token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemWrappingRewrapRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemWrappingRewrapAsync(SystemWrappingRewrapRequest systemWrappingRewrapRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemWrappingRewrapRequest' is set
            if (systemWrappingRewrapRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemWrappingRewrapRequest' when calling System->UpdateSystemWrappingRewrap");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemWrappingRewrapRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/wrapping/rewrap", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemWrappingRewrap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Unwraps a response-wrapped token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemWrappingUnwrapRequest"></param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemWrappingUnwrap(SystemWrappingUnwrapRequest systemWrappingUnwrapRequest)
        {
            // verify the required parameter 'systemWrappingUnwrapRequest' is set
            if (systemWrappingUnwrapRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemWrappingUnwrapRequest' when calling System->UpdateSystemWrappingUnwrap");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemWrappingUnwrapRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/wrapping/unwrap", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemWrappingUnwrap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Unwraps a response-wrapped token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="systemWrappingUnwrapRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemWrappingUnwrapAsync(SystemWrappingUnwrapRequest systemWrappingUnwrapRequest, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'systemWrappingUnwrapRequest' is set
            if (systemWrappingUnwrapRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'systemWrappingUnwrapRequest' when calling System->UpdateSystemWrappingUnwrap");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.Data = systemWrappingUnwrapRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/wrapping/unwrap", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemWrappingUnwrap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Response-wraps an arbitrary JSON object. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateSystemWrappingWrap()
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = this.Client.Post<Object>("/sys/wrapping/wrap", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemWrappingWrap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Response-wraps an arbitrary JSON object. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateSystemWrappingWrapAsync(CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);


            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/sys/wrapping/wrap", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateSystemWrappingWrap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }

    }
}
