/*
 * HashiCorp Vault API
 *
 * HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.
 *
 * The version of the OpenAPI document: 1.13.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Threading;
using System.Threading.Tasks;
using Vault.Client;
using Vault.Model;

namespace Vault.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuthSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> AuthUpdateAwsConfigRotateRoot(string mountPath = "aws");
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteApproleRoleRoleName(string roleName, string mountPath = "approle");
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteApproleRoleRoleNameBindSecretId(string roleName, string mountPath = "approle");
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteApproleRoleRoleNameBoundCidrList(string roleName, string mountPath = "approle");
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteApproleRoleRoleNamePeriod(string roleName, string mountPath = "approle");
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteApproleRoleRoleNamePolicies(string roleName, string mountPath = "approle");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteApproleRoleRoleNameSecretIdAccessorDestroy(string roleName, string mountPath = "approle");
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteApproleRoleRoleNameSecretIdBoundCidrs(string roleName, string mountPath = "approle");
        /// <summary>
        /// Invalidate an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteApproleRoleRoleNameSecretIdDestroy(string roleName, string mountPath = "approle");
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteApproleRoleRoleNameSecretIdNumUses(string roleName, string mountPath = "approle");
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteApproleRoleRoleNameSecretIdTtl(string roleName, string mountPath = "approle");
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteApproleRoleRoleNameTokenBoundCidrs(string roleName, string mountPath = "approle");
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteApproleRoleRoleNameTokenMaxTtl(string roleName, string mountPath = "approle");
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteApproleRoleRoleNameTokenNumUses(string roleName, string mountPath = "approle");
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteApproleRoleRoleNameTokenTtl(string roleName, string mountPath = "approle");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAwsConfigCertificateCertName(string certName, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAwsConfigClient(string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAwsConfigStsAccountId(string accountId, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAwsConfigTidyIdentityAccesslist(string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAwsConfigTidyIdentityWhitelist(string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAwsConfigTidyRoletagBlacklist(string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAwsConfigTidyRoletagDenylist(string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAwsIdentityAccesslistInstanceId(string instanceId, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAwsIdentityWhitelistInstanceId(string instanceId, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAwsRoleRole(string role, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAwsRoletagBlacklistRoleTag(string roleTag, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteAwsRoletagDenylistRoleTag(string roleTag, string mountPath = "aws");
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteCertCertsName(string name, string mountPath = "cert");
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteCertCrlsName(string name, string mountPath = "cert");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteCfRolesRole(string role, string mountPath = "cf");
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteGithubMapTeamsKey(string key, string mountPath = "github");
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteGithubMapUsersKey(string key, string mountPath = "github");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteKerberosGroupsName(string name, string mountPath = "kerberos");
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteKubernetesRoleName(string name, string mountPath = "kubernetes");
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteOktaUsersName(string name, string mountPath = "okta");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteTokenRolesRoleName(string roleName, string mountPath = "token");
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> DeleteUserpassUsersUsername(string username, string mountPath = "userpass");
        /// <summary>
        /// Generate a SecretID against this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListApproleRoleRoleNameSecretId(string roleName, string list, string mountPath = "approle");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListAwsConfigCertificates(string list, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListAwsConfigSts(string list, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListAwsIdentityAccesslist(string list, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListAwsIdentityWhitelist(string list, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListAwsRoletagBlacklist(string list, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListAwsRoletagDenylist(string list, string mountPath = "aws");
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListCertCerts(string list, string mountPath = "cert");
        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListGcpRoles(string list, string mountPath = "gcp");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListKerberosGroups(string list, string mountPath = "kerberos");
        /// <summary>
        /// Lists all the roles registered with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListKubernetesRole(string list, string mountPath = "kubernetes");
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListOktaUsers(string list, string mountPath = "okta");
        /// <summary>
        /// List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires &#39;sudo&#39; capability in addition to &#39;list&#39;.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ListTokenAccessors(string list, string mountPath = "token");
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadApproleRoleRoleName(string roleName, string mountPath = "approle");
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadApproleRoleRoleNameBindSecretId(string roleName, string mountPath = "approle");
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadApproleRoleRoleNameBoundCidrList(string roleName, string mountPath = "approle");
        /// <summary>
        /// Enables cluster local secret IDs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadApproleRoleRoleNameLocalSecretIds(string roleName, string mountPath = "approle");
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadApproleRoleRoleNamePeriod(string roleName, string mountPath = "approle");
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadApproleRoleRoleNamePolicies(string roleName, string mountPath = "approle");
        /// <summary>
        /// Returns the &#39;role_id&#39; of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadApproleRoleRoleNameRoleId(string roleName, string mountPath = "approle");
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadApproleRoleRoleNameSecretIdBoundCidrs(string roleName, string mountPath = "approle");
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadApproleRoleRoleNameSecretIdNumUses(string roleName, string mountPath = "approle");
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadApproleRoleRoleNameSecretIdTtl(string roleName, string mountPath = "approle");
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadApproleRoleRoleNameTokenBoundCidrs(string roleName, string mountPath = "approle");
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadApproleRoleRoleNameTokenMaxTtl(string roleName, string mountPath = "approle");
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadApproleRoleRoleNameTokenNumUses(string roleName, string mountPath = "approle");
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadApproleRoleRoleNameTokenTtl(string roleName, string mountPath = "approle");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadAwsConfigCertificateCertName(string certName, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadAwsConfigClient(string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadAwsConfigIdentity(string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadAwsConfigStsAccountId(string accountId, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadAwsConfigTidyIdentityAccesslist(string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadAwsConfigTidyIdentityWhitelist(string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadAwsConfigTidyRoletagBlacklist(string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadAwsConfigTidyRoletagDenylist(string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadAwsIdentityAccesslistInstanceId(string instanceId, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadAwsIdentityWhitelistInstanceId(string instanceId, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadAwsRoleRole(string role, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadAwsRoletagBlacklistRoleTag(string roleTag, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadAwsRoletagDenylistRoleTag(string roleTag, string mountPath = "aws");
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadCertCertsName(string name, string mountPath = "cert");
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadCertCrlsName(string name, string mountPath = "cert");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadCfRolesRole(string role, string mountPath = "cf");
        /// <summary>
        /// Read mappings for teams
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadGithubMapTeams(string mountPath = "github", string list = "false");
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadGithubMapTeamsKey(string key, string mountPath = "github");
        /// <summary>
        /// Read mappings for users
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadGithubMapUsers(string mountPath = "github", string list = "false");
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadGithubMapUsersKey(string key, string mountPath = "github");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadKerberosConfigLdap(string mountPath = "kerberos");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadKerberosGroupsName(string name, string mountPath = "kerberos");
        /// <summary>
        /// Configures the JWT Public Key and Kubernetes API information.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadKubernetesConfig(string mountPath = "kubernetes");
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadKubernetesRoleName(string name, string mountPath = "kubernetes");
        /// <summary>
        /// Callback endpoint to complete an OIDC login.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadOidcOidcCallback(string mountPath = "oidc");
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadOktaUsersName(string name, string mountPath = "okta");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">Nonce provided during a login request to retrieve the number verification challenge for the matching request.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadOktaVerifyNonce(string nonce, string mountPath = "okta");
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadTokenLookup(string mountPath = "token");
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadTokenLookupSelf(string mountPath = "token");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadTokenRolesRoleName(string roleName, string mountPath = "token");
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> ReadUserpassUsersUsername(string username, string mountPath = "userpass");
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleName(string roleName, ApproleRoleRequest approleRoleRequest, string mountPath = "approle");
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleBindSecretIdRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNameBindSecretId(string roleName, ApproleRoleBindSecretIdRequest approleRoleBindSecretIdRequest, string mountPath = "approle");
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleBoundCidrListRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNameBoundCidrList(string roleName, ApproleRoleBoundCidrListRequest approleRoleBoundCidrListRequest, string mountPath = "approle");
        /// <summary>
        /// Assign a SecretID of choice against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleCustomSecretIdRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNameCustomSecretId(string roleName, ApproleRoleCustomSecretIdRequest approleRoleCustomSecretIdRequest, string mountPath = "approle");
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRolePeriodRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNamePeriod(string roleName, ApproleRolePeriodRequest approleRolePeriodRequest, string mountPath = "approle");
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRolePoliciesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNamePolicies(string roleName, ApproleRolePoliciesRequest approleRolePoliciesRequest, string mountPath = "approle");
        /// <summary>
        /// Returns the &#39;role_id&#39; of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleRoleIdRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNameRoleId(string roleName, ApproleRoleRoleIdRequest approleRoleRoleIdRequest, string mountPath = "approle");
        /// <summary>
        /// Generate a SecretID against this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNameSecretId(string roleName, ApproleRoleSecretIdRequest approleRoleSecretIdRequest, string mountPath = "approle");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdAccessorDestroyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNameSecretIdAccessorDestroy(string roleName, ApproleRoleSecretIdAccessorDestroyRequest approleRoleSecretIdAccessorDestroyRequest, string mountPath = "approle");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdAccessorLookupRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNameSecretIdAccessorLookup(string roleName, ApproleRoleSecretIdAccessorLookupRequest approleRoleSecretIdAccessorLookupRequest, string mountPath = "approle");
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdBoundCidrsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNameSecretIdBoundCidrs(string roleName, ApproleRoleSecretIdBoundCidrsRequest approleRoleSecretIdBoundCidrsRequest, string mountPath = "approle");
        /// <summary>
        /// Invalidate an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdDestroyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNameSecretIdDestroy(string roleName, ApproleRoleSecretIdDestroyRequest approleRoleSecretIdDestroyRequest, string mountPath = "approle");
        /// <summary>
        /// Read the properties of an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdLookupRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNameSecretIdLookup(string roleName, ApproleRoleSecretIdLookupRequest approleRoleSecretIdLookupRequest, string mountPath = "approle");
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdNumUsesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNameSecretIdNumUses(string roleName, ApproleRoleSecretIdNumUsesRequest approleRoleSecretIdNumUsesRequest, string mountPath = "approle");
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdTtlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNameSecretIdTtl(string roleName, ApproleRoleSecretIdTtlRequest approleRoleSecretIdTtlRequest, string mountPath = "approle");
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenBoundCidrsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNameTokenBoundCidrs(string roleName, ApproleRoleTokenBoundCidrsRequest approleRoleTokenBoundCidrsRequest, string mountPath = "approle");
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenMaxTtlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNameTokenMaxTtl(string roleName, ApproleRoleTokenMaxTtlRequest approleRoleTokenMaxTtlRequest, string mountPath = "approle");
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenNumUsesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNameTokenNumUses(string roleName, ApproleRoleTokenNumUsesRequest approleRoleTokenNumUsesRequest, string mountPath = "approle");
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenTtlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleRoleRoleNameTokenTtl(string roleName, ApproleRoleTokenTtlRequest approleRoleTokenTtlRequest, string mountPath = "approle");
        /// <summary>
        /// Trigger the clean-up of expired SecretID entries.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateApproleTidySecretId(string mountPath = "approle");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsConfigCertificateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsConfigCertificateCertName(string certName, AwsConfigCertificateRequest awsConfigCertificateRequest, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigClientRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsConfigClient(AwsConfigClientRequest awsConfigClientRequest, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigIdentityRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsConfigIdentity(AwsConfigIdentityRequest awsConfigIdentityRequest, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsConfigStsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsConfigStsAccountId(string accountId, AwsConfigStsRequest awsConfigStsRequest, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyIdentityAccesslistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsConfigTidyIdentityAccesslist(AwsConfigTidyIdentityAccesslistRequest awsConfigTidyIdentityAccesslistRequest, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyIdentityWhitelistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsConfigTidyIdentityWhitelist(AwsConfigTidyIdentityWhitelistRequest awsConfigTidyIdentityWhitelistRequest, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyRoletagBlacklistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsConfigTidyRoletagBlacklist(AwsConfigTidyRoletagBlacklistRequest awsConfigTidyRoletagBlacklistRequest, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyRoletagDenylistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsConfigTidyRoletagDenylist(AwsConfigTidyRoletagDenylistRequest awsConfigTidyRoletagDenylistRequest, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsRoleRole(string role, AwsRoleRequest awsRoleRequest, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsRoleTagRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsRoleRoleTag(string role, AwsRoleTagRequest awsRoleTagRequest, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsRoletagBlacklistRoleTag(string roleTag, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsRoletagDenylistRoleTag(string roleTag, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityAccesslistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsTidyIdentityAccesslist(AwsTidyIdentityAccesslistRequest awsTidyIdentityAccesslistRequest, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityWhitelistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsTidyIdentityWhitelist(AwsTidyIdentityWhitelistRequest awsTidyIdentityWhitelistRequest, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoletagBlacklistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsTidyRoletagBlacklist(AwsTidyRoletagBlacklistRequest awsTidyRoletagBlacklistRequest, string mountPath = "aws");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoletagDenylistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateAwsTidyRoletagDenylist(AwsTidyRoletagDenylistRequest awsTidyRoletagDenylistRequest, string mountPath = "aws");
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certCertsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateCertCertsName(string name, CertCertsRequest certCertsRequest, string mountPath = "cert");
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certCrlsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateCertCrlsName(string name, CertCrlsRequest certCrlsRequest, string mountPath = "cert");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfRolesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateCfRolesRole(string role, CfRolesRequest cfRolesRequest, string mountPath = "cf");
        /// <summary>
        /// Add or remove labels for an existing &#39;gce&#39; role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleLabelsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpRoleNameLabels(string name, GcpRoleLabelsRequest gcpRoleLabelsRequest, string mountPath = "gcp");
        /// <summary>
        /// Add or remove service accounts for an existing &#x60;iam&#x60; role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleServiceAccountsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGcpRoleNameServiceAccounts(string name, GcpRoleServiceAccountsRequest gcpRoleServiceAccountsRequest, string mountPath = "gcp");
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMapTeamsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGithubMapTeamsKey(string key, GithubMapTeamsRequest githubMapTeamsRequest, string mountPath = "github");
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMapUsersRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateGithubMapUsersKey(string key, GithubMapUsersRequest githubMapUsersRequest, string mountPath = "github");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigLdapRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateKerberosConfigLdap(KerberosConfigLdapRequest kerberosConfigLdapRequest, string mountPath = "kerberos");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosGroupsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateKerberosGroupsName(string name, KerberosGroupsRequest kerberosGroupsRequest, string mountPath = "kerberos");
        /// <summary>
        /// Configures the JWT Public Key and Kubernetes API information.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateKubernetesConfig(KubernetesConfigRequest kubernetesConfigRequest, string mountPath = "kubernetes");
        /// <summary>
        /// Authenticates Kubernetes service accounts with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesLoginRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateKubernetesLogin(KubernetesLoginRequest kubernetesLoginRequest, string mountPath = "kubernetes");
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateKubernetesRoleName(string name, KubernetesRoleRequest kubernetesRoleRequest, string mountPath = "kubernetes");
        /// <summary>
        /// Authenticates to Vault using OCI credentials
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociLoginRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateOciLoginRole(string role, OciLoginRequest ociLoginRequest, string mountPath = "oci");
        /// <summary>
        /// Request an authorization URL to start an OIDC login flow.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcOidcAuthUrlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateOidcOidcAuthUrl(OidcOidcAuthUrlRequest oidcOidcAuthUrlRequest, string mountPath = "oidc");
        /// <summary>
        /// Callback endpoint to handle form_posts.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcOidcCallbackRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateOidcOidcCallback(OidcOidcCallbackRequest oidcOidcCallbackRequest, string mountPath = "oidc");
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username to be used for login.</param>
        /// <param name="oktaLoginRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateOktaLoginUsername(string username, OktaLoginRequest oktaLoginRequest, string mountPath = "okta");
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaUsersRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateOktaUsersName(string name, OktaUsersRequest oktaUsersRequest, string mountPath = "okta");
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlusername">Username to be used for login. (URL parameter)</param>
        /// <param name="radiusLoginRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateRadiusLoginUrlusername(string urlusername, RadiusLoginRequest radiusLoginRequest, string mountPath = "radius");
        /// <summary>
        /// The token create path is used to create new tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTokenCreate(TokenCreateRequest tokenCreateRequest, string format = "json", string mountPath = "token");
        /// <summary>
        /// The token create path is used to create new orphan tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateOrphanRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTokenCreateOrphan(TokenCreateOrphanRequest tokenCreateOrphanRequest, string format = "json", string mountPath = "token");
        /// <summary>
        /// This token create path is used to create new tokens adhering to the given role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTokenCreateRoleName(string roleName, TokenCreateRequest tokenCreateRequest, string format = "json", string mountPath = "token");
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTokenLookup(TokenLookupRequest tokenLookupRequest, string mountPath = "token");
        /// <summary>
        /// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupAccessorRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTokenLookupAccessor(TokenLookupAccessorRequest tokenLookupAccessorRequest, string mountPath = "token");
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupSelfRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTokenLookupSelf(TokenLookupSelfRequest tokenLookupSelfRequest, string mountPath = "token");
        /// <summary>
        /// This endpoint will renew the given token and prevent expiration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTokenRenew(TokenRenewRequest tokenRenewRequest, string mountPath = "token");
        /// <summary>
        /// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewAccessorRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTokenRenewAccessor(TokenRenewAccessorRequest tokenRenewAccessorRequest, string mountPath = "token");
        /// <summary>
        /// This endpoint will renew the token used to call it and prevent expiration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewSelfRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTokenRenewSelf(TokenRenewSelfRequest tokenRenewSelfRequest, string mountPath = "token");
        /// <summary>
        /// This endpoint will delete the given token and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTokenRevoke(TokenRevokeRequest tokenRevokeRequest, string mountPath = "token");
        /// <summary>
        /// This endpoint will delete the token associated with the accessor and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeAccessorRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTokenRevokeAccessor(TokenRevokeAccessorRequest tokenRevokeAccessorRequest, string mountPath = "token");
        /// <summary>
        /// This endpoint will delete the token and orphan its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeOrphanRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTokenRevokeOrphan(TokenRevokeOrphanRequest tokenRevokeOrphanRequest, string mountPath = "token");
        /// <summary>
        /// This endpoint will delete the token used to call it and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTokenRevokeSelf(string mountPath = "token");
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenRolesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTokenRolesRoleName(string roleName, TokenRolesRequest tokenRolesRequest, string mountPath = "token");
        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateTokenTidy(string mountPath = "token");
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateUserpassUsersUsername(string username, UserpassUsersRequest userpassUsersRequest, string mountPath = "userpass");
        /// <summary>
        /// Reset user&#39;s password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersPasswordRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateUserpassUsersUsernamePassword(string username, UserpassUsersPasswordRequest userpassUsersPasswordRequest, string mountPath = "userpass");
        /// <summary>
        /// Update the policies associated with the username.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersPoliciesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        VaultResponse<Object> UpdateUserpassUsersUsernamePolicies(string username, UserpassUsersPoliciesRequest userpassUsersPoliciesRequest, string mountPath = "userpass");
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuthAsync : IApiAccessor
    {
        #region Asynchronous Operations
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> AuthUpdateAwsConfigRotateRootAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteApproleRoleRoleNameAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteApproleRoleRoleNameBindSecretIdAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteApproleRoleRoleNameBoundCidrListAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteApproleRoleRoleNamePeriodAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteApproleRoleRoleNamePoliciesAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteApproleRoleRoleNameSecretIdAccessorDestroyAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Invalidate an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteApproleRoleRoleNameSecretIdDestroyAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteApproleRoleRoleNameSecretIdTtlAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteApproleRoleRoleNameTokenMaxTtlAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteApproleRoleRoleNameTokenNumUsesAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteApproleRoleRoleNameTokenTtlAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAwsConfigCertificateCertNameAsync(string certName, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAwsConfigClientAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAwsConfigStsAccountIdAsync(string accountId, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAwsConfigTidyIdentityAccesslistAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAwsConfigTidyIdentityWhitelistAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAwsConfigTidyRoletagBlacklistAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAwsConfigTidyRoletagDenylistAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAwsIdentityAccesslistInstanceIdAsync(string instanceId, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAwsIdentityWhitelistInstanceIdAsync(string instanceId, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAwsRoleRoleAsync(string role, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAwsRoletagBlacklistRoleTagAsync(string roleTag, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAwsRoletagDenylistRoleTagAsync(string roleTag, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteCertCertsNameAsync(string name, string mountPath = "cert", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteCertCrlsNameAsync(string name, string mountPath = "cert", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteCfRolesRoleAsync(string role, string mountPath = "cf", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteGithubMapTeamsKeyAsync(string key, string mountPath = "github", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteGithubMapUsersKeyAsync(string key, string mountPath = "github", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteKerberosGroupsNameAsync(string name, string mountPath = "kerberos", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteKubernetesRoleNameAsync(string name, string mountPath = "kubernetes", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteOktaUsersNameAsync(string name, string mountPath = "okta", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteTokenRolesRoleNameAsync(string roleName, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteUserpassUsersUsernameAsync(string username, string mountPath = "userpass", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a SecretID against this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListApproleRoleRoleNameSecretIdAsync(string roleName, string list, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListAwsConfigCertificatesAsync(string list, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListAwsConfigStsAsync(string list, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListAwsIdentityAccesslistAsync(string list, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListAwsIdentityWhitelistAsync(string list, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListAwsRoletagBlacklistAsync(string list, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListAwsRoletagDenylistAsync(string list, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListCertCertsAsync(string list, string mountPath = "cert", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListGcpRolesAsync(string list, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListKerberosGroupsAsync(string list, string mountPath = "kerberos", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Lists all the roles registered with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListKubernetesRoleAsync(string list, string mountPath = "kubernetes", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListOktaUsersAsync(string list, string mountPath = "okta", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires &#39;sudo&#39; capability in addition to &#39;list&#39;.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ListTokenAccessorsAsync(string list, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadApproleRoleRoleNameAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadApproleRoleRoleNameBindSecretIdAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadApproleRoleRoleNameBoundCidrListAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Enables cluster local secret IDs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadApproleRoleRoleNameLocalSecretIdsAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadApproleRoleRoleNamePeriodAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadApproleRoleRoleNamePoliciesAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the &#39;role_id&#39; of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadApproleRoleRoleNameRoleIdAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadApproleRoleRoleNameSecretIdTtlAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadApproleRoleRoleNameTokenMaxTtlAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadApproleRoleRoleNameTokenNumUsesAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadApproleRoleRoleNameTokenTtlAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadAwsConfigCertificateCertNameAsync(string certName, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadAwsConfigClientAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadAwsConfigIdentityAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadAwsConfigStsAccountIdAsync(string accountId, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadAwsConfigTidyIdentityAccesslistAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadAwsConfigTidyIdentityWhitelistAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadAwsConfigTidyRoletagBlacklistAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadAwsConfigTidyRoletagDenylistAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadAwsIdentityAccesslistInstanceIdAsync(string instanceId, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadAwsIdentityWhitelistInstanceIdAsync(string instanceId, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadAwsRoleRoleAsync(string role, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadAwsRoletagBlacklistRoleTagAsync(string roleTag, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadAwsRoletagDenylistRoleTagAsync(string roleTag, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadCertCertsNameAsync(string name, string mountPath = "cert", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadCertCrlsNameAsync(string name, string mountPath = "cert", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadCfRolesRoleAsync(string role, string mountPath = "cf", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read mappings for teams
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadGithubMapTeamsAsync(string mountPath = "github", string list = "false", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadGithubMapTeamsKeyAsync(string key, string mountPath = "github", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read mappings for users
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadGithubMapUsersAsync(string mountPath = "github", string list = "false", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadGithubMapUsersKeyAsync(string key, string mountPath = "github", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadKerberosConfigLdapAsync(string mountPath = "kerberos", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadKerberosGroupsNameAsync(string name, string mountPath = "kerberos", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configures the JWT Public Key and Kubernetes API information.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadKubernetesConfigAsync(string mountPath = "kubernetes", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadKubernetesRoleNameAsync(string name, string mountPath = "kubernetes", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Callback endpoint to complete an OIDC login.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadOidcOidcCallbackAsync(string mountPath = "oidc", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadOktaUsersNameAsync(string name, string mountPath = "okta", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">Nonce provided during a login request to retrieve the number verification challenge for the matching request.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadOktaVerifyNonceAsync(string nonce, string mountPath = "okta", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadTokenLookupAsync(string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadTokenLookupSelfAsync(string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadTokenRolesRoleNameAsync(string roleName, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> ReadUserpassUsersUsernameAsync(string username, string mountPath = "userpass", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameAsync(string roleName, ApproleRoleRequest approleRoleRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleBindSecretIdRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameBindSecretIdAsync(string roleName, ApproleRoleBindSecretIdRequest approleRoleBindSecretIdRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleBoundCidrListRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameBoundCidrListAsync(string roleName, ApproleRoleBoundCidrListRequest approleRoleBoundCidrListRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Assign a SecretID of choice against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleCustomSecretIdRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameCustomSecretIdAsync(string roleName, ApproleRoleCustomSecretIdRequest approleRoleCustomSecretIdRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRolePeriodRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNamePeriodAsync(string roleName, ApproleRolePeriodRequest approleRolePeriodRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRolePoliciesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNamePoliciesAsync(string roleName, ApproleRolePoliciesRequest approleRolePoliciesRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the &#39;role_id&#39; of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleRoleIdRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameRoleIdAsync(string roleName, ApproleRoleRoleIdRequest approleRoleRoleIdRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a SecretID against this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameSecretIdAsync(string roleName, ApproleRoleSecretIdRequest approleRoleSecretIdRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdAccessorDestroyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameSecretIdAccessorDestroyAsync(string roleName, ApproleRoleSecretIdAccessorDestroyRequest approleRoleSecretIdAccessorDestroyRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdAccessorLookupRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameSecretIdAccessorLookupAsync(string roleName, ApproleRoleSecretIdAccessorLookupRequest approleRoleSecretIdAccessorLookupRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdBoundCidrsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, ApproleRoleSecretIdBoundCidrsRequest approleRoleSecretIdBoundCidrsRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Invalidate an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdDestroyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameSecretIdDestroyAsync(string roleName, ApproleRoleSecretIdDestroyRequest approleRoleSecretIdDestroyRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the properties of an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdLookupRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameSecretIdLookupAsync(string roleName, ApproleRoleSecretIdLookupRequest approleRoleSecretIdLookupRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdNumUsesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, ApproleRoleSecretIdNumUsesRequest approleRoleSecretIdNumUsesRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdTtlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameSecretIdTtlAsync(string roleName, ApproleRoleSecretIdTtlRequest approleRoleSecretIdTtlRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenBoundCidrsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, ApproleRoleTokenBoundCidrsRequest approleRoleTokenBoundCidrsRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenMaxTtlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameTokenMaxTtlAsync(string roleName, ApproleRoleTokenMaxTtlRequest approleRoleTokenMaxTtlRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenNumUsesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameTokenNumUsesAsync(string roleName, ApproleRoleTokenNumUsesRequest approleRoleTokenNumUsesRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenTtlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleRoleRoleNameTokenTtlAsync(string roleName, ApproleRoleTokenTtlRequest approleRoleTokenTtlRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Trigger the clean-up of expired SecretID entries.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateApproleTidySecretIdAsync(string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsConfigCertificateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsConfigCertificateCertNameAsync(string certName, AwsConfigCertificateRequest awsConfigCertificateRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigClientRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsConfigClientAsync(AwsConfigClientRequest awsConfigClientRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigIdentityRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsConfigIdentityAsync(AwsConfigIdentityRequest awsConfigIdentityRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsConfigStsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsConfigStsAccountIdAsync(string accountId, AwsConfigStsRequest awsConfigStsRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyIdentityAccesslistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsConfigTidyIdentityAccesslistAsync(AwsConfigTidyIdentityAccesslistRequest awsConfigTidyIdentityAccesslistRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyIdentityWhitelistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsConfigTidyIdentityWhitelistAsync(AwsConfigTidyIdentityWhitelistRequest awsConfigTidyIdentityWhitelistRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyRoletagBlacklistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsConfigTidyRoletagBlacklistAsync(AwsConfigTidyRoletagBlacklistRequest awsConfigTidyRoletagBlacklistRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyRoletagDenylistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsConfigTidyRoletagDenylistAsync(AwsConfigTidyRoletagDenylistRequest awsConfigTidyRoletagDenylistRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsRoleRoleAsync(string role, AwsRoleRequest awsRoleRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsRoleTagRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsRoleRoleTagAsync(string role, AwsRoleTagRequest awsRoleTagRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsRoletagBlacklistRoleTagAsync(string roleTag, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsRoletagDenylistRoleTagAsync(string roleTag, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityAccesslistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsTidyIdentityAccesslistAsync(AwsTidyIdentityAccesslistRequest awsTidyIdentityAccesslistRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityWhitelistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsTidyIdentityWhitelistAsync(AwsTidyIdentityWhitelistRequest awsTidyIdentityWhitelistRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoletagBlacklistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsTidyRoletagBlacklistAsync(AwsTidyRoletagBlacklistRequest awsTidyRoletagBlacklistRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoletagDenylistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateAwsTidyRoletagDenylistAsync(AwsTidyRoletagDenylistRequest awsTidyRoletagDenylistRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certCertsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateCertCertsNameAsync(string name, CertCertsRequest certCertsRequest, string mountPath = "cert", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certCrlsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateCertCrlsNameAsync(string name, CertCrlsRequest certCrlsRequest, string mountPath = "cert", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfRolesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateCfRolesRoleAsync(string role, CfRolesRequest cfRolesRequest, string mountPath = "cf", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Add or remove labels for an existing &#39;gce&#39; role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleLabelsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpRoleNameLabelsAsync(string name, GcpRoleLabelsRequest gcpRoleLabelsRequest, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Add or remove service accounts for an existing &#x60;iam&#x60; role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleServiceAccountsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGcpRoleNameServiceAccountsAsync(string name, GcpRoleServiceAccountsRequest gcpRoleServiceAccountsRequest, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMapTeamsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGithubMapTeamsKeyAsync(string key, GithubMapTeamsRequest githubMapTeamsRequest, string mountPath = "github", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMapUsersRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateGithubMapUsersKeyAsync(string key, GithubMapUsersRequest githubMapUsersRequest, string mountPath = "github", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigLdapRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateKerberosConfigLdapAsync(KerberosConfigLdapRequest kerberosConfigLdapRequest, string mountPath = "kerberos", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosGroupsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateKerberosGroupsNameAsync(string name, KerberosGroupsRequest kerberosGroupsRequest, string mountPath = "kerberos", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configures the JWT Public Key and Kubernetes API information.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateKubernetesConfigAsync(KubernetesConfigRequest kubernetesConfigRequest, string mountPath = "kubernetes", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Authenticates Kubernetes service accounts with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesLoginRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateKubernetesLoginAsync(KubernetesLoginRequest kubernetesLoginRequest, string mountPath = "kubernetes", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateKubernetesRoleNameAsync(string name, KubernetesRoleRequest kubernetesRoleRequest, string mountPath = "kubernetes", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Authenticates to Vault using OCI credentials
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociLoginRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateOciLoginRoleAsync(string role, OciLoginRequest ociLoginRequest, string mountPath = "oci", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Request an authorization URL to start an OIDC login flow.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcOidcAuthUrlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateOidcOidcAuthUrlAsync(OidcOidcAuthUrlRequest oidcOidcAuthUrlRequest, string mountPath = "oidc", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Callback endpoint to handle form_posts.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcOidcCallbackRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateOidcOidcCallbackAsync(OidcOidcCallbackRequest oidcOidcCallbackRequest, string mountPath = "oidc", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username to be used for login.</param>
        /// <param name="oktaLoginRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateOktaLoginUsernameAsync(string username, OktaLoginRequest oktaLoginRequest, string mountPath = "okta", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaUsersRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateOktaUsersNameAsync(string name, OktaUsersRequest oktaUsersRequest, string mountPath = "okta", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlusername">Username to be used for login. (URL parameter)</param>
        /// <param name="radiusLoginRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateRadiusLoginUrlusernameAsync(string urlusername, RadiusLoginRequest radiusLoginRequest, string mountPath = "radius", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// The token create path is used to create new tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTokenCreateAsync(TokenCreateRequest tokenCreateRequest, string format = "json", string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// The token create path is used to create new orphan tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateOrphanRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTokenCreateOrphanAsync(TokenCreateOrphanRequest tokenCreateOrphanRequest, string format = "json", string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This token create path is used to create new tokens adhering to the given role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTokenCreateRoleNameAsync(string roleName, TokenCreateRequest tokenCreateRequest, string format = "json", string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTokenLookupAsync(TokenLookupRequest tokenLookupRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupAccessorRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTokenLookupAccessorAsync(TokenLookupAccessorRequest tokenLookupAccessorRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupSelfRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTokenLookupSelfAsync(TokenLookupSelfRequest tokenLookupSelfRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will renew the given token and prevent expiration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTokenRenewAsync(TokenRenewRequest tokenRenewRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewAccessorRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTokenRenewAccessorAsync(TokenRenewAccessorRequest tokenRenewAccessorRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will renew the token used to call it and prevent expiration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewSelfRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTokenRenewSelfAsync(TokenRenewSelfRequest tokenRenewSelfRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will delete the given token and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTokenRevokeAsync(TokenRevokeRequest tokenRevokeRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will delete the token associated with the accessor and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeAccessorRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTokenRevokeAccessorAsync(TokenRevokeAccessorRequest tokenRevokeAccessorRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will delete the token and orphan its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeOrphanRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTokenRevokeOrphanAsync(TokenRevokeOrphanRequest tokenRevokeOrphanRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will delete the token used to call it and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTokenRevokeSelfAsync(string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenRolesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTokenRolesRoleNameAsync(string roleName, TokenRolesRequest tokenRolesRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateTokenTidyAsync(string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateUserpassUsersUsernameAsync(string username, UserpassUsersRequest userpassUsersRequest, string mountPath = "userpass", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Reset user&#39;s password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersPasswordRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateUserpassUsersUsernamePasswordAsync(string username, UserpassUsersPasswordRequest userpassUsersPasswordRequest, string mountPath = "userpass", CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Update the policies associated with the username.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersPoliciesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> UpdateUserpassUsersUsernamePoliciesAsync(string username, UserpassUsersPoliciesRequest userpassUsersPoliciesRequest, string mountPath = "userpass", CancellationToken cancellationToken = default(CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuth : IAuthSync, IAuthAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class Auth : IAuth
    {
        private Vault.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Constructor for Auth
        /// </summary>
        public Auth(ApiClient apiClient)
        {
            if (apiClient == null) throw new ArgumentNullException("ApiClient");
            
            this.Configuration = apiClient.Configuration;
            this.Client = apiClient;
            this.AsynchronousClient = apiClient;
            this.ExceptionFactory = Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Vault.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Vault.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Vault.Client.Configuration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Vault.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> AuthUpdateAwsConfigRotateRoot(string mountPath = "aws")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AuthUpdateAwsConfigRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> AuthUpdateAwsConfigRotateRootAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("AuthUpdateAwsConfigRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteApproleRoleRoleName(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteApproleRoleRoleNameAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteApproleRoleRoleNameBindSecretId(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameBindSecretId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/bind-secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteApproleRoleRoleNameBindSecretIdAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameBindSecretId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/bind-secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteApproleRoleRoleNameBoundCidrList(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameBoundCidrList");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/bound-cidr-list", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteApproleRoleRoleNameBoundCidrListAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameBoundCidrList");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/bound-cidr-list", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteApproleRoleRoleNamePeriod(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNamePeriod");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/period", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNamePeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteApproleRoleRoleNamePeriodAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNamePeriod");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/period", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNamePeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteApproleRoleRoleNamePolicies(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNamePolicies");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/policies", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNamePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteApproleRoleRoleNamePoliciesAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNamePolicies");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/policies", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNamePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteApproleRoleRoleNameSecretIdAccessorDestroy(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdAccessorDestroy");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/secret-id-accessor/destroy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdAccessorDestroy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteApproleRoleRoleNameSecretIdAccessorDestroyAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdAccessorDestroy");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-accessor/destroy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdAccessorDestroy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteApproleRoleRoleNameSecretIdBoundCidrs(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Invalidate an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteApproleRoleRoleNameSecretIdDestroy(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdDestroy");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/secret-id/destroy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdDestroy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Invalidate an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteApproleRoleRoleNameSecretIdDestroyAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdDestroy");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id/destroy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdDestroy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteApproleRoleRoleNameSecretIdNumUses(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdNumUses");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/secret-id-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdNumUses");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteApproleRoleRoleNameSecretIdTtl(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/secret-id-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteApproleRoleRoleNameSecretIdTtlAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteApproleRoleRoleNameTokenBoundCidrs(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameTokenBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/token-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameTokenBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/token-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteApproleRoleRoleNameTokenMaxTtl(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameTokenMaxTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/token-max-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteApproleRoleRoleNameTokenMaxTtlAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameTokenMaxTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/token-max-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteApproleRoleRoleNameTokenNumUses(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameTokenNumUses");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/token-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteApproleRoleRoleNameTokenNumUsesAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameTokenNumUses");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/token-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteApproleRoleRoleNameTokenTtl(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameTokenTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/token-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteApproleRoleRoleNameTokenTtlAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameTokenTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/token-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteApproleRoleRoleNameTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAwsConfigCertificateCertName(string certName, string mountPath = "aws")
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->DeleteAwsConfigCertificateCertName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/config/certificate/{cert_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsConfigCertificateCertName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAwsConfigCertificateCertNameAsync(string certName, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->DeleteAwsConfigCertificateCertName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/config/certificate/{cert_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsConfigCertificateCertName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAwsConfigClient(string mountPath = "aws")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/config/client", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsConfigClient", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAwsConfigClientAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/config/client", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsConfigClient", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAwsConfigStsAccountId(string accountId, string mountPath = "aws")
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->DeleteAwsConfigStsAccountId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/config/sts/{account_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsConfigStsAccountId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAwsConfigStsAccountIdAsync(string accountId, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->DeleteAwsConfigStsAccountId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/config/sts/{account_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsConfigStsAccountId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAwsConfigTidyIdentityAccesslist(string mountPath = "aws")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/config/tidy/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsConfigTidyIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAwsConfigTidyIdentityAccesslistAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/config/tidy/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsConfigTidyIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAwsConfigTidyIdentityWhitelist(string mountPath = "aws")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/config/tidy/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsConfigTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAwsConfigTidyIdentityWhitelistAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/config/tidy/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsConfigTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAwsConfigTidyRoletagBlacklist(string mountPath = "aws")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/config/tidy/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsConfigTidyRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAwsConfigTidyRoletagBlacklistAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/config/tidy/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsConfigTidyRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAwsConfigTidyRoletagDenylist(string mountPath = "aws")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/config/tidy/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsConfigTidyRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAwsConfigTidyRoletagDenylistAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/config/tidy/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsConfigTidyRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAwsIdentityAccesslistInstanceId(string instanceId, string mountPath = "aws")
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->DeleteAwsIdentityAccesslistInstanceId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/identity-accesslist/{instance_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsIdentityAccesslistInstanceId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAwsIdentityAccesslistInstanceIdAsync(string instanceId, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->DeleteAwsIdentityAccesslistInstanceId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/identity-accesslist/{instance_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsIdentityAccesslistInstanceId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAwsIdentityWhitelistInstanceId(string instanceId, string mountPath = "aws")
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->DeleteAwsIdentityWhitelistInstanceId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/identity-whitelist/{instance_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsIdentityWhitelistInstanceId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAwsIdentityWhitelistInstanceIdAsync(string instanceId, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->DeleteAwsIdentityWhitelistInstanceId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/identity-whitelist/{instance_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsIdentityWhitelistInstanceId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAwsRoleRole(string role, string mountPath = "aws")
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->DeleteAwsRoleRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAwsRoleRoleAsync(string role, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->DeleteAwsRoleRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAwsRoletagBlacklistRoleTag(string roleTag, string mountPath = "aws")
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->DeleteAwsRoletagBlacklistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/roletag-blacklist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsRoletagBlacklistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAwsRoletagBlacklistRoleTagAsync(string roleTag, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->DeleteAwsRoletagBlacklistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/roletag-blacklist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsRoletagBlacklistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteAwsRoletagDenylistRoleTag(string roleTag, string mountPath = "aws")
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->DeleteAwsRoletagDenylistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/roletag-denylist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsRoletagDenylistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAwsRoletagDenylistRoleTagAsync(string roleTag, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->DeleteAwsRoletagDenylistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/roletag-denylist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAwsRoletagDenylistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteCertCertsName(string name, string mountPath = "cert")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteCertCertsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/certs/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteCertCertsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteCertCertsNameAsync(string name, string mountPath = "cert", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteCertCertsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/certs/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteCertCertsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteCertCrlsName(string name, string mountPath = "cert")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteCertCrlsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/crls/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteCertCrlsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteCertCrlsNameAsync(string name, string mountPath = "cert", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteCertCrlsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/crls/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteCertCrlsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteCfRolesRole(string role, string mountPath = "cf")
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->DeleteCfRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteCfRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteCfRolesRoleAsync(string role, string mountPath = "cf", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->DeleteCfRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteCfRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteGithubMapTeamsKey(string key, string mountPath = "github")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->DeleteGithubMapTeamsKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/map/teams/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGithubMapTeamsKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteGithubMapTeamsKeyAsync(string key, string mountPath = "github", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->DeleteGithubMapTeamsKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/map/teams/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGithubMapTeamsKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteGithubMapUsersKey(string key, string mountPath = "github")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->DeleteGithubMapUsersKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/map/users/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGithubMapUsersKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteGithubMapUsersKeyAsync(string key, string mountPath = "github", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->DeleteGithubMapUsersKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/map/users/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteGithubMapUsersKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteKerberosGroupsName(string name, string mountPath = "kerberos")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteKerberosGroupsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteKerberosGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteKerberosGroupsNameAsync(string name, string mountPath = "kerberos", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteKerberosGroupsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteKerberosGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteKubernetesRoleName(string name, string mountPath = "kubernetes")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteKubernetesRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteKubernetesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteKubernetesRoleNameAsync(string name, string mountPath = "kubernetes", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteKubernetesRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteKubernetesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteOktaUsersName(string name, string mountPath = "okta")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteOktaUsersName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteOktaUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteOktaUsersNameAsync(string name, string mountPath = "okta", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteOktaUsersName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteOktaUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteTokenRolesRoleName(string roleName, string mountPath = "token")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteTokenRolesRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/roles/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteTokenRolesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteTokenRolesRoleNameAsync(string roleName, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteTokenRolesRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/roles/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteTokenRolesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> DeleteUserpassUsersUsername(string username, string mountPath = "userpass")
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->DeleteUserpassUsersUsername");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/users/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteUserpassUsersUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteUserpassUsersUsernameAsync(string username, string mountPath = "userpass", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->DeleteUserpassUsersUsername");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/users/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteUserpassUsersUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a SecretID against this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListApproleRoleRoleNameSecretId(string roleName, string list, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ListApproleRoleRoleNameSecretId");

            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListApproleRoleRoleNameSecretId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListApproleRoleRoleNameSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a SecretID against this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListApproleRoleRoleNameSecretIdAsync(string roleName, string list, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ListApproleRoleRoleNameSecretId");

            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListApproleRoleRoleNameSecretId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListApproleRoleRoleNameSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListAwsConfigCertificates(string list, string mountPath = "aws")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsConfigCertificates");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/certificates", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListAwsConfigCertificates", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListAwsConfigCertificatesAsync(string list, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsConfigCertificates");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/certificates", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListAwsConfigCertificates", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListAwsConfigSts(string list, string mountPath = "aws")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsConfigSts");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/sts", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListAwsConfigSts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListAwsConfigStsAsync(string list, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsConfigSts");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/sts", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListAwsConfigSts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListAwsIdentityAccesslist(string list, string mountPath = "aws")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsIdentityAccesslist");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListAwsIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListAwsIdentityAccesslistAsync(string list, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsIdentityAccesslist");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListAwsIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListAwsIdentityWhitelist(string list, string mountPath = "aws")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsIdentityWhitelist");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListAwsIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListAwsIdentityWhitelistAsync(string list, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsIdentityWhitelist");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListAwsIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListAwsRoletagBlacklist(string list, string mountPath = "aws")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsRoletagBlacklist");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListAwsRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListAwsRoletagBlacklistAsync(string list, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsRoletagBlacklist");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListAwsRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListAwsRoletagDenylist(string list, string mountPath = "aws")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsRoletagDenylist");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListAwsRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListAwsRoletagDenylistAsync(string list, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsRoletagDenylist");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListAwsRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListCertCerts(string list, string mountPath = "cert")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListCertCerts");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/certs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListCertCerts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListCertCertsAsync(string list, string mountPath = "cert", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListCertCerts");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/certs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListCertCerts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListGcpRoles(string list, string mountPath = "gcp")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListGcpRoles");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListGcpRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListGcpRolesAsync(string list, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListGcpRoles");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListGcpRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListKerberosGroups(string list, string mountPath = "kerberos")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListKerberosGroups");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/groups", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListKerberosGroups", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListKerberosGroupsAsync(string list, string mountPath = "kerberos", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListKerberosGroups");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/groups", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListKerberosGroups", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles registered with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListKubernetesRole(string list, string mountPath = "kubernetes")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListKubernetesRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListKubernetesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles registered with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListKubernetesRoleAsync(string list, string mountPath = "kubernetes", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListKubernetesRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListKubernetesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListOktaUsers(string list, string mountPath = "okta")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListOktaUsers");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/users", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListOktaUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListOktaUsersAsync(string list, string mountPath = "okta", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListOktaUsers");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/users", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListOktaUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires &#39;sudo&#39; capability in addition to &#39;list&#39;. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ListTokenAccessors(string list, string mountPath = "token")
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListTokenAccessors");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/accessors/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListTokenAccessors", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires &#39;sudo&#39; capability in addition to &#39;list&#39;. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ListTokenAccessorsAsync(string list, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListTokenAccessors");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/accessors/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ListTokenAccessors", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadApproleRoleRoleName(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadApproleRoleRoleNameAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadApproleRoleRoleNameBindSecretId(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameBindSecretId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/bind-secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadApproleRoleRoleNameBindSecretIdAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameBindSecretId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/bind-secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadApproleRoleRoleNameBoundCidrList(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameBoundCidrList");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/bound-cidr-list", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadApproleRoleRoleNameBoundCidrListAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameBoundCidrList");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/bound-cidr-list", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enables cluster local secret IDs 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadApproleRoleRoleNameLocalSecretIds(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameLocalSecretIds");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/local-secret-ids", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameLocalSecretIds", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enables cluster local secret IDs 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadApproleRoleRoleNameLocalSecretIdsAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameLocalSecretIds");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/local-secret-ids", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameLocalSecretIds", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadApproleRoleRoleNamePeriod(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNamePeriod");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/period", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNamePeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadApproleRoleRoleNamePeriodAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNamePeriod");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/period", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNamePeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadApproleRoleRoleNamePolicies(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNamePolicies");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/policies", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNamePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadApproleRoleRoleNamePoliciesAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNamePolicies");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/policies", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNamePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the &#39;role_id&#39; of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadApproleRoleRoleNameRoleId(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameRoleId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/role-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameRoleId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the &#39;role_id&#39; of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadApproleRoleRoleNameRoleIdAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameRoleId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/role-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameRoleId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadApproleRoleRoleNameSecretIdBoundCidrs(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameSecretIdBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameSecretIdBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadApproleRoleRoleNameSecretIdNumUses(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameSecretIdNumUses");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/secret-id-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameSecretIdNumUses");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadApproleRoleRoleNameSecretIdTtl(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameSecretIdTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/secret-id-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadApproleRoleRoleNameSecretIdTtlAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameSecretIdTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadApproleRoleRoleNameTokenBoundCidrs(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameTokenBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/token-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameTokenBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/token-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadApproleRoleRoleNameTokenMaxTtl(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameTokenMaxTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/token-max-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadApproleRoleRoleNameTokenMaxTtlAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameTokenMaxTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/token-max-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadApproleRoleRoleNameTokenNumUses(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameTokenNumUses");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/token-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadApproleRoleRoleNameTokenNumUsesAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameTokenNumUses");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/token-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadApproleRoleRoleNameTokenTtl(string roleName, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameTokenTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/token-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadApproleRoleRoleNameTokenTtlAsync(string roleName, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameTokenTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/token-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadApproleRoleRoleNameTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadAwsConfigCertificateCertName(string certName, string mountPath = "aws")
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->ReadAwsConfigCertificateCertName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/certificate/{cert_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigCertificateCertName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadAwsConfigCertificateCertNameAsync(string certName, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->ReadAwsConfigCertificateCertName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/certificate/{cert_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigCertificateCertName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadAwsConfigClient(string mountPath = "aws")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/client", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigClient", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadAwsConfigClientAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/client", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigClient", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadAwsConfigIdentity(string mountPath = "aws")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/identity", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigIdentity", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadAwsConfigIdentityAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/identity", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigIdentity", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadAwsConfigStsAccountId(string accountId, string mountPath = "aws")
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->ReadAwsConfigStsAccountId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/sts/{account_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigStsAccountId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadAwsConfigStsAccountIdAsync(string accountId, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->ReadAwsConfigStsAccountId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/sts/{account_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigStsAccountId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadAwsConfigTidyIdentityAccesslist(string mountPath = "aws")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/tidy/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigTidyIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadAwsConfigTidyIdentityAccesslistAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/tidy/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigTidyIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadAwsConfigTidyIdentityWhitelist(string mountPath = "aws")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/tidy/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadAwsConfigTidyIdentityWhitelistAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/tidy/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadAwsConfigTidyRoletagBlacklist(string mountPath = "aws")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/tidy/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigTidyRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadAwsConfigTidyRoletagBlacklistAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/tidy/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigTidyRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadAwsConfigTidyRoletagDenylist(string mountPath = "aws")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/tidy/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigTidyRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadAwsConfigTidyRoletagDenylistAsync(string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/tidy/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsConfigTidyRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadAwsIdentityAccesslistInstanceId(string instanceId, string mountPath = "aws")
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->ReadAwsIdentityAccesslistInstanceId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/identity-accesslist/{instance_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsIdentityAccesslistInstanceId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadAwsIdentityAccesslistInstanceIdAsync(string instanceId, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->ReadAwsIdentityAccesslistInstanceId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/identity-accesslist/{instance_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsIdentityAccesslistInstanceId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadAwsIdentityWhitelistInstanceId(string instanceId, string mountPath = "aws")
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->ReadAwsIdentityWhitelistInstanceId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/identity-whitelist/{instance_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsIdentityWhitelistInstanceId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadAwsIdentityWhitelistInstanceIdAsync(string instanceId, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->ReadAwsIdentityWhitelistInstanceId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/identity-whitelist/{instance_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsIdentityWhitelistInstanceId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadAwsRoleRole(string role, string mountPath = "aws")
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->ReadAwsRoleRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadAwsRoleRoleAsync(string role, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->ReadAwsRoleRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadAwsRoletagBlacklistRoleTag(string roleTag, string mountPath = "aws")
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->ReadAwsRoletagBlacklistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/roletag-blacklist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsRoletagBlacklistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadAwsRoletagBlacklistRoleTagAsync(string roleTag, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->ReadAwsRoletagBlacklistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/roletag-blacklist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsRoletagBlacklistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadAwsRoletagDenylistRoleTag(string roleTag, string mountPath = "aws")
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->ReadAwsRoletagDenylistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/roletag-denylist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsRoletagDenylistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadAwsRoletagDenylistRoleTagAsync(string roleTag, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->ReadAwsRoletagDenylistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/roletag-denylist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadAwsRoletagDenylistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadCertCertsName(string name, string mountPath = "cert")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadCertCertsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/certs/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadCertCertsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadCertCertsNameAsync(string name, string mountPath = "cert", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadCertCertsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/certs/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadCertCertsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadCertCrlsName(string name, string mountPath = "cert")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadCertCrlsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/crls/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadCertCrlsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadCertCrlsNameAsync(string name, string mountPath = "cert", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadCertCrlsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/crls/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadCertCrlsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadCfRolesRole(string role, string mountPath = "cf")
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->ReadCfRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadCfRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadCfRolesRoleAsync(string role, string mountPath = "cf", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->ReadCfRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadCfRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read mappings for teams 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadGithubMapTeams(string mountPath = "github", string list = "false")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/map/teams", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGithubMapTeams", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read mappings for teams 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadGithubMapTeamsAsync(string mountPath = "github", string list = "false", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/map/teams", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGithubMapTeams", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadGithubMapTeamsKey(string key, string mountPath = "github")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->ReadGithubMapTeamsKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/map/teams/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGithubMapTeamsKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadGithubMapTeamsKeyAsync(string key, string mountPath = "github", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->ReadGithubMapTeamsKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/map/teams/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGithubMapTeamsKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read mappings for users 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadGithubMapUsers(string mountPath = "github", string list = "false")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/map/users", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGithubMapUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read mappings for users 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadGithubMapUsersAsync(string mountPath = "github", string list = "false", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/map/users", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGithubMapUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadGithubMapUsersKey(string key, string mountPath = "github")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->ReadGithubMapUsersKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/map/users/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGithubMapUsersKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadGithubMapUsersKeyAsync(string key, string mountPath = "github", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->ReadGithubMapUsersKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/map/users/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadGithubMapUsersKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadKerberosConfigLdap(string mountPath = "kerberos")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/ldap", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadKerberosConfigLdap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadKerberosConfigLdapAsync(string mountPath = "kerberos", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/ldap", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadKerberosConfigLdap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadKerberosGroupsName(string name, string mountPath = "kerberos")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadKerberosGroupsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadKerberosGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadKerberosGroupsNameAsync(string name, string mountPath = "kerberos", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadKerberosGroupsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadKerberosGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures the JWT Public Key and Kubernetes API information. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadKubernetesConfig(string mountPath = "kubernetes")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadKubernetesConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures the JWT Public Key and Kubernetes API information. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadKubernetesConfigAsync(string mountPath = "kubernetes", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadKubernetesConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadKubernetesRoleName(string name, string mountPath = "kubernetes")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadKubernetesRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadKubernetesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadKubernetesRoleNameAsync(string name, string mountPath = "kubernetes", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadKubernetesRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadKubernetesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Callback endpoint to complete an OIDC login. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadOidcOidcCallback(string mountPath = "oidc")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/oidc/callback", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadOidcOidcCallback", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Callback endpoint to complete an OIDC login. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadOidcOidcCallbackAsync(string mountPath = "oidc", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/oidc/callback", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadOidcOidcCallback", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadOktaUsersName(string name, string mountPath = "okta")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadOktaUsersName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadOktaUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadOktaUsersNameAsync(string name, string mountPath = "okta", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadOktaUsersName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadOktaUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">Nonce provided during a login request to retrieve the number verification challenge for the matching request.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadOktaVerifyNonce(string nonce, string mountPath = "okta")
        {
            // verify the required parameter 'nonce' is set
            if (nonce == null)
                throw new VaultApiException(400, "Missing required parameter 'nonce' when calling Auth->ReadOktaVerifyNonce");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("nonce", ClientUtils.ParameterToString(nonce)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/verify/{nonce}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadOktaVerifyNonce", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">Nonce provided during a login request to retrieve the number verification challenge for the matching request.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadOktaVerifyNonceAsync(string nonce, string mountPath = "okta", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'nonce' is set
            if (nonce == null)
                throw new VaultApiException(400, "Missing required parameter 'nonce' when calling Auth->ReadOktaVerifyNonce");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("nonce", ClientUtils.ParameterToString(nonce)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/verify/{nonce}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadOktaVerifyNonce", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadTokenLookup(string mountPath = "token")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTokenLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadTokenLookupAsync(string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTokenLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadTokenLookupSelf(string mountPath = "token")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/lookup-self", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTokenLookupSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadTokenLookupSelfAsync(string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/lookup-self", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTokenLookupSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadTokenRolesRoleName(string roleName, string mountPath = "token")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadTokenRolesRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/roles/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTokenRolesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadTokenRolesRoleNameAsync(string roleName, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadTokenRolesRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/roles/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadTokenRolesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> ReadUserpassUsersUsername(string username, string mountPath = "userpass")
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->ReadUserpassUsersUsername");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/users/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadUserpassUsersUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> ReadUserpassUsersUsernameAsync(string username, string mountPath = "userpass", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->ReadUserpassUsersUsername");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/users/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("ReadUserpassUsersUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleName(string roleName, ApproleRoleRequest approleRoleRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleName");

            // verify the required parameter 'approleRoleRequest' is set
            if (approleRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleRequest' when calling Auth->UpdateApproleRoleRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameAsync(string roleName, ApproleRoleRequest approleRoleRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleName");

            // verify the required parameter 'approleRoleRequest' is set
            if (approleRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleRequest' when calling Auth->UpdateApproleRoleRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleBindSecretIdRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNameBindSecretId(string roleName, ApproleRoleBindSecretIdRequest approleRoleBindSecretIdRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameBindSecretId");

            // verify the required parameter 'approleRoleBindSecretIdRequest' is set
            if (approleRoleBindSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleBindSecretIdRequest' when calling Auth->UpdateApproleRoleRoleNameBindSecretId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleBindSecretIdRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/bind-secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleBindSecretIdRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameBindSecretIdAsync(string roleName, ApproleRoleBindSecretIdRequest approleRoleBindSecretIdRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameBindSecretId");

            // verify the required parameter 'approleRoleBindSecretIdRequest' is set
            if (approleRoleBindSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleBindSecretIdRequest' when calling Auth->UpdateApproleRoleRoleNameBindSecretId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleBindSecretIdRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/bind-secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleBoundCidrListRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNameBoundCidrList(string roleName, ApproleRoleBoundCidrListRequest approleRoleBoundCidrListRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameBoundCidrList");

            // verify the required parameter 'approleRoleBoundCidrListRequest' is set
            if (approleRoleBoundCidrListRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleBoundCidrListRequest' when calling Auth->UpdateApproleRoleRoleNameBoundCidrList");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleBoundCidrListRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/bound-cidr-list", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleBoundCidrListRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameBoundCidrListAsync(string roleName, ApproleRoleBoundCidrListRequest approleRoleBoundCidrListRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameBoundCidrList");

            // verify the required parameter 'approleRoleBoundCidrListRequest' is set
            if (approleRoleBoundCidrListRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleBoundCidrListRequest' when calling Auth->UpdateApproleRoleRoleNameBoundCidrList");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleBoundCidrListRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/bound-cidr-list", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Assign a SecretID of choice against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleCustomSecretIdRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNameCustomSecretId(string roleName, ApproleRoleCustomSecretIdRequest approleRoleCustomSecretIdRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameCustomSecretId");

            // verify the required parameter 'approleRoleCustomSecretIdRequest' is set
            if (approleRoleCustomSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleCustomSecretIdRequest' when calling Auth->UpdateApproleRoleRoleNameCustomSecretId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleCustomSecretIdRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/custom-secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameCustomSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Assign a SecretID of choice against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleCustomSecretIdRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameCustomSecretIdAsync(string roleName, ApproleRoleCustomSecretIdRequest approleRoleCustomSecretIdRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameCustomSecretId");

            // verify the required parameter 'approleRoleCustomSecretIdRequest' is set
            if (approleRoleCustomSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleCustomSecretIdRequest' when calling Auth->UpdateApproleRoleRoleNameCustomSecretId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleCustomSecretIdRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/custom-secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameCustomSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRolePeriodRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNamePeriod(string roleName, ApproleRolePeriodRequest approleRolePeriodRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNamePeriod");

            // verify the required parameter 'approleRolePeriodRequest' is set
            if (approleRolePeriodRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRolePeriodRequest' when calling Auth->UpdateApproleRoleRoleNamePeriod");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRolePeriodRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/period", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNamePeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRolePeriodRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNamePeriodAsync(string roleName, ApproleRolePeriodRequest approleRolePeriodRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNamePeriod");

            // verify the required parameter 'approleRolePeriodRequest' is set
            if (approleRolePeriodRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRolePeriodRequest' when calling Auth->UpdateApproleRoleRoleNamePeriod");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRolePeriodRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/period", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNamePeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRolePoliciesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNamePolicies(string roleName, ApproleRolePoliciesRequest approleRolePoliciesRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNamePolicies");

            // verify the required parameter 'approleRolePoliciesRequest' is set
            if (approleRolePoliciesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRolePoliciesRequest' when calling Auth->UpdateApproleRoleRoleNamePolicies");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRolePoliciesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/policies", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNamePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRolePoliciesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNamePoliciesAsync(string roleName, ApproleRolePoliciesRequest approleRolePoliciesRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNamePolicies");

            // verify the required parameter 'approleRolePoliciesRequest' is set
            if (approleRolePoliciesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRolePoliciesRequest' when calling Auth->UpdateApproleRoleRoleNamePolicies");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRolePoliciesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/policies", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNamePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the &#39;role_id&#39; of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleRoleIdRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNameRoleId(string roleName, ApproleRoleRoleIdRequest approleRoleRoleIdRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameRoleId");

            // verify the required parameter 'approleRoleRoleIdRequest' is set
            if (approleRoleRoleIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleRoleIdRequest' when calling Auth->UpdateApproleRoleRoleNameRoleId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleRoleIdRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/role-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameRoleId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the &#39;role_id&#39; of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleRoleIdRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameRoleIdAsync(string roleName, ApproleRoleRoleIdRequest approleRoleRoleIdRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameRoleId");

            // verify the required parameter 'approleRoleRoleIdRequest' is set
            if (approleRoleRoleIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleRoleIdRequest' when calling Auth->UpdateApproleRoleRoleNameRoleId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleRoleIdRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/role-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameRoleId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a SecretID against this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNameSecretId(string roleName, ApproleRoleSecretIdRequest approleRoleSecretIdRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretId");

            // verify the required parameter 'approleRoleSecretIdRequest' is set
            if (approleRoleSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdRequest' when calling Auth->UpdateApproleRoleRoleNameSecretId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a SecretID against this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameSecretIdAsync(string roleName, ApproleRoleSecretIdRequest approleRoleSecretIdRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretId");

            // verify the required parameter 'approleRoleSecretIdRequest' is set
            if (approleRoleSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdRequest' when calling Auth->UpdateApproleRoleRoleNameSecretId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdAccessorDestroyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNameSecretIdAccessorDestroy(string roleName, ApproleRoleSecretIdAccessorDestroyRequest approleRoleSecretIdAccessorDestroyRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdAccessorDestroy");

            // verify the required parameter 'approleRoleSecretIdAccessorDestroyRequest' is set
            if (approleRoleSecretIdAccessorDestroyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdAccessorDestroyRequest' when calling Auth->UpdateApproleRoleRoleNameSecretIdAccessorDestroy");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdAccessorDestroyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/secret-id-accessor/destroy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdAccessorDestroy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdAccessorDestroyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameSecretIdAccessorDestroyAsync(string roleName, ApproleRoleSecretIdAccessorDestroyRequest approleRoleSecretIdAccessorDestroyRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdAccessorDestroy");

            // verify the required parameter 'approleRoleSecretIdAccessorDestroyRequest' is set
            if (approleRoleSecretIdAccessorDestroyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdAccessorDestroyRequest' when calling Auth->UpdateApproleRoleRoleNameSecretIdAccessorDestroy");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdAccessorDestroyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-accessor/destroy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdAccessorDestroy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdAccessorLookupRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNameSecretIdAccessorLookup(string roleName, ApproleRoleSecretIdAccessorLookupRequest approleRoleSecretIdAccessorLookupRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdAccessorLookup");

            // verify the required parameter 'approleRoleSecretIdAccessorLookupRequest' is set
            if (approleRoleSecretIdAccessorLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdAccessorLookupRequest' when calling Auth->UpdateApproleRoleRoleNameSecretIdAccessorLookup");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdAccessorLookupRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/secret-id-accessor/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdAccessorLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdAccessorLookupRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameSecretIdAccessorLookupAsync(string roleName, ApproleRoleSecretIdAccessorLookupRequest approleRoleSecretIdAccessorLookupRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdAccessorLookup");

            // verify the required parameter 'approleRoleSecretIdAccessorLookupRequest' is set
            if (approleRoleSecretIdAccessorLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdAccessorLookupRequest' when calling Auth->UpdateApproleRoleRoleNameSecretIdAccessorLookup");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdAccessorLookupRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-accessor/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdAccessorLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdBoundCidrsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNameSecretIdBoundCidrs(string roleName, ApproleRoleSecretIdBoundCidrsRequest approleRoleSecretIdBoundCidrsRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdBoundCidrs");

            // verify the required parameter 'approleRoleSecretIdBoundCidrsRequest' is set
            if (approleRoleSecretIdBoundCidrsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdBoundCidrsRequest' when calling Auth->UpdateApproleRoleRoleNameSecretIdBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdBoundCidrsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdBoundCidrsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, ApproleRoleSecretIdBoundCidrsRequest approleRoleSecretIdBoundCidrsRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdBoundCidrs");

            // verify the required parameter 'approleRoleSecretIdBoundCidrsRequest' is set
            if (approleRoleSecretIdBoundCidrsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdBoundCidrsRequest' when calling Auth->UpdateApproleRoleRoleNameSecretIdBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdBoundCidrsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Invalidate an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdDestroyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNameSecretIdDestroy(string roleName, ApproleRoleSecretIdDestroyRequest approleRoleSecretIdDestroyRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdDestroy");

            // verify the required parameter 'approleRoleSecretIdDestroyRequest' is set
            if (approleRoleSecretIdDestroyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdDestroyRequest' when calling Auth->UpdateApproleRoleRoleNameSecretIdDestroy");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdDestroyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/secret-id/destroy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdDestroy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Invalidate an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdDestroyRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameSecretIdDestroyAsync(string roleName, ApproleRoleSecretIdDestroyRequest approleRoleSecretIdDestroyRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdDestroy");

            // verify the required parameter 'approleRoleSecretIdDestroyRequest' is set
            if (approleRoleSecretIdDestroyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdDestroyRequest' when calling Auth->UpdateApproleRoleRoleNameSecretIdDestroy");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdDestroyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id/destroy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdDestroy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the properties of an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdLookupRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNameSecretIdLookup(string roleName, ApproleRoleSecretIdLookupRequest approleRoleSecretIdLookupRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdLookup");

            // verify the required parameter 'approleRoleSecretIdLookupRequest' is set
            if (approleRoleSecretIdLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdLookupRequest' when calling Auth->UpdateApproleRoleRoleNameSecretIdLookup");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdLookupRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/secret-id/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the properties of an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdLookupRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameSecretIdLookupAsync(string roleName, ApproleRoleSecretIdLookupRequest approleRoleSecretIdLookupRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdLookup");

            // verify the required parameter 'approleRoleSecretIdLookupRequest' is set
            if (approleRoleSecretIdLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdLookupRequest' when calling Auth->UpdateApproleRoleRoleNameSecretIdLookup");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdLookupRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdNumUsesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNameSecretIdNumUses(string roleName, ApproleRoleSecretIdNumUsesRequest approleRoleSecretIdNumUsesRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdNumUses");

            // verify the required parameter 'approleRoleSecretIdNumUsesRequest' is set
            if (approleRoleSecretIdNumUsesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdNumUsesRequest' when calling Auth->UpdateApproleRoleRoleNameSecretIdNumUses");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdNumUsesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/secret-id-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdNumUsesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, ApproleRoleSecretIdNumUsesRequest approleRoleSecretIdNumUsesRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdNumUses");

            // verify the required parameter 'approleRoleSecretIdNumUsesRequest' is set
            if (approleRoleSecretIdNumUsesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdNumUsesRequest' when calling Auth->UpdateApproleRoleRoleNameSecretIdNumUses");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdNumUsesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdTtlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNameSecretIdTtl(string roleName, ApproleRoleSecretIdTtlRequest approleRoleSecretIdTtlRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdTtl");

            // verify the required parameter 'approleRoleSecretIdTtlRequest' is set
            if (approleRoleSecretIdTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdTtlRequest' when calling Auth->UpdateApproleRoleRoleNameSecretIdTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdTtlRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/secret-id-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdTtlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameSecretIdTtlAsync(string roleName, ApproleRoleSecretIdTtlRequest approleRoleSecretIdTtlRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdTtl");

            // verify the required parameter 'approleRoleSecretIdTtlRequest' is set
            if (approleRoleSecretIdTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdTtlRequest' when calling Auth->UpdateApproleRoleRoleNameSecretIdTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdTtlRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenBoundCidrsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNameTokenBoundCidrs(string roleName, ApproleRoleTokenBoundCidrsRequest approleRoleTokenBoundCidrsRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameTokenBoundCidrs");

            // verify the required parameter 'approleRoleTokenBoundCidrsRequest' is set
            if (approleRoleTokenBoundCidrsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleTokenBoundCidrsRequest' when calling Auth->UpdateApproleRoleRoleNameTokenBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenBoundCidrsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/token-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenBoundCidrsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, ApproleRoleTokenBoundCidrsRequest approleRoleTokenBoundCidrsRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameTokenBoundCidrs");

            // verify the required parameter 'approleRoleTokenBoundCidrsRequest' is set
            if (approleRoleTokenBoundCidrsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleTokenBoundCidrsRequest' when calling Auth->UpdateApproleRoleRoleNameTokenBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenBoundCidrsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/token-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenMaxTtlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNameTokenMaxTtl(string roleName, ApproleRoleTokenMaxTtlRequest approleRoleTokenMaxTtlRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameTokenMaxTtl");

            // verify the required parameter 'approleRoleTokenMaxTtlRequest' is set
            if (approleRoleTokenMaxTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleTokenMaxTtlRequest' when calling Auth->UpdateApproleRoleRoleNameTokenMaxTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenMaxTtlRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/token-max-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenMaxTtlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameTokenMaxTtlAsync(string roleName, ApproleRoleTokenMaxTtlRequest approleRoleTokenMaxTtlRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameTokenMaxTtl");

            // verify the required parameter 'approleRoleTokenMaxTtlRequest' is set
            if (approleRoleTokenMaxTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleTokenMaxTtlRequest' when calling Auth->UpdateApproleRoleRoleNameTokenMaxTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenMaxTtlRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/token-max-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenNumUsesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNameTokenNumUses(string roleName, ApproleRoleTokenNumUsesRequest approleRoleTokenNumUsesRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameTokenNumUses");

            // verify the required parameter 'approleRoleTokenNumUsesRequest' is set
            if (approleRoleTokenNumUsesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleTokenNumUsesRequest' when calling Auth->UpdateApproleRoleRoleNameTokenNumUses");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenNumUsesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/token-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenNumUsesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameTokenNumUsesAsync(string roleName, ApproleRoleTokenNumUsesRequest approleRoleTokenNumUsesRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameTokenNumUses");

            // verify the required parameter 'approleRoleTokenNumUsesRequest' is set
            if (approleRoleTokenNumUsesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleTokenNumUsesRequest' when calling Auth->UpdateApproleRoleRoleNameTokenNumUses");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenNumUsesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/token-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenTtlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleRoleRoleNameTokenTtl(string roleName, ApproleRoleTokenTtlRequest approleRoleTokenTtlRequest, string mountPath = "approle")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameTokenTtl");

            // verify the required parameter 'approleRoleTokenTtlRequest' is set
            if (approleRoleTokenTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleTokenTtlRequest' when calling Auth->UpdateApproleRoleRoleNameTokenTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenTtlRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/token-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenTtlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleRoleRoleNameTokenTtlAsync(string roleName, ApproleRoleTokenTtlRequest approleRoleTokenTtlRequest, string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameTokenTtl");

            // verify the required parameter 'approleRoleTokenTtlRequest' is set
            if (approleRoleTokenTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleTokenTtlRequest' when calling Auth->UpdateApproleRoleRoleNameTokenTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenTtlRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/token-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleRoleRoleNameTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Trigger the clean-up of expired SecretID entries. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateApproleTidySecretId(string mountPath = "approle")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/tidy/secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleTidySecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Trigger the clean-up of expired SecretID entries. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateApproleTidySecretIdAsync(string mountPath = "approle", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/tidy/secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateApproleTidySecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsConfigCertificateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsConfigCertificateCertName(string certName, AwsConfigCertificateRequest awsConfigCertificateRequest, string mountPath = "aws")
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->UpdateAwsConfigCertificateCertName");

            // verify the required parameter 'awsConfigCertificateRequest' is set
            if (awsConfigCertificateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigCertificateRequest' when calling Auth->UpdateAwsConfigCertificateCertName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigCertificateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/certificate/{cert_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigCertificateCertName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsConfigCertificateRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsConfigCertificateCertNameAsync(string certName, AwsConfigCertificateRequest awsConfigCertificateRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->UpdateAwsConfigCertificateCertName");

            // verify the required parameter 'awsConfigCertificateRequest' is set
            if (awsConfigCertificateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigCertificateRequest' when calling Auth->UpdateAwsConfigCertificateCertName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigCertificateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/certificate/{cert_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigCertificateCertName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigClientRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsConfigClient(AwsConfigClientRequest awsConfigClientRequest, string mountPath = "aws")
        {
            // verify the required parameter 'awsConfigClientRequest' is set
            if (awsConfigClientRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigClientRequest' when calling Auth->UpdateAwsConfigClient");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigClientRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/client", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigClient", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigClientRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsConfigClientAsync(AwsConfigClientRequest awsConfigClientRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsConfigClientRequest' is set
            if (awsConfigClientRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigClientRequest' when calling Auth->UpdateAwsConfigClient");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigClientRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/client", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigClient", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigIdentityRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsConfigIdentity(AwsConfigIdentityRequest awsConfigIdentityRequest, string mountPath = "aws")
        {
            // verify the required parameter 'awsConfigIdentityRequest' is set
            if (awsConfigIdentityRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigIdentityRequest' when calling Auth->UpdateAwsConfigIdentity");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigIdentityRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/identity", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigIdentity", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigIdentityRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsConfigIdentityAsync(AwsConfigIdentityRequest awsConfigIdentityRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsConfigIdentityRequest' is set
            if (awsConfigIdentityRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigIdentityRequest' when calling Auth->UpdateAwsConfigIdentity");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigIdentityRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/identity", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigIdentity", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsConfigStsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsConfigStsAccountId(string accountId, AwsConfigStsRequest awsConfigStsRequest, string mountPath = "aws")
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->UpdateAwsConfigStsAccountId");

            // verify the required parameter 'awsConfigStsRequest' is set
            if (awsConfigStsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigStsRequest' when calling Auth->UpdateAwsConfigStsAccountId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigStsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/sts/{account_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigStsAccountId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsConfigStsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsConfigStsAccountIdAsync(string accountId, AwsConfigStsRequest awsConfigStsRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->UpdateAwsConfigStsAccountId");

            // verify the required parameter 'awsConfigStsRequest' is set
            if (awsConfigStsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigStsRequest' when calling Auth->UpdateAwsConfigStsAccountId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigStsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/sts/{account_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigStsAccountId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyIdentityAccesslistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsConfigTidyIdentityAccesslist(AwsConfigTidyIdentityAccesslistRequest awsConfigTidyIdentityAccesslistRequest, string mountPath = "aws")
        {
            // verify the required parameter 'awsConfigTidyIdentityAccesslistRequest' is set
            if (awsConfigTidyIdentityAccesslistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigTidyIdentityAccesslistRequest' when calling Auth->UpdateAwsConfigTidyIdentityAccesslist");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyIdentityAccesslistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/tidy/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigTidyIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyIdentityAccesslistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsConfigTidyIdentityAccesslistAsync(AwsConfigTidyIdentityAccesslistRequest awsConfigTidyIdentityAccesslistRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsConfigTidyIdentityAccesslistRequest' is set
            if (awsConfigTidyIdentityAccesslistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigTidyIdentityAccesslistRequest' when calling Auth->UpdateAwsConfigTidyIdentityAccesslist");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyIdentityAccesslistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/tidy/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigTidyIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyIdentityWhitelistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsConfigTidyIdentityWhitelist(AwsConfigTidyIdentityWhitelistRequest awsConfigTidyIdentityWhitelistRequest, string mountPath = "aws")
        {
            // verify the required parameter 'awsConfigTidyIdentityWhitelistRequest' is set
            if (awsConfigTidyIdentityWhitelistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigTidyIdentityWhitelistRequest' when calling Auth->UpdateAwsConfigTidyIdentityWhitelist");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyIdentityWhitelistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/tidy/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyIdentityWhitelistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsConfigTidyIdentityWhitelistAsync(AwsConfigTidyIdentityWhitelistRequest awsConfigTidyIdentityWhitelistRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsConfigTidyIdentityWhitelistRequest' is set
            if (awsConfigTidyIdentityWhitelistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigTidyIdentityWhitelistRequest' when calling Auth->UpdateAwsConfigTidyIdentityWhitelist");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyIdentityWhitelistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/tidy/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyRoletagBlacklistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsConfigTidyRoletagBlacklist(AwsConfigTidyRoletagBlacklistRequest awsConfigTidyRoletagBlacklistRequest, string mountPath = "aws")
        {
            // verify the required parameter 'awsConfigTidyRoletagBlacklistRequest' is set
            if (awsConfigTidyRoletagBlacklistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigTidyRoletagBlacklistRequest' when calling Auth->UpdateAwsConfigTidyRoletagBlacklist");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyRoletagBlacklistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/tidy/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigTidyRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyRoletagBlacklistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsConfigTidyRoletagBlacklistAsync(AwsConfigTidyRoletagBlacklistRequest awsConfigTidyRoletagBlacklistRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsConfigTidyRoletagBlacklistRequest' is set
            if (awsConfigTidyRoletagBlacklistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigTidyRoletagBlacklistRequest' when calling Auth->UpdateAwsConfigTidyRoletagBlacklist");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyRoletagBlacklistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/tidy/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigTidyRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyRoletagDenylistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsConfigTidyRoletagDenylist(AwsConfigTidyRoletagDenylistRequest awsConfigTidyRoletagDenylistRequest, string mountPath = "aws")
        {
            // verify the required parameter 'awsConfigTidyRoletagDenylistRequest' is set
            if (awsConfigTidyRoletagDenylistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigTidyRoletagDenylistRequest' when calling Auth->UpdateAwsConfigTidyRoletagDenylist");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyRoletagDenylistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/tidy/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigTidyRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyRoletagDenylistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsConfigTidyRoletagDenylistAsync(AwsConfigTidyRoletagDenylistRequest awsConfigTidyRoletagDenylistRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsConfigTidyRoletagDenylistRequest' is set
            if (awsConfigTidyRoletagDenylistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigTidyRoletagDenylistRequest' when calling Auth->UpdateAwsConfigTidyRoletagDenylist");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyRoletagDenylistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/tidy/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsConfigTidyRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsRoleRole(string role, AwsRoleRequest awsRoleRequest, string mountPath = "aws")
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->UpdateAwsRoleRole");

            // verify the required parameter 'awsRoleRequest' is set
            if (awsRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsRoleRequest' when calling Auth->UpdateAwsRoleRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = awsRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsRoleRoleAsync(string role, AwsRoleRequest awsRoleRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->UpdateAwsRoleRole");

            // verify the required parameter 'awsRoleRequest' is set
            if (awsRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsRoleRequest' when calling Auth->UpdateAwsRoleRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = awsRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsRoleTagRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsRoleRoleTag(string role, AwsRoleTagRequest awsRoleTagRequest, string mountPath = "aws")
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->UpdateAwsRoleRoleTag");

            // verify the required parameter 'awsRoleTagRequest' is set
            if (awsRoleTagRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsRoleTagRequest' when calling Auth->UpdateAwsRoleRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = awsRoleTagRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role}/tag", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsRoleRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsRoleTagRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsRoleRoleTagAsync(string role, AwsRoleTagRequest awsRoleTagRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->UpdateAwsRoleRoleTag");

            // verify the required parameter 'awsRoleTagRequest' is set
            if (awsRoleTagRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsRoleTagRequest' when calling Auth->UpdateAwsRoleRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = awsRoleTagRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role}/tag", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsRoleRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsRoletagBlacklistRoleTag(string roleTag, string mountPath = "aws")
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->UpdateAwsRoletagBlacklistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/roletag-blacklist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsRoletagBlacklistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsRoletagBlacklistRoleTagAsync(string roleTag, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->UpdateAwsRoletagBlacklistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/roletag-blacklist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsRoletagBlacklistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsRoletagDenylistRoleTag(string roleTag, string mountPath = "aws")
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->UpdateAwsRoletagDenylistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/roletag-denylist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsRoletagDenylistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsRoletagDenylistRoleTagAsync(string roleTag, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->UpdateAwsRoletagDenylistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/roletag-denylist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsRoletagDenylistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityAccesslistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsTidyIdentityAccesslist(AwsTidyIdentityAccesslistRequest awsTidyIdentityAccesslistRequest, string mountPath = "aws")
        {
            // verify the required parameter 'awsTidyIdentityAccesslistRequest' is set
            if (awsTidyIdentityAccesslistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyIdentityAccesslistRequest' when calling Auth->UpdateAwsTidyIdentityAccesslist");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsTidyIdentityAccesslistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/tidy/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsTidyIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityAccesslistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsTidyIdentityAccesslistAsync(AwsTidyIdentityAccesslistRequest awsTidyIdentityAccesslistRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsTidyIdentityAccesslistRequest' is set
            if (awsTidyIdentityAccesslistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyIdentityAccesslistRequest' when calling Auth->UpdateAwsTidyIdentityAccesslist");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsTidyIdentityAccesslistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/tidy/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsTidyIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityWhitelistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsTidyIdentityWhitelist(AwsTidyIdentityWhitelistRequest awsTidyIdentityWhitelistRequest, string mountPath = "aws")
        {
            // verify the required parameter 'awsTidyIdentityWhitelistRequest' is set
            if (awsTidyIdentityWhitelistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyIdentityWhitelistRequest' when calling Auth->UpdateAwsTidyIdentityWhitelist");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsTidyIdentityWhitelistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/tidy/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityWhitelistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsTidyIdentityWhitelistAsync(AwsTidyIdentityWhitelistRequest awsTidyIdentityWhitelistRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsTidyIdentityWhitelistRequest' is set
            if (awsTidyIdentityWhitelistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyIdentityWhitelistRequest' when calling Auth->UpdateAwsTidyIdentityWhitelist");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsTidyIdentityWhitelistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/tidy/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoletagBlacklistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsTidyRoletagBlacklist(AwsTidyRoletagBlacklistRequest awsTidyRoletagBlacklistRequest, string mountPath = "aws")
        {
            // verify the required parameter 'awsTidyRoletagBlacklistRequest' is set
            if (awsTidyRoletagBlacklistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyRoletagBlacklistRequest' when calling Auth->UpdateAwsTidyRoletagBlacklist");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsTidyRoletagBlacklistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/tidy/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsTidyRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoletagBlacklistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsTidyRoletagBlacklistAsync(AwsTidyRoletagBlacklistRequest awsTidyRoletagBlacklistRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsTidyRoletagBlacklistRequest' is set
            if (awsTidyRoletagBlacklistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyRoletagBlacklistRequest' when calling Auth->UpdateAwsTidyRoletagBlacklist");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsTidyRoletagBlacklistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/tidy/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsTidyRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoletagDenylistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateAwsTidyRoletagDenylist(AwsTidyRoletagDenylistRequest awsTidyRoletagDenylistRequest, string mountPath = "aws")
        {
            // verify the required parameter 'awsTidyRoletagDenylistRequest' is set
            if (awsTidyRoletagDenylistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyRoletagDenylistRequest' when calling Auth->UpdateAwsTidyRoletagDenylist");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsTidyRoletagDenylistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/tidy/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsTidyRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoletagDenylistRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateAwsTidyRoletagDenylistAsync(AwsTidyRoletagDenylistRequest awsTidyRoletagDenylistRequest, string mountPath = "aws", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsTidyRoletagDenylistRequest' is set
            if (awsTidyRoletagDenylistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyRoletagDenylistRequest' when calling Auth->UpdateAwsTidyRoletagDenylist");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsTidyRoletagDenylistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/tidy/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateAwsTidyRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certCertsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateCertCertsName(string name, CertCertsRequest certCertsRequest, string mountPath = "cert")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateCertCertsName");

            // verify the required parameter 'certCertsRequest' is set
            if (certCertsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certCertsRequest' when calling Auth->UpdateCertCertsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = certCertsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/certs/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateCertCertsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certCertsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateCertCertsNameAsync(string name, CertCertsRequest certCertsRequest, string mountPath = "cert", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateCertCertsName");

            // verify the required parameter 'certCertsRequest' is set
            if (certCertsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certCertsRequest' when calling Auth->UpdateCertCertsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = certCertsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/certs/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateCertCertsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certCrlsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateCertCrlsName(string name, CertCrlsRequest certCrlsRequest, string mountPath = "cert")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateCertCrlsName");

            // verify the required parameter 'certCrlsRequest' is set
            if (certCrlsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certCrlsRequest' when calling Auth->UpdateCertCrlsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = certCrlsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/crls/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateCertCrlsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certCrlsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateCertCrlsNameAsync(string name, CertCrlsRequest certCrlsRequest, string mountPath = "cert", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateCertCrlsName");

            // verify the required parameter 'certCrlsRequest' is set
            if (certCrlsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certCrlsRequest' when calling Auth->UpdateCertCrlsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = certCrlsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/crls/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateCertCrlsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfRolesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateCfRolesRole(string role, CfRolesRequest cfRolesRequest, string mountPath = "cf")
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->UpdateCfRolesRole");

            // verify the required parameter 'cfRolesRequest' is set
            if (cfRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'cfRolesRequest' when calling Auth->UpdateCfRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = cfRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateCfRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfRolesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateCfRolesRoleAsync(string role, CfRolesRequest cfRolesRequest, string mountPath = "cf", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->UpdateCfRolesRole");

            // verify the required parameter 'cfRolesRequest' is set
            if (cfRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'cfRolesRequest' when calling Auth->UpdateCfRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = cfRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateCfRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Add or remove labels for an existing &#39;gce&#39; role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleLabelsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpRoleNameLabels(string name, GcpRoleLabelsRequest gcpRoleLabelsRequest, string mountPath = "gcp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateGcpRoleNameLabels");

            // verify the required parameter 'gcpRoleLabelsRequest' is set
            if (gcpRoleLabelsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRoleLabelsRequest' when calling Auth->UpdateGcpRoleNameLabels");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRoleLabelsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{name}/labels", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpRoleNameLabels", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Add or remove labels for an existing &#39;gce&#39; role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleLabelsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpRoleNameLabelsAsync(string name, GcpRoleLabelsRequest gcpRoleLabelsRequest, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateGcpRoleNameLabels");

            // verify the required parameter 'gcpRoleLabelsRequest' is set
            if (gcpRoleLabelsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRoleLabelsRequest' when calling Auth->UpdateGcpRoleNameLabels");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRoleLabelsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{name}/labels", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpRoleNameLabels", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Add or remove service accounts for an existing &#x60;iam&#x60; role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleServiceAccountsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGcpRoleNameServiceAccounts(string name, GcpRoleServiceAccountsRequest gcpRoleServiceAccountsRequest, string mountPath = "gcp")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateGcpRoleNameServiceAccounts");

            // verify the required parameter 'gcpRoleServiceAccountsRequest' is set
            if (gcpRoleServiceAccountsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRoleServiceAccountsRequest' when calling Auth->UpdateGcpRoleNameServiceAccounts");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRoleServiceAccountsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{name}/service-accounts", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpRoleNameServiceAccounts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Add or remove service accounts for an existing &#x60;iam&#x60; role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleServiceAccountsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGcpRoleNameServiceAccountsAsync(string name, GcpRoleServiceAccountsRequest gcpRoleServiceAccountsRequest, string mountPath = "gcp", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateGcpRoleNameServiceAccounts");

            // verify the required parameter 'gcpRoleServiceAccountsRequest' is set
            if (gcpRoleServiceAccountsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRoleServiceAccountsRequest' when calling Auth->UpdateGcpRoleNameServiceAccounts");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRoleServiceAccountsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{name}/service-accounts", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGcpRoleNameServiceAccounts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMapTeamsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGithubMapTeamsKey(string key, GithubMapTeamsRequest githubMapTeamsRequest, string mountPath = "github")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->UpdateGithubMapTeamsKey");

            // verify the required parameter 'githubMapTeamsRequest' is set
            if (githubMapTeamsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubMapTeamsRequest' when calling Auth->UpdateGithubMapTeamsKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = githubMapTeamsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/map/teams/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGithubMapTeamsKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMapTeamsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGithubMapTeamsKeyAsync(string key, GithubMapTeamsRequest githubMapTeamsRequest, string mountPath = "github", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->UpdateGithubMapTeamsKey");

            // verify the required parameter 'githubMapTeamsRequest' is set
            if (githubMapTeamsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubMapTeamsRequest' when calling Auth->UpdateGithubMapTeamsKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = githubMapTeamsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/map/teams/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGithubMapTeamsKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMapUsersRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateGithubMapUsersKey(string key, GithubMapUsersRequest githubMapUsersRequest, string mountPath = "github")
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->UpdateGithubMapUsersKey");

            // verify the required parameter 'githubMapUsersRequest' is set
            if (githubMapUsersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubMapUsersRequest' when calling Auth->UpdateGithubMapUsersKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = githubMapUsersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/map/users/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGithubMapUsersKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMapUsersRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateGithubMapUsersKeyAsync(string key, GithubMapUsersRequest githubMapUsersRequest, string mountPath = "github", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->UpdateGithubMapUsersKey");

            // verify the required parameter 'githubMapUsersRequest' is set
            if (githubMapUsersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubMapUsersRequest' when calling Auth->UpdateGithubMapUsersKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = githubMapUsersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/map/users/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateGithubMapUsersKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigLdapRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateKerberosConfigLdap(KerberosConfigLdapRequest kerberosConfigLdapRequest, string mountPath = "kerberos")
        {
            // verify the required parameter 'kerberosConfigLdapRequest' is set
            if (kerberosConfigLdapRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosConfigLdapRequest' when calling Auth->UpdateKerberosConfigLdap");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = kerberosConfigLdapRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/ldap", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateKerberosConfigLdap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigLdapRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateKerberosConfigLdapAsync(KerberosConfigLdapRequest kerberosConfigLdapRequest, string mountPath = "kerberos", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'kerberosConfigLdapRequest' is set
            if (kerberosConfigLdapRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosConfigLdapRequest' when calling Auth->UpdateKerberosConfigLdap");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = kerberosConfigLdapRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/ldap", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateKerberosConfigLdap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosGroupsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateKerberosGroupsName(string name, KerberosGroupsRequest kerberosGroupsRequest, string mountPath = "kerberos")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateKerberosGroupsName");

            // verify the required parameter 'kerberosGroupsRequest' is set
            if (kerberosGroupsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosGroupsRequest' when calling Auth->UpdateKerberosGroupsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = kerberosGroupsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateKerberosGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosGroupsRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateKerberosGroupsNameAsync(string name, KerberosGroupsRequest kerberosGroupsRequest, string mountPath = "kerberos", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateKerberosGroupsName");

            // verify the required parameter 'kerberosGroupsRequest' is set
            if (kerberosGroupsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosGroupsRequest' when calling Auth->UpdateKerberosGroupsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = kerberosGroupsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateKerberosGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures the JWT Public Key and Kubernetes API information. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateKubernetesConfig(KubernetesConfigRequest kubernetesConfigRequest, string mountPath = "kubernetes")
        {
            // verify the required parameter 'kubernetesConfigRequest' is set
            if (kubernetesConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesConfigRequest' when calling Auth->UpdateKubernetesConfig");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = kubernetesConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateKubernetesConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures the JWT Public Key and Kubernetes API information. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateKubernetesConfigAsync(KubernetesConfigRequest kubernetesConfigRequest, string mountPath = "kubernetes", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'kubernetesConfigRequest' is set
            if (kubernetesConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesConfigRequest' when calling Auth->UpdateKubernetesConfig");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = kubernetesConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateKubernetesConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates Kubernetes service accounts with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesLoginRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateKubernetesLogin(KubernetesLoginRequest kubernetesLoginRequest, string mountPath = "kubernetes")
        {
            // verify the required parameter 'kubernetesLoginRequest' is set
            if (kubernetesLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesLoginRequest' when calling Auth->UpdateKubernetesLogin");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = kubernetesLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateKubernetesLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates Kubernetes service accounts with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesLoginRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateKubernetesLoginAsync(KubernetesLoginRequest kubernetesLoginRequest, string mountPath = "kubernetes", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'kubernetesLoginRequest' is set
            if (kubernetesLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesLoginRequest' when calling Auth->UpdateKubernetesLogin");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = kubernetesLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateKubernetesLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateKubernetesRoleName(string name, KubernetesRoleRequest kubernetesRoleRequest, string mountPath = "kubernetes")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateKubernetesRoleName");

            // verify the required parameter 'kubernetesRoleRequest' is set
            if (kubernetesRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesRoleRequest' when calling Auth->UpdateKubernetesRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = kubernetesRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateKubernetesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesRoleRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateKubernetesRoleNameAsync(string name, KubernetesRoleRequest kubernetesRoleRequest, string mountPath = "kubernetes", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateKubernetesRoleName");

            // verify the required parameter 'kubernetesRoleRequest' is set
            if (kubernetesRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesRoleRequest' when calling Auth->UpdateKubernetesRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = kubernetesRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateKubernetesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates to Vault using OCI credentials 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociLoginRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateOciLoginRole(string role, OciLoginRequest ociLoginRequest, string mountPath = "oci")
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->UpdateOciLoginRole");

            // verify the required parameter 'ociLoginRequest' is set
            if (ociLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ociLoginRequest' when calling Auth->UpdateOciLoginRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = ociLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/login/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateOciLoginRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates to Vault using OCI credentials 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociLoginRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateOciLoginRoleAsync(string role, OciLoginRequest ociLoginRequest, string mountPath = "oci", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->UpdateOciLoginRole");

            // verify the required parameter 'ociLoginRequest' is set
            if (ociLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ociLoginRequest' when calling Auth->UpdateOciLoginRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = ociLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/login/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateOciLoginRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request an authorization URL to start an OIDC login flow. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcOidcAuthUrlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateOidcOidcAuthUrl(OidcOidcAuthUrlRequest oidcOidcAuthUrlRequest, string mountPath = "oidc")
        {
            // verify the required parameter 'oidcOidcAuthUrlRequest' is set
            if (oidcOidcAuthUrlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oidcOidcAuthUrlRequest' when calling Auth->UpdateOidcOidcAuthUrl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = oidcOidcAuthUrlRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/oidc/auth_url", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateOidcOidcAuthUrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request an authorization URL to start an OIDC login flow. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcOidcAuthUrlRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateOidcOidcAuthUrlAsync(OidcOidcAuthUrlRequest oidcOidcAuthUrlRequest, string mountPath = "oidc", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'oidcOidcAuthUrlRequest' is set
            if (oidcOidcAuthUrlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oidcOidcAuthUrlRequest' when calling Auth->UpdateOidcOidcAuthUrl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = oidcOidcAuthUrlRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/oidc/auth_url", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateOidcOidcAuthUrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Callback endpoint to handle form_posts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcOidcCallbackRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateOidcOidcCallback(OidcOidcCallbackRequest oidcOidcCallbackRequest, string mountPath = "oidc")
        {
            // verify the required parameter 'oidcOidcCallbackRequest' is set
            if (oidcOidcCallbackRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oidcOidcCallbackRequest' when calling Auth->UpdateOidcOidcCallback");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = oidcOidcCallbackRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/oidc/callback", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateOidcOidcCallback", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Callback endpoint to handle form_posts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcOidcCallbackRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateOidcOidcCallbackAsync(OidcOidcCallbackRequest oidcOidcCallbackRequest, string mountPath = "oidc", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'oidcOidcCallbackRequest' is set
            if (oidcOidcCallbackRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oidcOidcCallbackRequest' when calling Auth->UpdateOidcOidcCallback");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = oidcOidcCallbackRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/oidc/callback", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateOidcOidcCallback", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username to be used for login.</param>
        /// <param name="oktaLoginRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateOktaLoginUsername(string username, OktaLoginRequest oktaLoginRequest, string mountPath = "okta")
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UpdateOktaLoginUsername");

            // verify the required parameter 'oktaLoginRequest' is set
            if (oktaLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaLoginRequest' when calling Auth->UpdateOktaLoginUsername");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = oktaLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/login/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateOktaLoginUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username to be used for login.</param>
        /// <param name="oktaLoginRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateOktaLoginUsernameAsync(string username, OktaLoginRequest oktaLoginRequest, string mountPath = "okta", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UpdateOktaLoginUsername");

            // verify the required parameter 'oktaLoginRequest' is set
            if (oktaLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaLoginRequest' when calling Auth->UpdateOktaLoginUsername");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = oktaLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/login/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateOktaLoginUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaUsersRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateOktaUsersName(string name, OktaUsersRequest oktaUsersRequest, string mountPath = "okta")
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateOktaUsersName");

            // verify the required parameter 'oktaUsersRequest' is set
            if (oktaUsersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaUsersRequest' when calling Auth->UpdateOktaUsersName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = oktaUsersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateOktaUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaUsersRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateOktaUsersNameAsync(string name, OktaUsersRequest oktaUsersRequest, string mountPath = "okta", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateOktaUsersName");

            // verify the required parameter 'oktaUsersRequest' is set
            if (oktaUsersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaUsersRequest' when calling Auth->UpdateOktaUsersName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = oktaUsersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateOktaUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlusername">Username to be used for login. (URL parameter)</param>
        /// <param name="radiusLoginRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateRadiusLoginUrlusername(string urlusername, RadiusLoginRequest radiusLoginRequest, string mountPath = "radius")
        {
            // verify the required parameter 'urlusername' is set
            if (urlusername == null)
                throw new VaultApiException(400, "Missing required parameter 'urlusername' when calling Auth->UpdateRadiusLoginUrlusername");

            // verify the required parameter 'radiusLoginRequest' is set
            if (radiusLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusLoginRequest' when calling Auth->UpdateRadiusLoginUrlusername");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlusername", ClientUtils.ParameterToString(urlusername)); // path parameter
            requestOptions.Data = radiusLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/login/{urlusername}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateRadiusLoginUrlusername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlusername">Username to be used for login. (URL parameter)</param>
        /// <param name="radiusLoginRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateRadiusLoginUrlusernameAsync(string urlusername, RadiusLoginRequest radiusLoginRequest, string mountPath = "radius", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'urlusername' is set
            if (urlusername == null)
                throw new VaultApiException(400, "Missing required parameter 'urlusername' when calling Auth->UpdateRadiusLoginUrlusername");

            // verify the required parameter 'radiusLoginRequest' is set
            if (radiusLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusLoginRequest' when calling Auth->UpdateRadiusLoginUrlusername");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlusername", ClientUtils.ParameterToString(urlusername)); // path parameter
            requestOptions.Data = radiusLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/login/{urlusername}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateRadiusLoginUrlusername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// The token create path is used to create new tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTokenCreate(TokenCreateRequest tokenCreateRequest, string format = "json", string mountPath = "token")
        {
            // verify the required parameter 'tokenCreateRequest' is set
            if (tokenCreateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateRequest' when calling Auth->UpdateTokenCreate");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/create", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenCreate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// The token create path is used to create new tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTokenCreateAsync(TokenCreateRequest tokenCreateRequest, string format = "json", string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenCreateRequest' is set
            if (tokenCreateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateRequest' when calling Auth->UpdateTokenCreate");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/create", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenCreate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// The token create path is used to create new orphan tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateOrphanRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTokenCreateOrphan(TokenCreateOrphanRequest tokenCreateOrphanRequest, string format = "json", string mountPath = "token")
        {
            // verify the required parameter 'tokenCreateOrphanRequest' is set
            if (tokenCreateOrphanRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateOrphanRequest' when calling Auth->UpdateTokenCreateOrphan");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateOrphanRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/create-orphan", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenCreateOrphan", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// The token create path is used to create new orphan tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateOrphanRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTokenCreateOrphanAsync(TokenCreateOrphanRequest tokenCreateOrphanRequest, string format = "json", string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenCreateOrphanRequest' is set
            if (tokenCreateOrphanRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateOrphanRequest' when calling Auth->UpdateTokenCreateOrphan");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateOrphanRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/create-orphan", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenCreateOrphan", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This token create path is used to create new tokens adhering to the given role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTokenCreateRoleName(string roleName, TokenCreateRequest tokenCreateRequest, string format = "json", string mountPath = "token")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateTokenCreateRoleName");

            // verify the required parameter 'tokenCreateRequest' is set
            if (tokenCreateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateRequest' when calling Auth->UpdateTokenCreateRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/create/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenCreateRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This token create path is used to create new tokens adhering to the given role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTokenCreateRoleNameAsync(string roleName, TokenCreateRequest tokenCreateRequest, string format = "json", string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateTokenCreateRoleName");

            // verify the required parameter 'tokenCreateRequest' is set
            if (tokenCreateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateRequest' when calling Auth->UpdateTokenCreateRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/create/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenCreateRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTokenLookup(TokenLookupRequest tokenLookupRequest, string mountPath = "token")
        {
            // verify the required parameter 'tokenLookupRequest' is set
            if (tokenLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenLookupRequest' when calling Auth->UpdateTokenLookup");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTokenLookupAsync(TokenLookupRequest tokenLookupRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenLookupRequest' is set
            if (tokenLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenLookupRequest' when calling Auth->UpdateTokenLookup");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupAccessorRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTokenLookupAccessor(TokenLookupAccessorRequest tokenLookupAccessorRequest, string mountPath = "token")
        {
            // verify the required parameter 'tokenLookupAccessorRequest' is set
            if (tokenLookupAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenLookupAccessorRequest' when calling Auth->UpdateTokenLookupAccessor");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupAccessorRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/lookup-accessor", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenLookupAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupAccessorRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTokenLookupAccessorAsync(TokenLookupAccessorRequest tokenLookupAccessorRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenLookupAccessorRequest' is set
            if (tokenLookupAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenLookupAccessorRequest' when calling Auth->UpdateTokenLookupAccessor");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupAccessorRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/lookup-accessor", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenLookupAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupSelfRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTokenLookupSelf(TokenLookupSelfRequest tokenLookupSelfRequest, string mountPath = "token")
        {
            // verify the required parameter 'tokenLookupSelfRequest' is set
            if (tokenLookupSelfRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenLookupSelfRequest' when calling Auth->UpdateTokenLookupSelf");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupSelfRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/lookup-self", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenLookupSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupSelfRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTokenLookupSelfAsync(TokenLookupSelfRequest tokenLookupSelfRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenLookupSelfRequest' is set
            if (tokenLookupSelfRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenLookupSelfRequest' when calling Auth->UpdateTokenLookupSelf");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupSelfRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/lookup-self", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenLookupSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will renew the given token and prevent expiration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTokenRenew(TokenRenewRequest tokenRenewRequest, string mountPath = "token")
        {
            // verify the required parameter 'tokenRenewRequest' is set
            if (tokenRenewRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewRequest' when calling Auth->UpdateTokenRenew");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/renew", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenRenew", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will renew the given token and prevent expiration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTokenRenewAsync(TokenRenewRequest tokenRenewRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenRenewRequest' is set
            if (tokenRenewRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewRequest' when calling Auth->UpdateTokenRenew");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/renew", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenRenew", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewAccessorRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTokenRenewAccessor(TokenRenewAccessorRequest tokenRenewAccessorRequest, string mountPath = "token")
        {
            // verify the required parameter 'tokenRenewAccessorRequest' is set
            if (tokenRenewAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewAccessorRequest' when calling Auth->UpdateTokenRenewAccessor");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewAccessorRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/renew-accessor", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenRenewAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewAccessorRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTokenRenewAccessorAsync(TokenRenewAccessorRequest tokenRenewAccessorRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenRenewAccessorRequest' is set
            if (tokenRenewAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewAccessorRequest' when calling Auth->UpdateTokenRenewAccessor");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewAccessorRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/renew-accessor", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenRenewAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will renew the token used to call it and prevent expiration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewSelfRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTokenRenewSelf(TokenRenewSelfRequest tokenRenewSelfRequest, string mountPath = "token")
        {
            // verify the required parameter 'tokenRenewSelfRequest' is set
            if (tokenRenewSelfRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewSelfRequest' when calling Auth->UpdateTokenRenewSelf");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewSelfRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/renew-self", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenRenewSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will renew the token used to call it and prevent expiration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewSelfRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTokenRenewSelfAsync(TokenRenewSelfRequest tokenRenewSelfRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenRenewSelfRequest' is set
            if (tokenRenewSelfRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewSelfRequest' when calling Auth->UpdateTokenRenewSelf");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewSelfRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/renew-self", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenRenewSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the given token and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTokenRevoke(TokenRevokeRequest tokenRevokeRequest, string mountPath = "token")
        {
            // verify the required parameter 'tokenRevokeRequest' is set
            if (tokenRevokeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeRequest' when calling Auth->UpdateTokenRevoke");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/revoke", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the given token and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTokenRevokeAsync(TokenRevokeRequest tokenRevokeRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenRevokeRequest' is set
            if (tokenRevokeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeRequest' when calling Auth->UpdateTokenRevoke");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/revoke", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the token associated with the accessor and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeAccessorRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTokenRevokeAccessor(TokenRevokeAccessorRequest tokenRevokeAccessorRequest, string mountPath = "token")
        {
            // verify the required parameter 'tokenRevokeAccessorRequest' is set
            if (tokenRevokeAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeAccessorRequest' when calling Auth->UpdateTokenRevokeAccessor");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeAccessorRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/revoke-accessor", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenRevokeAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the token associated with the accessor and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeAccessorRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTokenRevokeAccessorAsync(TokenRevokeAccessorRequest tokenRevokeAccessorRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenRevokeAccessorRequest' is set
            if (tokenRevokeAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeAccessorRequest' when calling Auth->UpdateTokenRevokeAccessor");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeAccessorRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/revoke-accessor", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenRevokeAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the token and orphan its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeOrphanRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTokenRevokeOrphan(TokenRevokeOrphanRequest tokenRevokeOrphanRequest, string mountPath = "token")
        {
            // verify the required parameter 'tokenRevokeOrphanRequest' is set
            if (tokenRevokeOrphanRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeOrphanRequest' when calling Auth->UpdateTokenRevokeOrphan");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeOrphanRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/revoke-orphan", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenRevokeOrphan", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the token and orphan its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeOrphanRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTokenRevokeOrphanAsync(TokenRevokeOrphanRequest tokenRevokeOrphanRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenRevokeOrphanRequest' is set
            if (tokenRevokeOrphanRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeOrphanRequest' when calling Auth->UpdateTokenRevokeOrphan");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeOrphanRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/revoke-orphan", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenRevokeOrphan", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the token used to call it and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTokenRevokeSelf(string mountPath = "token")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/revoke-self", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenRevokeSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the token used to call it and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTokenRevokeSelfAsync(string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/revoke-self", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenRevokeSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenRolesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTokenRolesRoleName(string roleName, TokenRolesRequest tokenRolesRequest, string mountPath = "token")
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateTokenRolesRoleName");

            // verify the required parameter 'tokenRolesRequest' is set
            if (tokenRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRolesRequest' when calling Auth->UpdateTokenRolesRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = tokenRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/roles/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenRolesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenRolesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTokenRolesRoleNameAsync(string roleName, TokenRolesRequest tokenRolesRequest, string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateTokenRolesRoleName");

            // verify the required parameter 'tokenRolesRequest' is set
            if (tokenRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRolesRequest' when calling Auth->UpdateTokenRolesRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = tokenRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/roles/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenRolesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateTokenTidy(string mountPath = "token")
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateTokenTidyAsync(string mountPath = "token", CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateTokenTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateUserpassUsersUsername(string username, UserpassUsersRequest userpassUsersRequest, string mountPath = "userpass")
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UpdateUserpassUsersUsername");

            // verify the required parameter 'userpassUsersRequest' is set
            if (userpassUsersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassUsersRequest' when calling Auth->UpdateUserpassUsersUsername");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = userpassUsersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/users/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateUserpassUsersUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateUserpassUsersUsernameAsync(string username, UserpassUsersRequest userpassUsersRequest, string mountPath = "userpass", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UpdateUserpassUsersUsername");

            // verify the required parameter 'userpassUsersRequest' is set
            if (userpassUsersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassUsersRequest' when calling Auth->UpdateUserpassUsersUsername");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = userpassUsersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/users/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateUserpassUsersUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Reset user&#39;s password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersPasswordRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateUserpassUsersUsernamePassword(string username, UserpassUsersPasswordRequest userpassUsersPasswordRequest, string mountPath = "userpass")
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UpdateUserpassUsersUsernamePassword");

            // verify the required parameter 'userpassUsersPasswordRequest' is set
            if (userpassUsersPasswordRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassUsersPasswordRequest' when calling Auth->UpdateUserpassUsersUsernamePassword");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = userpassUsersPasswordRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/users/{username}/password", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateUserpassUsersUsernamePassword", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Reset user&#39;s password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersPasswordRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateUserpassUsersUsernamePasswordAsync(string username, UserpassUsersPasswordRequest userpassUsersPasswordRequest, string mountPath = "userpass", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UpdateUserpassUsersUsernamePassword");

            // verify the required parameter 'userpassUsersPasswordRequest' is set
            if (userpassUsersPasswordRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassUsersPasswordRequest' when calling Auth->UpdateUserpassUsersUsernamePassword");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = userpassUsersPasswordRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/users/{username}/password", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateUserpassUsersUsernamePassword", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Update the policies associated with the username. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersPoliciesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        public VaultResponse<Object> UpdateUserpassUsersUsernamePolicies(string username, UserpassUsersPoliciesRequest userpassUsersPoliciesRequest, string mountPath = "userpass")
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UpdateUserpassUsersUsernamePolicies");

            // verify the required parameter 'userpassUsersPoliciesRequest' is set
            if (userpassUsersPoliciesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassUsersPoliciesRequest' when calling Auth->UpdateUserpassUsersUsernamePolicies");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = userpassUsersPoliciesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/users/{username}/policies", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateUserpassUsersUsernamePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Update the policies associated with the username. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersPoliciesRequest"></param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> UpdateUserpassUsersUsernamePoliciesAsync(string username, UserpassUsersPoliciesRequest userpassUsersPoliciesRequest, string mountPath = "userpass", CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UpdateUserpassUsersUsernamePolicies");

            // verify the required parameter 'userpassUsersPoliciesRequest' is set
            if (userpassUsersPoliciesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassUsersPoliciesRequest' when calling Auth->UpdateUserpassUsersUsernamePolicies");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = userpassUsersPoliciesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/users/{username}/policies", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("UpdateUserpassUsersUsernamePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }

    }
}
