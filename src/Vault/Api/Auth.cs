/*
 * HashiCorp Vault API
 *
 * HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.
 *
 * The version of the OpenAPI document: 1.13.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Threading;
using System.Threading.Tasks;
using Vault.Client;
using Vault.Model;

namespace Vault.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuthSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteApproleRoleRoleName(string roleName, string mountPath = default(string));
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteApproleRoleRoleNameBindSecretId(string roleName, string mountPath = default(string));
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteApproleRoleRoleNameBoundCidrList(string roleName, string mountPath = default(string));
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteApproleRoleRoleNamePeriod(string roleName, string mountPath = default(string));
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteApproleRoleRoleNamePolicies(string roleName, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteApproleRoleRoleNameSecretIdAccessorDestroy(string roleName, string mountPath = default(string));
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteApproleRoleRoleNameSecretIdBoundCidrs(string roleName, string mountPath = default(string));
        /// <summary>
        /// Invalidate an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteApproleRoleRoleNameSecretIdDestroy(string roleName, string mountPath = default(string));
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteApproleRoleRoleNameSecretIdNumUses(string roleName, string mountPath = default(string));
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteApproleRoleRoleNameSecretIdTtl(string roleName, string mountPath = default(string));
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteApproleRoleRoleNameTokenBoundCidrs(string roleName, string mountPath = default(string));
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteApproleRoleRoleNameTokenMaxTtl(string roleName, string mountPath = default(string));
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteApproleRoleRoleNameTokenNumUses(string roleName, string mountPath = default(string));
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteApproleRoleRoleNameTokenTtl(string roleName, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAwsConfigCertificateCertName(string certName, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAwsConfigClient(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAwsConfigStsAccountId(string accountId, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAwsConfigTidyIdentityAccesslist(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAwsConfigTidyIdentityWhitelist(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAwsConfigTidyRoletagBlacklist(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAwsConfigTidyRoletagDenylist(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAwsIdentityAccesslistInstanceId(string instanceId, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAwsIdentityWhitelistInstanceId(string instanceId, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAwsRoleRole(string role, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAwsRoletagBlacklistRoleTag(string roleTag, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteAwsRoletagDenylistRoleTag(string roleTag, string mountPath = default(string));
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteCertCertsName(string name, string mountPath = default(string));
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteCertCrlsName(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteCfRolesRole(string role, string mountPath = default(string));
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteGithubMapTeamsKey(string key, string mountPath = default(string));
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteGithubMapUsersKey(string key, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteKerberosGroupsName(string name, string mountPath = default(string));
        /// <summary>
        /// Delete an existing role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteOidcRoleName(string name, string mountPath = default(string));
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteRadiusUsersName(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteTokenRolesRoleName(string roleName, string mountPath = default(string));
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteUserpassUsersUsername(string username, string mountPath = default(string));
        /// <summary>
        /// Generate a SecretID against this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListApproleRoleRoleNameSecretId(string roleName, string list, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListAwsConfigCertificates(string list, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListAwsConfigSts(string list, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListAwsIdentityAccesslist(string list, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListAwsIdentityWhitelist(string list, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListAwsRoletagBlacklist(string list, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListAwsRoletagDenylist(string list, string mountPath = default(string));
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListCertCerts(string list, string mountPath = default(string));
        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListGcpRoles(string list, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListKerberosGroups(string list, string mountPath = default(string));
        /// <summary>
        /// Lists all the roles registered with the backend.
        /// </summary>
        /// <remarks>
        /// The list will contain the names of the roles.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListOidcRole(string list, string mountPath = default(string));
        /// <summary>
        /// List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires &#39;sudo&#39; capability in addition to &#39;list&#39;.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListTokenAccessors(string list, string mountPath = default(string));
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ListUserpassUsers(string list, string mountPath = default(string));
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadApproleRoleRoleName(string roleName, string mountPath = default(string));
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadApproleRoleRoleNameBindSecretId(string roleName, string mountPath = default(string));
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadApproleRoleRoleNameBoundCidrList(string roleName, string mountPath = default(string));
        /// <summary>
        /// Enables cluster local secret IDs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadApproleRoleRoleNameLocalSecretIds(string roleName, string mountPath = default(string));
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadApproleRoleRoleNamePeriod(string roleName, string mountPath = default(string));
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadApproleRoleRoleNamePolicies(string roleName, string mountPath = default(string));
        /// <summary>
        /// Returns the &#39;role_id&#39; of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadApproleRoleRoleNameRoleId(string roleName, string mountPath = default(string));
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadApproleRoleRoleNameSecretIdBoundCidrs(string roleName, string mountPath = default(string));
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadApproleRoleRoleNameSecretIdNumUses(string roleName, string mountPath = default(string));
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadApproleRoleRoleNameSecretIdTtl(string roleName, string mountPath = default(string));
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadApproleRoleRoleNameTokenBoundCidrs(string roleName, string mountPath = default(string));
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadApproleRoleRoleNameTokenMaxTtl(string roleName, string mountPath = default(string));
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadApproleRoleRoleNameTokenNumUses(string roleName, string mountPath = default(string));
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadApproleRoleRoleNameTokenTtl(string roleName, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsConfigCertificateCertName(string certName, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsConfigClient(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsConfigIdentity(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsConfigStsAccountId(string accountId, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsConfigTidyIdentityAccesslist(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsConfigTidyIdentityWhitelist(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsConfigTidyRoletagBlacklist(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsConfigTidyRoletagDenylist(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsIdentityAccesslistInstanceId(string instanceId, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsIdentityWhitelistInstanceId(string instanceId, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsRoleRole(string role, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsRoletagBlacklistRoleTag(string roleTag, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadAwsRoletagDenylistRoleTag(string roleTag, string mountPath = default(string));
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadCertCertsName(string name, string mountPath = default(string));
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadCertCrlsName(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadCfRolesRole(string role, string mountPath = default(string));
        /// <summary>
        /// Read mappings for teams
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadGithubMapTeams(string mountPath = default(string), string list = default(string));
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadGithubMapTeamsKey(string key, string mountPath = default(string));
        /// <summary>
        /// Read mappings for users
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadGithubMapUsers(string mountPath = default(string), string list = default(string));
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadGithubMapUsersKey(string key, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadKerberosConfigLdap(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadKerberosGroupsName(string name, string mountPath = default(string));
        /// <summary>
        /// Read the current JWT authentication backend configuration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadOidcConfig(string mountPath = default(string));
        /// <summary>
        /// Callback endpoint to complete an OIDC login.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadOidcOidcCallback(string mountPath = default(string));
        /// <summary>
        /// Read an existing role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadOidcRoleName(string name, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">Nonce provided during a login request to retrieve the number verification challenge for the matching request.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadOktaVerifyNonce(string nonce, string mountPath = default(string));
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadRadiusUsersName(string name, string mountPath = default(string));
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadTokenLookup(string mountPath = default(string));
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadTokenLookupSelf(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadTokenRolesRoleName(string roleName, string mountPath = default(string));
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReadUserpassUsersUsername(string username, string mountPath = default(string));
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleName(string roleName, string mountPath = default(string), ApproleRoleRequest approleRoleRequest = default(ApproleRoleRequest));
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleBindSecretIdRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNameBindSecretId(string roleName, string mountPath = default(string), ApproleRoleBindSecretIdRequest approleRoleBindSecretIdRequest = default(ApproleRoleBindSecretIdRequest));
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleBoundCidrListRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNameBoundCidrList(string roleName, string mountPath = default(string), ApproleRoleBoundCidrListRequest approleRoleBoundCidrListRequest = default(ApproleRoleBoundCidrListRequest));
        /// <summary>
        /// Assign a SecretID of choice against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleCustomSecretIdRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNameCustomSecretId(string roleName, string mountPath = default(string), ApproleRoleCustomSecretIdRequest approleRoleCustomSecretIdRequest = default(ApproleRoleCustomSecretIdRequest));
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRolePeriodRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNamePeriod(string roleName, string mountPath = default(string), ApproleRolePeriodRequest approleRolePeriodRequest = default(ApproleRolePeriodRequest));
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRolePoliciesRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNamePolicies(string roleName, string mountPath = default(string), ApproleRolePoliciesRequest approleRolePoliciesRequest = default(ApproleRolePoliciesRequest));
        /// <summary>
        /// Returns the &#39;role_id&#39; of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleRoleIdRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNameRoleId(string roleName, string mountPath = default(string), ApproleRoleRoleIdRequest approleRoleRoleIdRequest = default(ApproleRoleRoleIdRequest));
        /// <summary>
        /// Generate a SecretID against this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNameSecretId(string roleName, string mountPath = default(string), ApproleRoleSecretIdRequest approleRoleSecretIdRequest = default(ApproleRoleSecretIdRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdAccessorDestroyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNameSecretIdAccessorDestroy(string roleName, string mountPath = default(string), ApproleRoleSecretIdAccessorDestroyRequest approleRoleSecretIdAccessorDestroyRequest = default(ApproleRoleSecretIdAccessorDestroyRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdAccessorLookupRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNameSecretIdAccessorLookup(string roleName, string mountPath = default(string), ApproleRoleSecretIdAccessorLookupRequest approleRoleSecretIdAccessorLookupRequest = default(ApproleRoleSecretIdAccessorLookupRequest));
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdBoundCidrsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNameSecretIdBoundCidrs(string roleName, string mountPath = default(string), ApproleRoleSecretIdBoundCidrsRequest approleRoleSecretIdBoundCidrsRequest = default(ApproleRoleSecretIdBoundCidrsRequest));
        /// <summary>
        /// Invalidate an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdDestroyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNameSecretIdDestroy(string roleName, string mountPath = default(string), ApproleRoleSecretIdDestroyRequest approleRoleSecretIdDestroyRequest = default(ApproleRoleSecretIdDestroyRequest));
        /// <summary>
        /// Read the properties of an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdLookupRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNameSecretIdLookup(string roleName, string mountPath = default(string), ApproleRoleSecretIdLookupRequest approleRoleSecretIdLookupRequest = default(ApproleRoleSecretIdLookupRequest));
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdNumUsesRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNameSecretIdNumUses(string roleName, string mountPath = default(string), ApproleRoleSecretIdNumUsesRequest approleRoleSecretIdNumUsesRequest = default(ApproleRoleSecretIdNumUsesRequest));
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdTtlRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNameSecretIdTtl(string roleName, string mountPath = default(string), ApproleRoleSecretIdTtlRequest approleRoleSecretIdTtlRequest = default(ApproleRoleSecretIdTtlRequest));
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleTokenBoundCidrsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNameTokenBoundCidrs(string roleName, string mountPath = default(string), ApproleRoleTokenBoundCidrsRequest approleRoleTokenBoundCidrsRequest = default(ApproleRoleTokenBoundCidrsRequest));
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleTokenMaxTtlRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNameTokenMaxTtl(string roleName, string mountPath = default(string), ApproleRoleTokenMaxTtlRequest approleRoleTokenMaxTtlRequest = default(ApproleRoleTokenMaxTtlRequest));
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleTokenNumUsesRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNameTokenNumUses(string roleName, string mountPath = default(string), ApproleRoleTokenNumUsesRequest approleRoleTokenNumUsesRequest = default(ApproleRoleTokenNumUsesRequest));
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleTokenTtlRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleRoleRoleNameTokenTtl(string roleName, string mountPath = default(string), ApproleRoleTokenTtlRequest approleRoleTokenTtlRequest = default(ApproleRoleTokenTtlRequest));
        /// <summary>
        /// Trigger the clean-up of expired SecretID entries.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateApproleTidySecretId(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigCertificateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsConfigCertificateCertName(string certName, string mountPath = default(string), AwsConfigCertificateRequest awsConfigCertificateRequest = default(AwsConfigCertificateRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigClientRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsConfigClient(string mountPath = default(string), AwsConfigClientRequest awsConfigClientRequest = default(AwsConfigClientRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigIdentityRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsConfigIdentity(string mountPath = default(string), AwsConfigIdentityRequest awsConfigIdentityRequest = default(AwsConfigIdentityRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsConfigRotateRoot(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigStsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsConfigStsAccountId(string accountId, string mountPath = default(string), AwsConfigStsRequest awsConfigStsRequest = default(AwsConfigStsRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigTidyIdentityAccesslistRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsConfigTidyIdentityAccesslist(string mountPath = default(string), AwsConfigTidyIdentityAccesslistRequest awsConfigTidyIdentityAccesslistRequest = default(AwsConfigTidyIdentityAccesslistRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigTidyIdentityWhitelistRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsConfigTidyIdentityWhitelist(string mountPath = default(string), AwsConfigTidyIdentityWhitelistRequest awsConfigTidyIdentityWhitelistRequest = default(AwsConfigTidyIdentityWhitelistRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigTidyRoletagBlacklistRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsConfigTidyRoletagBlacklist(string mountPath = default(string), AwsConfigTidyRoletagBlacklistRequest awsConfigTidyRoletagBlacklistRequest = default(AwsConfigTidyRoletagBlacklistRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigTidyRoletagDenylistRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsConfigTidyRoletagDenylist(string mountPath = default(string), AwsConfigTidyRoletagDenylistRequest awsConfigTidyRoletagDenylistRequest = default(AwsConfigTidyRoletagDenylistRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsRoleRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsRoleRole(string role, string mountPath = default(string), AwsRoleRequest awsRoleRequest = default(AwsRoleRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsRoleTagRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsRoleRoleTag(string role, string mountPath = default(string), AwsRoleTagRequest awsRoleTagRequest = default(AwsRoleTagRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsRoletagBlacklistRoleTag(string roleTag, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsRoletagDenylistRoleTag(string roleTag, string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsTidyIdentityAccesslistRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsTidyIdentityAccesslist(string mountPath = default(string), AwsTidyIdentityAccesslistRequest awsTidyIdentityAccesslistRequest = default(AwsTidyIdentityAccesslistRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsTidyIdentityWhitelistRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsTidyIdentityWhitelist(string mountPath = default(string), AwsTidyIdentityWhitelistRequest awsTidyIdentityWhitelistRequest = default(AwsTidyIdentityWhitelistRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsTidyRoletagBlacklistRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsTidyRoletagBlacklist(string mountPath = default(string), AwsTidyRoletagBlacklistRequest awsTidyRoletagBlacklistRequest = default(AwsTidyRoletagBlacklistRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsTidyRoletagDenylistRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateAwsTidyRoletagDenylist(string mountPath = default(string), AwsTidyRoletagDenylistRequest awsTidyRoletagDenylistRequest = default(AwsTidyRoletagDenylistRequest));
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="certCertsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateCertCertsName(string name, string mountPath = default(string), CertCertsRequest certCertsRequest = default(CertCertsRequest));
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="certCrlsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateCertCrlsName(string name, string mountPath = default(string), CertCrlsRequest certCrlsRequest = default(CertCrlsRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="cfRolesRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateCfRolesRole(string role, string mountPath = default(string), CfRolesRequest cfRolesRequest = default(CfRolesRequest));
        /// <summary>
        /// Add or remove labels for an existing &#39;gce&#39; role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpRoleLabelsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpRoleNameLabels(string name, string mountPath = default(string), GcpRoleLabelsRequest gcpRoleLabelsRequest = default(GcpRoleLabelsRequest));
        /// <summary>
        /// Add or remove service accounts for an existing &#x60;iam&#x60; role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpRoleServiceAccountsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGcpRoleNameServiceAccounts(string name, string mountPath = default(string), GcpRoleServiceAccountsRequest gcpRoleServiceAccountsRequest = default(GcpRoleServiceAccountsRequest));
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="githubMapTeamsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGithubMapTeamsKey(string key, string mountPath = default(string), GithubMapTeamsRequest githubMapTeamsRequest = default(GithubMapTeamsRequest));
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="githubMapUsersRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateGithubMapUsersKey(string key, string mountPath = default(string), GithubMapUsersRequest githubMapUsersRequest = default(GithubMapUsersRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="kerberosConfigLdapRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateKerberosConfigLdap(string mountPath = default(string), KerberosConfigLdapRequest kerberosConfigLdapRequest = default(KerberosConfigLdapRequest));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="kerberosGroupsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateKerberosGroupsName(string name, string mountPath = default(string), KerberosGroupsRequest kerberosGroupsRequest = default(KerberosGroupsRequest));
        /// <summary>
        /// Authenticates to Vault using OCI credentials
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="ociLoginRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateOciLoginRole(string role, string mountPath = default(string), OciLoginRequest ociLoginRequest = default(OciLoginRequest));
        /// <summary>
        /// Configure the JWT authentication backend.
        /// </summary>
        /// <remarks>
        /// The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcConfigRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateOidcConfig(string mountPath = default(string), OidcConfigRequest oidcConfigRequest = default(OidcConfigRequest));
        /// <summary>
        /// Authenticates to Vault using a JWT (or OIDC) token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcLoginRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateOidcLogin(string mountPath = default(string), OidcLoginRequest oidcLoginRequest = default(OidcLoginRequest));
        /// <summary>
        /// Request an authorization URL to start an OIDC login flow.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcOidcAuthUrlRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateOidcOidcAuthUrl(string mountPath = default(string), OidcOidcAuthUrlRequest oidcOidcAuthUrlRequest = default(OidcOidcAuthUrlRequest));
        /// <summary>
        /// Callback endpoint to handle form_posts.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcOidcCallbackRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateOidcOidcCallback(string mountPath = default(string), OidcOidcCallbackRequest oidcOidcCallbackRequest = default(OidcOidcCallbackRequest));
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcRoleRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateOidcRoleName(string name, string mountPath = default(string), OidcRoleRequest oidcRoleRequest = default(OidcRoleRequest));
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlusername">Username to be used for login. (URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="radiusLoginRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateRadiusLoginUrlusername(string urlusername, string mountPath = default(string), RadiusLoginRequest radiusLoginRequest = default(RadiusLoginRequest));
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="radiusUsersRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateRadiusUsersName(string name, string mountPath = default(string), RadiusUsersRequest radiusUsersRequest = default(RadiusUsersRequest));
        /// <summary>
        /// The token create path is used to create new tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="format">Return json formatted output (optional)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenCreateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTokenCreate(string format = default(string), string mountPath = default(string), TokenCreateRequest tokenCreateRequest = default(TokenCreateRequest));
        /// <summary>
        /// The token create path is used to create new orphan tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="format">Return json formatted output (optional)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenCreateOrphanRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTokenCreateOrphan(string format = default(string), string mountPath = default(string), TokenCreateOrphanRequest tokenCreateOrphanRequest = default(TokenCreateOrphanRequest));
        /// <summary>
        /// This token create path is used to create new tokens adhering to the given role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="format">Return json formatted output (optional)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenCreateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTokenCreateRoleName(string roleName, string format = default(string), string mountPath = default(string), TokenCreateRequest tokenCreateRequest = default(TokenCreateRequest));
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenLookupRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTokenLookup(string mountPath = default(string), TokenLookupRequest tokenLookupRequest = default(TokenLookupRequest));
        /// <summary>
        /// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenLookupAccessorRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTokenLookupAccessor(string mountPath = default(string), TokenLookupAccessorRequest tokenLookupAccessorRequest = default(TokenLookupAccessorRequest));
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenLookupSelfRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTokenLookupSelf(string mountPath = default(string), TokenLookupSelfRequest tokenLookupSelfRequest = default(TokenLookupSelfRequest));
        /// <summary>
        /// This endpoint will renew the given token and prevent expiration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRenewRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTokenRenew(string mountPath = default(string), TokenRenewRequest tokenRenewRequest = default(TokenRenewRequest));
        /// <summary>
        /// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRenewAccessorRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTokenRenewAccessor(string mountPath = default(string), TokenRenewAccessorRequest tokenRenewAccessorRequest = default(TokenRenewAccessorRequest));
        /// <summary>
        /// This endpoint will renew the token used to call it and prevent expiration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRenewSelfRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTokenRenewSelf(string mountPath = default(string), TokenRenewSelfRequest tokenRenewSelfRequest = default(TokenRenewSelfRequest));
        /// <summary>
        /// This endpoint will delete the given token and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRevokeRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTokenRevoke(string mountPath = default(string), TokenRevokeRequest tokenRevokeRequest = default(TokenRevokeRequest));
        /// <summary>
        /// This endpoint will delete the token associated with the accessor and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRevokeAccessorRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTokenRevokeAccessor(string mountPath = default(string), TokenRevokeAccessorRequest tokenRevokeAccessorRequest = default(TokenRevokeAccessorRequest));
        /// <summary>
        /// This endpoint will delete the token and orphan its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRevokeOrphanRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTokenRevokeOrphan(string mountPath = default(string), TokenRevokeOrphanRequest tokenRevokeOrphanRequest = default(TokenRevokeOrphanRequest));
        /// <summary>
        /// This endpoint will delete the token used to call it and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTokenRevokeSelf(string mountPath = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRolesRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTokenRolesRoleName(string roleName, string mountPath = default(string), TokenRolesRequest tokenRolesRequest = default(TokenRolesRequest));
        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateTokenTidy(string mountPath = default(string));
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username of the user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="userpassLoginRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateUserpassLoginUsername(string username, string mountPath = default(string), UserpassLoginRequest userpassLoginRequest = default(UserpassLoginRequest));
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="userpassUsersRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateUserpassUsersUsername(string username, string mountPath = default(string), UserpassUsersRequest userpassUsersRequest = default(UserpassUsersRequest));
        /// <summary>
        /// Reset user&#39;s password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="userpassUsersPasswordRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateUserpassUsersUsernamePassword(string username, string mountPath = default(string), UserpassUsersPasswordRequest userpassUsersPasswordRequest = default(UserpassUsersPasswordRequest));
        /// <summary>
        /// Update the policies associated with the username.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="userpassUsersPoliciesRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateUserpassUsersUsernamePolicies(string username, string mountPath = default(string), UserpassUsersPoliciesRequest userpassUsersPoliciesRequest = default(UserpassUsersPoliciesRequest));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuthAsync : IApiAccessor
    {
        #region Asynchronous Operations
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteApproleRoleRoleNameAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteApproleRoleRoleNameBindSecretIdAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteApproleRoleRoleNameBoundCidrListAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteApproleRoleRoleNamePeriodAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteApproleRoleRoleNamePoliciesAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteApproleRoleRoleNameSecretIdAccessorDestroyAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Invalidate an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteApproleRoleRoleNameSecretIdDestroyAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteApproleRoleRoleNameSecretIdTtlAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteApproleRoleRoleNameTokenMaxTtlAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteApproleRoleRoleNameTokenNumUsesAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteApproleRoleRoleNameTokenTtlAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteAwsConfigCertificateCertNameAsync(string certName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteAwsConfigClientAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteAwsConfigStsAccountIdAsync(string accountId, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteAwsConfigTidyIdentityAccesslistAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteAwsConfigTidyIdentityWhitelistAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteAwsConfigTidyRoletagBlacklistAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteAwsConfigTidyRoletagDenylistAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteAwsIdentityAccesslistInstanceIdAsync(string instanceId, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteAwsIdentityWhitelistInstanceIdAsync(string instanceId, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteAwsRoleRoleAsync(string role, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteAwsRoletagBlacklistRoleTagAsync(string roleTag, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteAwsRoletagDenylistRoleTagAsync(string roleTag, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteCertCertsNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteCertCrlsNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteCfRolesRoleAsync(string role, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteGithubMapTeamsKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteGithubMapUsersKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteKerberosGroupsNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete an existing role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteOidcRoleNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteRadiusUsersNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteTokenRolesRoleNameAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> DeleteUserpassUsersUsernameAsync(string username, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a SecretID against this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListApproleRoleRoleNameSecretIdAsync(string roleName, string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListAwsConfigCertificatesAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListAwsConfigStsAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListAwsIdentityAccesslistAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListAwsIdentityWhitelistAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListAwsRoletagBlacklistAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListAwsRoletagDenylistAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListCertCertsAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListGcpRolesAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListKerberosGroupsAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Lists all the roles registered with the backend.
        /// </summary>
        /// <remarks>
        /// The list will contain the names of the roles.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListOidcRoleAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires &#39;sudo&#39; capability in addition to &#39;list&#39;.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListTokenAccessorsAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ListUserpassUsersAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadApproleRoleRoleNameAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadApproleRoleRoleNameBindSecretIdAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadApproleRoleRoleNameBoundCidrListAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Enables cluster local secret IDs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadApproleRoleRoleNameLocalSecretIdsAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadApproleRoleRoleNamePeriodAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadApproleRoleRoleNamePoliciesAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the &#39;role_id&#39; of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadApproleRoleRoleNameRoleIdAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadApproleRoleRoleNameSecretIdTtlAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadApproleRoleRoleNameTokenMaxTtlAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadApproleRoleRoleNameTokenNumUsesAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadApproleRoleRoleNameTokenTtlAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsConfigCertificateCertNameAsync(string certName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsConfigClientAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsConfigIdentityAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsConfigStsAccountIdAsync(string accountId, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsConfigTidyIdentityAccesslistAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsConfigTidyIdentityWhitelistAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsConfigTidyRoletagBlacklistAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsConfigTidyRoletagDenylistAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsIdentityAccesslistInstanceIdAsync(string instanceId, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsIdentityWhitelistInstanceIdAsync(string instanceId, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsRoleRoleAsync(string role, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsRoletagBlacklistRoleTagAsync(string roleTag, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadAwsRoletagDenylistRoleTagAsync(string roleTag, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadCertCertsNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadCertCrlsNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadCfRolesRoleAsync(string role, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read mappings for teams
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadGithubMapTeamsAsync(string mountPath = default(string), string list = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadGithubMapTeamsKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read mappings for users
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadGithubMapUsersAsync(string mountPath = default(string), string list = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadGithubMapUsersKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadKerberosConfigLdapAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadKerberosGroupsNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the current JWT authentication backend configuration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadOidcConfigAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Callback endpoint to complete an OIDC login.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadOidcOidcCallbackAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read an existing role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadOidcRoleNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">Nonce provided during a login request to retrieve the number verification challenge for the matching request.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadOktaVerifyNonceAsync(string nonce, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadRadiusUsersNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadTokenLookupAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadTokenLookupSelfAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadTokenRolesRoleNameAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> ReadUserpassUsersUsernameAsync(string username, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameAsync(string roleName, string mountPath = default(string), ApproleRoleRequest approleRoleRequest = default(ApproleRoleRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleBindSecretIdRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameBindSecretIdAsync(string roleName, string mountPath = default(string), ApproleRoleBindSecretIdRequest approleRoleBindSecretIdRequest = default(ApproleRoleBindSecretIdRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleBoundCidrListRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameBoundCidrListAsync(string roleName, string mountPath = default(string), ApproleRoleBoundCidrListRequest approleRoleBoundCidrListRequest = default(ApproleRoleBoundCidrListRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Assign a SecretID of choice against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleCustomSecretIdRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameCustomSecretIdAsync(string roleName, string mountPath = default(string), ApproleRoleCustomSecretIdRequest approleRoleCustomSecretIdRequest = default(ApproleRoleCustomSecretIdRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRolePeriodRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNamePeriodAsync(string roleName, string mountPath = default(string), ApproleRolePeriodRequest approleRolePeriodRequest = default(ApproleRolePeriodRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRolePoliciesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNamePoliciesAsync(string roleName, string mountPath = default(string), ApproleRolePoliciesRequest approleRolePoliciesRequest = default(ApproleRolePoliciesRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the &#39;role_id&#39; of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleRoleIdRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameRoleIdAsync(string roleName, string mountPath = default(string), ApproleRoleRoleIdRequest approleRoleRoleIdRequest = default(ApproleRoleRoleIdRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a SecretID against this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameSecretIdAsync(string roleName, string mountPath = default(string), ApproleRoleSecretIdRequest approleRoleSecretIdRequest = default(ApproleRoleSecretIdRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdAccessorDestroyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameSecretIdAccessorDestroyAsync(string roleName, string mountPath = default(string), ApproleRoleSecretIdAccessorDestroyRequest approleRoleSecretIdAccessorDestroyRequest = default(ApproleRoleSecretIdAccessorDestroyRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdAccessorLookupRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameSecretIdAccessorLookupAsync(string roleName, string mountPath = default(string), ApproleRoleSecretIdAccessorLookupRequest approleRoleSecretIdAccessorLookupRequest = default(ApproleRoleSecretIdAccessorLookupRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdBoundCidrsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, string mountPath = default(string), ApproleRoleSecretIdBoundCidrsRequest approleRoleSecretIdBoundCidrsRequest = default(ApproleRoleSecretIdBoundCidrsRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Invalidate an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdDestroyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameSecretIdDestroyAsync(string roleName, string mountPath = default(string), ApproleRoleSecretIdDestroyRequest approleRoleSecretIdDestroyRequest = default(ApproleRoleSecretIdDestroyRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the properties of an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdLookupRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameSecretIdLookupAsync(string roleName, string mountPath = default(string), ApproleRoleSecretIdLookupRequest approleRoleSecretIdLookupRequest = default(ApproleRoleSecretIdLookupRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdNumUsesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, string mountPath = default(string), ApproleRoleSecretIdNumUsesRequest approleRoleSecretIdNumUsesRequest = default(ApproleRoleSecretIdNumUsesRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdTtlRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameSecretIdTtlAsync(string roleName, string mountPath = default(string), ApproleRoleSecretIdTtlRequest approleRoleSecretIdTtlRequest = default(ApproleRoleSecretIdTtlRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleTokenBoundCidrsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, string mountPath = default(string), ApproleRoleTokenBoundCidrsRequest approleRoleTokenBoundCidrsRequest = default(ApproleRoleTokenBoundCidrsRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleTokenMaxTtlRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameTokenMaxTtlAsync(string roleName, string mountPath = default(string), ApproleRoleTokenMaxTtlRequest approleRoleTokenMaxTtlRequest = default(ApproleRoleTokenMaxTtlRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleTokenNumUsesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameTokenNumUsesAsync(string roleName, string mountPath = default(string), ApproleRoleTokenNumUsesRequest approleRoleTokenNumUsesRequest = default(ApproleRoleTokenNumUsesRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleTokenTtlRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleRoleRoleNameTokenTtlAsync(string roleName, string mountPath = default(string), ApproleRoleTokenTtlRequest approleRoleTokenTtlRequest = default(ApproleRoleTokenTtlRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Trigger the clean-up of expired SecretID entries.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateApproleTidySecretIdAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigCertificateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsConfigCertificateCertNameAsync(string certName, string mountPath = default(string), AwsConfigCertificateRequest awsConfigCertificateRequest = default(AwsConfigCertificateRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigClientRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsConfigClientAsync(string mountPath = default(string), AwsConfigClientRequest awsConfigClientRequest = default(AwsConfigClientRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigIdentityRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsConfigIdentityAsync(string mountPath = default(string), AwsConfigIdentityRequest awsConfigIdentityRequest = default(AwsConfigIdentityRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsConfigRotateRootAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigStsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsConfigStsAccountIdAsync(string accountId, string mountPath = default(string), AwsConfigStsRequest awsConfigStsRequest = default(AwsConfigStsRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigTidyIdentityAccesslistRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsConfigTidyIdentityAccesslistAsync(string mountPath = default(string), AwsConfigTidyIdentityAccesslistRequest awsConfigTidyIdentityAccesslistRequest = default(AwsConfigTidyIdentityAccesslistRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigTidyIdentityWhitelistRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsConfigTidyIdentityWhitelistAsync(string mountPath = default(string), AwsConfigTidyIdentityWhitelistRequest awsConfigTidyIdentityWhitelistRequest = default(AwsConfigTidyIdentityWhitelistRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigTidyRoletagBlacklistRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsConfigTidyRoletagBlacklistAsync(string mountPath = default(string), AwsConfigTidyRoletagBlacklistRequest awsConfigTidyRoletagBlacklistRequest = default(AwsConfigTidyRoletagBlacklistRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigTidyRoletagDenylistRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsConfigTidyRoletagDenylistAsync(string mountPath = default(string), AwsConfigTidyRoletagDenylistRequest awsConfigTidyRoletagDenylistRequest = default(AwsConfigTidyRoletagDenylistRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsRoleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsRoleRoleAsync(string role, string mountPath = default(string), AwsRoleRequest awsRoleRequest = default(AwsRoleRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsRoleTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsRoleRoleTagAsync(string role, string mountPath = default(string), AwsRoleTagRequest awsRoleTagRequest = default(AwsRoleTagRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsRoletagBlacklistRoleTagAsync(string roleTag, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsRoletagDenylistRoleTagAsync(string roleTag, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsTidyIdentityAccesslistRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsTidyIdentityAccesslistAsync(string mountPath = default(string), AwsTidyIdentityAccesslistRequest awsTidyIdentityAccesslistRequest = default(AwsTidyIdentityAccesslistRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsTidyIdentityWhitelistRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsTidyIdentityWhitelistAsync(string mountPath = default(string), AwsTidyIdentityWhitelistRequest awsTidyIdentityWhitelistRequest = default(AwsTidyIdentityWhitelistRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsTidyRoletagBlacklistRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsTidyRoletagBlacklistAsync(string mountPath = default(string), AwsTidyRoletagBlacklistRequest awsTidyRoletagBlacklistRequest = default(AwsTidyRoletagBlacklistRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsTidyRoletagDenylistRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateAwsTidyRoletagDenylistAsync(string mountPath = default(string), AwsTidyRoletagDenylistRequest awsTidyRoletagDenylistRequest = default(AwsTidyRoletagDenylistRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="certCertsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateCertCertsNameAsync(string name, string mountPath = default(string), CertCertsRequest certCertsRequest = default(CertCertsRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="certCrlsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateCertCrlsNameAsync(string name, string mountPath = default(string), CertCrlsRequest certCrlsRequest = default(CertCrlsRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="cfRolesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateCfRolesRoleAsync(string role, string mountPath = default(string), CfRolesRequest cfRolesRequest = default(CfRolesRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Add or remove labels for an existing &#39;gce&#39; role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpRoleLabelsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpRoleNameLabelsAsync(string name, string mountPath = default(string), GcpRoleLabelsRequest gcpRoleLabelsRequest = default(GcpRoleLabelsRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Add or remove service accounts for an existing &#x60;iam&#x60; role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpRoleServiceAccountsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGcpRoleNameServiceAccountsAsync(string name, string mountPath = default(string), GcpRoleServiceAccountsRequest gcpRoleServiceAccountsRequest = default(GcpRoleServiceAccountsRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="githubMapTeamsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGithubMapTeamsKeyAsync(string key, string mountPath = default(string), GithubMapTeamsRequest githubMapTeamsRequest = default(GithubMapTeamsRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="githubMapUsersRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateGithubMapUsersKeyAsync(string key, string mountPath = default(string), GithubMapUsersRequest githubMapUsersRequest = default(GithubMapUsersRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="kerberosConfigLdapRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateKerberosConfigLdapAsync(string mountPath = default(string), KerberosConfigLdapRequest kerberosConfigLdapRequest = default(KerberosConfigLdapRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="kerberosGroupsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateKerberosGroupsNameAsync(string name, string mountPath = default(string), KerberosGroupsRequest kerberosGroupsRequest = default(KerberosGroupsRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Authenticates to Vault using OCI credentials
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="ociLoginRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateOciLoginRoleAsync(string role, string mountPath = default(string), OciLoginRequest ociLoginRequest = default(OciLoginRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the JWT authentication backend.
        /// </summary>
        /// <remarks>
        /// The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcConfigRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateOidcConfigAsync(string mountPath = default(string), OidcConfigRequest oidcConfigRequest = default(OidcConfigRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Authenticates to Vault using a JWT (or OIDC) token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcLoginRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateOidcLoginAsync(string mountPath = default(string), OidcLoginRequest oidcLoginRequest = default(OidcLoginRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Request an authorization URL to start an OIDC login flow.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcOidcAuthUrlRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateOidcOidcAuthUrlAsync(string mountPath = default(string), OidcOidcAuthUrlRequest oidcOidcAuthUrlRequest = default(OidcOidcAuthUrlRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Callback endpoint to handle form_posts.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcOidcCallbackRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateOidcOidcCallbackAsync(string mountPath = default(string), OidcOidcCallbackRequest oidcOidcCallbackRequest = default(OidcOidcCallbackRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcRoleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateOidcRoleNameAsync(string name, string mountPath = default(string), OidcRoleRequest oidcRoleRequest = default(OidcRoleRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlusername">Username to be used for login. (URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="radiusLoginRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateRadiusLoginUrlusernameAsync(string urlusername, string mountPath = default(string), RadiusLoginRequest radiusLoginRequest = default(RadiusLoginRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="radiusUsersRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateRadiusUsersNameAsync(string name, string mountPath = default(string), RadiusUsersRequest radiusUsersRequest = default(RadiusUsersRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// The token create path is used to create new tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="format">Return json formatted output (optional)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenCreateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTokenCreateAsync(string format = default(string), string mountPath = default(string), TokenCreateRequest tokenCreateRequest = default(TokenCreateRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// The token create path is used to create new orphan tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="format">Return json formatted output (optional)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenCreateOrphanRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTokenCreateOrphanAsync(string format = default(string), string mountPath = default(string), TokenCreateOrphanRequest tokenCreateOrphanRequest = default(TokenCreateOrphanRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This token create path is used to create new tokens adhering to the given role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="format">Return json formatted output (optional)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenCreateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTokenCreateRoleNameAsync(string roleName, string format = default(string), string mountPath = default(string), TokenCreateRequest tokenCreateRequest = default(TokenCreateRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenLookupRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTokenLookupAsync(string mountPath = default(string), TokenLookupRequest tokenLookupRequest = default(TokenLookupRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenLookupAccessorRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTokenLookupAccessorAsync(string mountPath = default(string), TokenLookupAccessorRequest tokenLookupAccessorRequest = default(TokenLookupAccessorRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenLookupSelfRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTokenLookupSelfAsync(string mountPath = default(string), TokenLookupSelfRequest tokenLookupSelfRequest = default(TokenLookupSelfRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will renew the given token and prevent expiration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRenewRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTokenRenewAsync(string mountPath = default(string), TokenRenewRequest tokenRenewRequest = default(TokenRenewRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRenewAccessorRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTokenRenewAccessorAsync(string mountPath = default(string), TokenRenewAccessorRequest tokenRenewAccessorRequest = default(TokenRenewAccessorRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will renew the token used to call it and prevent expiration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRenewSelfRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTokenRenewSelfAsync(string mountPath = default(string), TokenRenewSelfRequest tokenRenewSelfRequest = default(TokenRenewSelfRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will delete the given token and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRevokeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTokenRevokeAsync(string mountPath = default(string), TokenRevokeRequest tokenRevokeRequest = default(TokenRevokeRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will delete the token associated with the accessor and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRevokeAccessorRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTokenRevokeAccessorAsync(string mountPath = default(string), TokenRevokeAccessorRequest tokenRevokeAccessorRequest = default(TokenRevokeAccessorRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will delete the token and orphan its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRevokeOrphanRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTokenRevokeOrphanAsync(string mountPath = default(string), TokenRevokeOrphanRequest tokenRevokeOrphanRequest = default(TokenRevokeOrphanRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will delete the token used to call it and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTokenRevokeSelfAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRolesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTokenRolesRoleNameAsync(string roleName, string mountPath = default(string), TokenRolesRequest tokenRolesRequest = default(TokenRolesRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateTokenTidyAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username of the user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="userpassLoginRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateUserpassLoginUsernameAsync(string username, string mountPath = default(string), UserpassLoginRequest userpassLoginRequest = default(UserpassLoginRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="userpassUsersRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateUserpassUsersUsernameAsync(string username, string mountPath = default(string), UserpassUsersRequest userpassUsersRequest = default(UserpassUsersRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Reset user&#39;s password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="userpassUsersPasswordRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateUserpassUsersUsernamePasswordAsync(string username, string mountPath = default(string), UserpassUsersPasswordRequest userpassUsersPasswordRequest = default(UserpassUsersPasswordRequest), CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Update the policies associated with the username.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="userpassUsersPoliciesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        Task<ApiResponse<Object>> UpdateUserpassUsersUsernamePoliciesAsync(string username, string mountPath = default(string), UserpassUsersPoliciesRequest userpassUsersPoliciesRequest = default(UserpassUsersPoliciesRequest), CancellationToken cancellationToken = default(CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuth : IAuthSync, IAuthAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class Auth : IAuth
    {
        private Vault.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Constructor for Auth
        /// </summary>
        public Auth(ApiClient apiClient)
        {
            if (apiClient == null) throw new ArgumentNullException("ApiClient");
            
            this.Configuration = apiClient.Configuration;
            this.Client = apiClient;
            this.AsynchronousClient = apiClient;
            this.ExceptionFactory = Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Vault.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Vault.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Vault.Client.Configuration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Vault.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteApproleRoleRoleName(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteApproleRoleRoleNameAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteApproleRoleRoleNameBindSecretId(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameBindSecretId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/bind-secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameBindSecretId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteApproleRoleRoleNameBindSecretIdAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameBindSecretId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/bind-secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameBindSecretId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteApproleRoleRoleNameBoundCidrList(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameBoundCidrList");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/bound-cidr-list", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameBoundCidrList", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteApproleRoleRoleNameBoundCidrListAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameBoundCidrList");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/bound-cidr-list", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameBoundCidrList", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteApproleRoleRoleNamePeriod(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNamePeriod");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/period", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNamePeriod", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteApproleRoleRoleNamePeriodAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNamePeriod");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/period", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNamePeriod", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteApproleRoleRoleNamePolicies(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNamePolicies");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/policies", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNamePolicies", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteApproleRoleRoleNamePoliciesAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNamePolicies");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/policies", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNamePolicies", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteApproleRoleRoleNameSecretIdAccessorDestroy(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdAccessorDestroy");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/secret-id-accessor/destroy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdAccessorDestroy", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteApproleRoleRoleNameSecretIdAccessorDestroyAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdAccessorDestroy");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-accessor/destroy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdAccessorDestroy", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteApproleRoleRoleNameSecretIdBoundCidrs(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Invalidate an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteApproleRoleRoleNameSecretIdDestroy(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdDestroy");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/secret-id/destroy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdDestroy", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Invalidate an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteApproleRoleRoleNameSecretIdDestroyAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdDestroy");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id/destroy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdDestroy", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteApproleRoleRoleNameSecretIdNumUses(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdNumUses");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/secret-id-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdNumUses", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdNumUses");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdNumUses", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteApproleRoleRoleNameSecretIdTtl(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/secret-id-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteApproleRoleRoleNameSecretIdTtlAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameSecretIdTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameSecretIdTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteApproleRoleRoleNameTokenBoundCidrs(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameTokenBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/token-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameTokenBoundCidrs", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameTokenBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/token-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameTokenBoundCidrs", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteApproleRoleRoleNameTokenMaxTtl(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameTokenMaxTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/token-max-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameTokenMaxTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteApproleRoleRoleNameTokenMaxTtlAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameTokenMaxTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/token-max-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameTokenMaxTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteApproleRoleRoleNameTokenNumUses(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameTokenNumUses");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/token-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameTokenNumUses", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteApproleRoleRoleNameTokenNumUsesAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameTokenNumUses");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/token-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameTokenNumUses", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteApproleRoleRoleNameTokenTtl(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameTokenTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role_name}/token-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameTokenTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteApproleRoleRoleNameTokenTtlAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteApproleRoleRoleNameTokenTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role_name}/token-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteApproleRoleRoleNameTokenTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteAwsConfigCertificateCertName(string certName, string mountPath = default(string))
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->DeleteAwsConfigCertificateCertName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/config/certificate/{cert_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsConfigCertificateCertName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteAwsConfigCertificateCertNameAsync(string certName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->DeleteAwsConfigCertificateCertName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/config/certificate/{cert_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsConfigCertificateCertName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteAwsConfigClient(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/config/client", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsConfigClient", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteAwsConfigClientAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/config/client", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsConfigClient", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteAwsConfigStsAccountId(string accountId, string mountPath = default(string))
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->DeleteAwsConfigStsAccountId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/config/sts/{account_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsConfigStsAccountId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteAwsConfigStsAccountIdAsync(string accountId, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->DeleteAwsConfigStsAccountId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/config/sts/{account_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsConfigStsAccountId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteAwsConfigTidyIdentityAccesslist(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/config/tidy/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsConfigTidyIdentityAccesslist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteAwsConfigTidyIdentityAccesslistAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/config/tidy/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsConfigTidyIdentityAccesslist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteAwsConfigTidyIdentityWhitelist(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/config/tidy/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsConfigTidyIdentityWhitelist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteAwsConfigTidyIdentityWhitelistAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/config/tidy/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsConfigTidyIdentityWhitelist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteAwsConfigTidyRoletagBlacklist(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/config/tidy/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsConfigTidyRoletagBlacklist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteAwsConfigTidyRoletagBlacklistAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/config/tidy/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsConfigTidyRoletagBlacklist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteAwsConfigTidyRoletagDenylist(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/config/tidy/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsConfigTidyRoletagDenylist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteAwsConfigTidyRoletagDenylistAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/config/tidy/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsConfigTidyRoletagDenylist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteAwsIdentityAccesslistInstanceId(string instanceId, string mountPath = default(string))
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->DeleteAwsIdentityAccesslistInstanceId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/identity-accesslist/{instance_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsIdentityAccesslistInstanceId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteAwsIdentityAccesslistInstanceIdAsync(string instanceId, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->DeleteAwsIdentityAccesslistInstanceId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/identity-accesslist/{instance_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsIdentityAccesslistInstanceId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteAwsIdentityWhitelistInstanceId(string instanceId, string mountPath = default(string))
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->DeleteAwsIdentityWhitelistInstanceId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/identity-whitelist/{instance_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsIdentityWhitelistInstanceId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteAwsIdentityWhitelistInstanceIdAsync(string instanceId, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->DeleteAwsIdentityWhitelistInstanceId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/identity-whitelist/{instance_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsIdentityWhitelistInstanceId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteAwsRoleRole(string role, string mountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->DeleteAwsRoleRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsRoleRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteAwsRoleRoleAsync(string role, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->DeleteAwsRoleRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsRoleRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteAwsRoletagBlacklistRoleTag(string roleTag, string mountPath = default(string))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->DeleteAwsRoletagBlacklistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/roletag-blacklist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsRoletagBlacklistRoleTag", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteAwsRoletagBlacklistRoleTagAsync(string roleTag, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->DeleteAwsRoletagBlacklistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/roletag-blacklist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsRoletagBlacklistRoleTag", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteAwsRoletagDenylistRoleTag(string roleTag, string mountPath = default(string))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->DeleteAwsRoletagDenylistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/roletag-denylist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsRoletagDenylistRoleTag", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteAwsRoletagDenylistRoleTagAsync(string roleTag, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->DeleteAwsRoletagDenylistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/roletag-denylist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAwsRoletagDenylistRoleTag", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteCertCertsName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteCertCertsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/certs/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteCertCertsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteCertCertsNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteCertCertsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/certs/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteCertCertsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteCertCrlsName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteCertCrlsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/crls/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteCertCrlsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteCertCrlsNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteCertCrlsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/crls/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteCertCrlsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteCfRolesRole(string role, string mountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->DeleteCfRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteCfRolesRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteCfRolesRoleAsync(string role, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->DeleteCfRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteCfRolesRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteGithubMapTeamsKey(string key, string mountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->DeleteGithubMapTeamsKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/map/teams/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGithubMapTeamsKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteGithubMapTeamsKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->DeleteGithubMapTeamsKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/map/teams/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGithubMapTeamsKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteGithubMapUsersKey(string key, string mountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->DeleteGithubMapUsersKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/map/users/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGithubMapUsersKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteGithubMapUsersKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->DeleteGithubMapUsersKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/map/users/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteGithubMapUsersKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteKerberosGroupsName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteKerberosGroupsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteKerberosGroupsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteKerberosGroupsNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteKerberosGroupsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteKerberosGroupsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Delete an existing role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteOidcRoleName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteOidcRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteOidcRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Delete an existing role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteOidcRoleNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteOidcRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteOidcRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteRadiusUsersName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteRadiusUsersName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteRadiusUsersName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteRadiusUsersNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteRadiusUsersName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteRadiusUsersName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteTokenRolesRoleName(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteTokenRolesRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/roles/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteTokenRolesRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteTokenRolesRoleNameAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteTokenRolesRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/roles/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteTokenRolesRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteUserpassUsersUsername(string username, string mountPath = default(string))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->DeleteUserpassUsersUsername");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{mount_path}/users/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteUserpassUsersUsername", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> DeleteUserpassUsersUsernameAsync(string username, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->DeleteUserpassUsersUsername");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{mount_path}/users/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteUserpassUsersUsername", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate a SecretID against this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListApproleRoleRoleNameSecretId(string roleName, string list, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ListApproleRoleRoleNameSecretId");

            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListApproleRoleRoleNameSecretId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListApproleRoleRoleNameSecretId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate a SecretID against this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListApproleRoleRoleNameSecretIdAsync(string roleName, string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ListApproleRoleRoleNameSecretId");

            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListApproleRoleRoleNameSecretId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListApproleRoleRoleNameSecretId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListAwsConfigCertificates(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsConfigCertificates");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/certificates", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAwsConfigCertificates", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListAwsConfigCertificatesAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsConfigCertificates");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/certificates", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAwsConfigCertificates", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListAwsConfigSts(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsConfigSts");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/sts", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAwsConfigSts", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListAwsConfigStsAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsConfigSts");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/sts", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAwsConfigSts", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListAwsIdentityAccesslist(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsIdentityAccesslist");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAwsIdentityAccesslist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListAwsIdentityAccesslistAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsIdentityAccesslist");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAwsIdentityAccesslist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListAwsIdentityWhitelist(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsIdentityWhitelist");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAwsIdentityWhitelist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListAwsIdentityWhitelistAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsIdentityWhitelist");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAwsIdentityWhitelist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListAwsRoletagBlacklist(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsRoletagBlacklist");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAwsRoletagBlacklist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListAwsRoletagBlacklistAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsRoletagBlacklist");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAwsRoletagBlacklist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListAwsRoletagDenylist(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsRoletagDenylist");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAwsRoletagDenylist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListAwsRoletagDenylistAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListAwsRoletagDenylist");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAwsRoletagDenylist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListCertCerts(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListCertCerts");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/certs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListCertCerts", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListCertCertsAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListCertCerts");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/certs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListCertCerts", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListGcpRoles(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListGcpRoles");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListGcpRoles", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListGcpRolesAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListGcpRoles");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListGcpRoles", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListKerberosGroups(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListKerberosGroups");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/groups", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListKerberosGroups", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListKerberosGroupsAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListKerberosGroups");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/groups", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListKerberosGroups", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Lists all the roles registered with the backend. The list will contain the names of the roles.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListOidcRole(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListOidcRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListOidcRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Lists all the roles registered with the backend. The list will contain the names of the roles.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListOidcRoleAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListOidcRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListOidcRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires &#39;sudo&#39; capability in addition to &#39;list&#39;. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListTokenAccessors(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListTokenAccessors");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/accessors/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListTokenAccessors", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires &#39;sudo&#39; capability in addition to &#39;list&#39;. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListTokenAccessorsAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListTokenAccessors");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/accessors/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListTokenAccessors", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ListUserpassUsers(string list, string mountPath = default(string))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListUserpassUsers");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/users", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListUserpassUsers", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ListUserpassUsersAsync(string list, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->ListUserpassUsers");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/users", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListUserpassUsers", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadApproleRoleRoleName(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadApproleRoleRoleNameAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadApproleRoleRoleNameBindSecretId(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameBindSecretId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/bind-secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameBindSecretId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadApproleRoleRoleNameBindSecretIdAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameBindSecretId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/bind-secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameBindSecretId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadApproleRoleRoleNameBoundCidrList(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameBoundCidrList");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/bound-cidr-list", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameBoundCidrList", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadApproleRoleRoleNameBoundCidrListAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameBoundCidrList");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/bound-cidr-list", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameBoundCidrList", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Enables cluster local secret IDs 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadApproleRoleRoleNameLocalSecretIds(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameLocalSecretIds");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/local-secret-ids", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameLocalSecretIds", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Enables cluster local secret IDs 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadApproleRoleRoleNameLocalSecretIdsAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameLocalSecretIds");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/local-secret-ids", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameLocalSecretIds", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadApproleRoleRoleNamePeriod(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNamePeriod");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/period", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNamePeriod", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadApproleRoleRoleNamePeriodAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNamePeriod");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/period", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNamePeriod", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadApproleRoleRoleNamePolicies(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNamePolicies");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/policies", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNamePolicies", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadApproleRoleRoleNamePoliciesAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNamePolicies");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/policies", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNamePolicies", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Returns the &#39;role_id&#39; of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadApproleRoleRoleNameRoleId(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameRoleId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/role-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameRoleId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Returns the &#39;role_id&#39; of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadApproleRoleRoleNameRoleIdAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameRoleId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/role-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameRoleId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadApproleRoleRoleNameSecretIdBoundCidrs(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameSecretIdBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameSecretIdBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadApproleRoleRoleNameSecretIdNumUses(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameSecretIdNumUses");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/secret-id-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameSecretIdNumUses", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameSecretIdNumUses");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameSecretIdNumUses", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadApproleRoleRoleNameSecretIdTtl(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameSecretIdTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/secret-id-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameSecretIdTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadApproleRoleRoleNameSecretIdTtlAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameSecretIdTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameSecretIdTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadApproleRoleRoleNameTokenBoundCidrs(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameTokenBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/token-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameTokenBoundCidrs", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameTokenBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/token-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameTokenBoundCidrs", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadApproleRoleRoleNameTokenMaxTtl(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameTokenMaxTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/token-max-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameTokenMaxTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadApproleRoleRoleNameTokenMaxTtlAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameTokenMaxTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/token-max-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameTokenMaxTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadApproleRoleRoleNameTokenNumUses(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameTokenNumUses");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/token-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameTokenNumUses", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadApproleRoleRoleNameTokenNumUsesAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameTokenNumUses");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/token-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameTokenNumUses", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadApproleRoleRoleNameTokenTtl(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameTokenTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role_name}/token-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameTokenTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadApproleRoleRoleNameTokenTtlAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadApproleRoleRoleNameTokenTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role_name}/token-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadApproleRoleRoleNameTokenTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsConfigCertificateCertName(string certName, string mountPath = default(string))
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->ReadAwsConfigCertificateCertName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/certificate/{cert_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigCertificateCertName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsConfigCertificateCertNameAsync(string certName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->ReadAwsConfigCertificateCertName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/certificate/{cert_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigCertificateCertName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsConfigClient(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/client", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigClient", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsConfigClientAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/client", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigClient", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsConfigIdentity(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/identity", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigIdentity", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsConfigIdentityAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/identity", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigIdentity", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsConfigStsAccountId(string accountId, string mountPath = default(string))
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->ReadAwsConfigStsAccountId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/sts/{account_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigStsAccountId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsConfigStsAccountIdAsync(string accountId, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->ReadAwsConfigStsAccountId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/sts/{account_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigStsAccountId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsConfigTidyIdentityAccesslist(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/tidy/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigTidyIdentityAccesslist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsConfigTidyIdentityAccesslistAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/tidy/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigTidyIdentityAccesslist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsConfigTidyIdentityWhitelist(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/tidy/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigTidyIdentityWhitelist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsConfigTidyIdentityWhitelistAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/tidy/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigTidyIdentityWhitelist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsConfigTidyRoletagBlacklist(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/tidy/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigTidyRoletagBlacklist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsConfigTidyRoletagBlacklistAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/tidy/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigTidyRoletagBlacklist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsConfigTidyRoletagDenylist(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/tidy/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigTidyRoletagDenylist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsConfigTidyRoletagDenylistAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/tidy/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsConfigTidyRoletagDenylist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsIdentityAccesslistInstanceId(string instanceId, string mountPath = default(string))
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->ReadAwsIdentityAccesslistInstanceId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/identity-accesslist/{instance_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsIdentityAccesslistInstanceId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsIdentityAccesslistInstanceIdAsync(string instanceId, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->ReadAwsIdentityAccesslistInstanceId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/identity-accesslist/{instance_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsIdentityAccesslistInstanceId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsIdentityWhitelistInstanceId(string instanceId, string mountPath = default(string))
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->ReadAwsIdentityWhitelistInstanceId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/identity-whitelist/{instance_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsIdentityWhitelistInstanceId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsIdentityWhitelistInstanceIdAsync(string instanceId, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->ReadAwsIdentityWhitelistInstanceId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/identity-whitelist/{instance_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsIdentityWhitelistInstanceId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsRoleRole(string role, string mountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->ReadAwsRoleRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsRoleRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsRoleRoleAsync(string role, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->ReadAwsRoleRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsRoleRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsRoletagBlacklistRoleTag(string roleTag, string mountPath = default(string))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->ReadAwsRoletagBlacklistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/roletag-blacklist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsRoletagBlacklistRoleTag", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsRoletagBlacklistRoleTagAsync(string roleTag, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->ReadAwsRoletagBlacklistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/roletag-blacklist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsRoletagBlacklistRoleTag", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadAwsRoletagDenylistRoleTag(string roleTag, string mountPath = default(string))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->ReadAwsRoletagDenylistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/roletag-denylist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsRoletagDenylistRoleTag", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadAwsRoletagDenylistRoleTagAsync(string roleTag, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->ReadAwsRoletagDenylistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/roletag-denylist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadAwsRoletagDenylistRoleTag", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadCertCertsName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadCertCertsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/certs/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadCertCertsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadCertCertsNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadCertCertsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/certs/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadCertCertsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadCertCrlsName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadCertCrlsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/crls/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadCertCrlsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadCertCrlsNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadCertCrlsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/crls/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadCertCrlsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadCfRolesRole(string role, string mountPath = default(string))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->ReadCfRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadCfRolesRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadCfRolesRoleAsync(string role, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->ReadCfRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadCfRolesRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read mappings for teams 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadGithubMapTeams(string mountPath = default(string), string list = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/map/teams", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGithubMapTeams", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read mappings for teams 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadGithubMapTeamsAsync(string mountPath = default(string), string list = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/map/teams", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGithubMapTeams", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadGithubMapTeamsKey(string key, string mountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->ReadGithubMapTeamsKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/map/teams/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGithubMapTeamsKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadGithubMapTeamsKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->ReadGithubMapTeamsKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/map/teams/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGithubMapTeamsKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read mappings for users 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadGithubMapUsers(string mountPath = default(string), string list = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/map/users", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGithubMapUsers", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read mappings for users 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadGithubMapUsersAsync(string mountPath = default(string), string list = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/map/users", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGithubMapUsers", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadGithubMapUsersKey(string key, string mountPath = default(string))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->ReadGithubMapUsersKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/map/users/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGithubMapUsersKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadGithubMapUsersKeyAsync(string key, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->ReadGithubMapUsersKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/map/users/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadGithubMapUsersKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadKerberosConfigLdap(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config/ldap", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadKerberosConfigLdap", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadKerberosConfigLdapAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config/ldap", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadKerberosConfigLdap", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadKerberosGroupsName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadKerberosGroupsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadKerberosGroupsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadKerberosGroupsNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadKerberosGroupsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadKerberosGroupsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read the current JWT authentication backend configuration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadOidcConfig(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadOidcConfig", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read the current JWT authentication backend configuration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadOidcConfigAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadOidcConfig", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Callback endpoint to complete an OIDC login. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadOidcOidcCallback(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/oidc/callback", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadOidcOidcCallback", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Callback endpoint to complete an OIDC login. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadOidcOidcCallbackAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/oidc/callback", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadOidcOidcCallback", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read an existing role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadOidcRoleName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadOidcRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadOidcRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read an existing role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadOidcRoleNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadOidcRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadOidcRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">Nonce provided during a login request to retrieve the number verification challenge for the matching request.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadOktaVerifyNonce(string nonce, string mountPath = default(string))
        {
            // verify the required parameter 'nonce' is set
            if (nonce == null)
                throw new VaultApiException(400, "Missing required parameter 'nonce' when calling Auth->ReadOktaVerifyNonce");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("nonce", ClientUtils.ParameterToString(nonce)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/verify/{nonce}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadOktaVerifyNonce", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">Nonce provided during a login request to retrieve the number verification challenge for the matching request.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadOktaVerifyNonceAsync(string nonce, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'nonce' is set
            if (nonce == null)
                throw new VaultApiException(400, "Missing required parameter 'nonce' when calling Auth->ReadOktaVerifyNonce");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("nonce", ClientUtils.ParameterToString(nonce)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/verify/{nonce}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadOktaVerifyNonce", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadRadiusUsersName(string name, string mountPath = default(string))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadRadiusUsersName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadRadiusUsersName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadRadiusUsersNameAsync(string name, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->ReadRadiusUsersName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadRadiusUsersName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadTokenLookup(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTokenLookup", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadTokenLookupAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTokenLookup", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadTokenLookupSelf(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/lookup-self", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTokenLookupSelf", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadTokenLookupSelfAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/lookup-self", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTokenLookupSelf", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadTokenRolesRoleName(string roleName, string mountPath = default(string))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadTokenRolesRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/roles/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTokenRolesRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadTokenRolesRoleNameAsync(string roleName, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->ReadTokenRolesRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/roles/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadTokenRolesRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReadUserpassUsersUsername(string username, string mountPath = default(string))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->ReadUserpassUsersUsername");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{mount_path}/users/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadUserpassUsersUsername", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> ReadUserpassUsersUsernameAsync(string username, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->ReadUserpassUsersUsername");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{mount_path}/users/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReadUserpassUsersUsername", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleName(string roleName, string mountPath = default(string), ApproleRoleRequest approleRoleRequest = default(ApproleRoleRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameAsync(string roleName, string mountPath = default(string), ApproleRoleRequest approleRoleRequest = default(ApproleRoleRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleBindSecretIdRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNameBindSecretId(string roleName, string mountPath = default(string), ApproleRoleBindSecretIdRequest approleRoleBindSecretIdRequest = default(ApproleRoleBindSecretIdRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameBindSecretId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleBindSecretIdRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/bind-secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameBindSecretId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleBindSecretIdRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameBindSecretIdAsync(string roleName, string mountPath = default(string), ApproleRoleBindSecretIdRequest approleRoleBindSecretIdRequest = default(ApproleRoleBindSecretIdRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameBindSecretId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleBindSecretIdRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/bind-secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameBindSecretId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleBoundCidrListRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNameBoundCidrList(string roleName, string mountPath = default(string), ApproleRoleBoundCidrListRequest approleRoleBoundCidrListRequest = default(ApproleRoleBoundCidrListRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameBoundCidrList");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleBoundCidrListRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/bound-cidr-list", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameBoundCidrList", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleBoundCidrListRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameBoundCidrListAsync(string roleName, string mountPath = default(string), ApproleRoleBoundCidrListRequest approleRoleBoundCidrListRequest = default(ApproleRoleBoundCidrListRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameBoundCidrList");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleBoundCidrListRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/bound-cidr-list", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameBoundCidrList", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Assign a SecretID of choice against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleCustomSecretIdRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNameCustomSecretId(string roleName, string mountPath = default(string), ApproleRoleCustomSecretIdRequest approleRoleCustomSecretIdRequest = default(ApproleRoleCustomSecretIdRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameCustomSecretId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleCustomSecretIdRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/custom-secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameCustomSecretId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Assign a SecretID of choice against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleCustomSecretIdRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameCustomSecretIdAsync(string roleName, string mountPath = default(string), ApproleRoleCustomSecretIdRequest approleRoleCustomSecretIdRequest = default(ApproleRoleCustomSecretIdRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameCustomSecretId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleCustomSecretIdRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/custom-secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameCustomSecretId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRolePeriodRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNamePeriod(string roleName, string mountPath = default(string), ApproleRolePeriodRequest approleRolePeriodRequest = default(ApproleRolePeriodRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNamePeriod");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRolePeriodRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/period", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNamePeriod", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRolePeriodRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNamePeriodAsync(string roleName, string mountPath = default(string), ApproleRolePeriodRequest approleRolePeriodRequest = default(ApproleRolePeriodRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNamePeriod");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRolePeriodRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/period", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNamePeriod", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRolePoliciesRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNamePolicies(string roleName, string mountPath = default(string), ApproleRolePoliciesRequest approleRolePoliciesRequest = default(ApproleRolePoliciesRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNamePolicies");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRolePoliciesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/policies", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNamePolicies", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRolePoliciesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNamePoliciesAsync(string roleName, string mountPath = default(string), ApproleRolePoliciesRequest approleRolePoliciesRequest = default(ApproleRolePoliciesRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNamePolicies");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRolePoliciesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/policies", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNamePolicies", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Returns the &#39;role_id&#39; of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleRoleIdRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNameRoleId(string roleName, string mountPath = default(string), ApproleRoleRoleIdRequest approleRoleRoleIdRequest = default(ApproleRoleRoleIdRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameRoleId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleRoleIdRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/role-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameRoleId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Returns the &#39;role_id&#39; of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleRoleIdRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameRoleIdAsync(string roleName, string mountPath = default(string), ApproleRoleRoleIdRequest approleRoleRoleIdRequest = default(ApproleRoleRoleIdRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameRoleId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleRoleIdRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/role-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameRoleId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate a SecretID against this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNameSecretId(string roleName, string mountPath = default(string), ApproleRoleSecretIdRequest approleRoleSecretIdRequest = default(ApproleRoleSecretIdRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Generate a SecretID against this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameSecretIdAsync(string roleName, string mountPath = default(string), ApproleRoleSecretIdRequest approleRoleSecretIdRequest = default(ApproleRoleSecretIdRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdAccessorDestroyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNameSecretIdAccessorDestroy(string roleName, string mountPath = default(string), ApproleRoleSecretIdAccessorDestroyRequest approleRoleSecretIdAccessorDestroyRequest = default(ApproleRoleSecretIdAccessorDestroyRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdAccessorDestroy");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdAccessorDestroyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/secret-id-accessor/destroy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdAccessorDestroy", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdAccessorDestroyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameSecretIdAccessorDestroyAsync(string roleName, string mountPath = default(string), ApproleRoleSecretIdAccessorDestroyRequest approleRoleSecretIdAccessorDestroyRequest = default(ApproleRoleSecretIdAccessorDestroyRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdAccessorDestroy");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdAccessorDestroyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-accessor/destroy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdAccessorDestroy", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdAccessorLookupRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNameSecretIdAccessorLookup(string roleName, string mountPath = default(string), ApproleRoleSecretIdAccessorLookupRequest approleRoleSecretIdAccessorLookupRequest = default(ApproleRoleSecretIdAccessorLookupRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdAccessorLookup");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdAccessorLookupRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/secret-id-accessor/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdAccessorLookup", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdAccessorLookupRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameSecretIdAccessorLookupAsync(string roleName, string mountPath = default(string), ApproleRoleSecretIdAccessorLookupRequest approleRoleSecretIdAccessorLookupRequest = default(ApproleRoleSecretIdAccessorLookupRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdAccessorLookup");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdAccessorLookupRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-accessor/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdAccessorLookup", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdBoundCidrsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNameSecretIdBoundCidrs(string roleName, string mountPath = default(string), ApproleRoleSecretIdBoundCidrsRequest approleRoleSecretIdBoundCidrsRequest = default(ApproleRoleSecretIdBoundCidrsRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdBoundCidrsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdBoundCidrsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, string mountPath = default(string), ApproleRoleSecretIdBoundCidrsRequest approleRoleSecretIdBoundCidrsRequest = default(ApproleRoleSecretIdBoundCidrsRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdBoundCidrsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Invalidate an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdDestroyRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNameSecretIdDestroy(string roleName, string mountPath = default(string), ApproleRoleSecretIdDestroyRequest approleRoleSecretIdDestroyRequest = default(ApproleRoleSecretIdDestroyRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdDestroy");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdDestroyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/secret-id/destroy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdDestroy", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Invalidate an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdDestroyRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameSecretIdDestroyAsync(string roleName, string mountPath = default(string), ApproleRoleSecretIdDestroyRequest approleRoleSecretIdDestroyRequest = default(ApproleRoleSecretIdDestroyRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdDestroy");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdDestroyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id/destroy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdDestroy", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read the properties of an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdLookupRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNameSecretIdLookup(string roleName, string mountPath = default(string), ApproleRoleSecretIdLookupRequest approleRoleSecretIdLookupRequest = default(ApproleRoleSecretIdLookupRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdLookup");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdLookupRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/secret-id/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdLookup", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read the properties of an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdLookupRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameSecretIdLookupAsync(string roleName, string mountPath = default(string), ApproleRoleSecretIdLookupRequest approleRoleSecretIdLookupRequest = default(ApproleRoleSecretIdLookupRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdLookup");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdLookupRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdLookup", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdNumUsesRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNameSecretIdNumUses(string roleName, string mountPath = default(string), ApproleRoleSecretIdNumUsesRequest approleRoleSecretIdNumUsesRequest = default(ApproleRoleSecretIdNumUsesRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdNumUses");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdNumUsesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/secret-id-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdNumUses", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdNumUsesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, string mountPath = default(string), ApproleRoleSecretIdNumUsesRequest approleRoleSecretIdNumUsesRequest = default(ApproleRoleSecretIdNumUsesRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdNumUses");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdNumUsesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdNumUses", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdTtlRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNameSecretIdTtl(string roleName, string mountPath = default(string), ApproleRoleSecretIdTtlRequest approleRoleSecretIdTtlRequest = default(ApproleRoleSecretIdTtlRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdTtlRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/secret-id-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleSecretIdTtlRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameSecretIdTtlAsync(string roleName, string mountPath = default(string), ApproleRoleSecretIdTtlRequest approleRoleSecretIdTtlRequest = default(ApproleRoleSecretIdTtlRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameSecretIdTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdTtlRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/secret-id-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameSecretIdTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleTokenBoundCidrsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNameTokenBoundCidrs(string roleName, string mountPath = default(string), ApproleRoleTokenBoundCidrsRequest approleRoleTokenBoundCidrsRequest = default(ApproleRoleTokenBoundCidrsRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameTokenBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenBoundCidrsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/token-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameTokenBoundCidrs", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleTokenBoundCidrsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, string mountPath = default(string), ApproleRoleTokenBoundCidrsRequest approleRoleTokenBoundCidrsRequest = default(ApproleRoleTokenBoundCidrsRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameTokenBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenBoundCidrsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/token-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameTokenBoundCidrs", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleTokenMaxTtlRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNameTokenMaxTtl(string roleName, string mountPath = default(string), ApproleRoleTokenMaxTtlRequest approleRoleTokenMaxTtlRequest = default(ApproleRoleTokenMaxTtlRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameTokenMaxTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenMaxTtlRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/token-max-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameTokenMaxTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleTokenMaxTtlRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameTokenMaxTtlAsync(string roleName, string mountPath = default(string), ApproleRoleTokenMaxTtlRequest approleRoleTokenMaxTtlRequest = default(ApproleRoleTokenMaxTtlRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameTokenMaxTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenMaxTtlRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/token-max-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameTokenMaxTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleTokenNumUsesRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNameTokenNumUses(string roleName, string mountPath = default(string), ApproleRoleTokenNumUsesRequest approleRoleTokenNumUsesRequest = default(ApproleRoleTokenNumUsesRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameTokenNumUses");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenNumUsesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/token-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameTokenNumUses", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleTokenNumUsesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameTokenNumUsesAsync(string roleName, string mountPath = default(string), ApproleRoleTokenNumUsesRequest approleRoleTokenNumUsesRequest = default(ApproleRoleTokenNumUsesRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameTokenNumUses");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenNumUsesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/token-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameTokenNumUses", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleTokenTtlRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleRoleRoleNameTokenTtl(string roleName, string mountPath = default(string), ApproleRoleTokenTtlRequest approleRoleTokenTtlRequest = default(ApproleRoleTokenTtlRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameTokenTtl");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenTtlRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role_name}/token-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameTokenTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="approleRoleTokenTtlRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleRoleRoleNameTokenTtlAsync(string roleName, string mountPath = default(string), ApproleRoleTokenTtlRequest approleRoleTokenTtlRequest = default(ApproleRoleTokenTtlRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateApproleRoleRoleNameTokenTtl");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenTtlRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role_name}/token-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleRoleRoleNameTokenTtl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Trigger the clean-up of expired SecretID entries. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateApproleTidySecretId(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/tidy/secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleTidySecretId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Trigger the clean-up of expired SecretID entries. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateApproleTidySecretIdAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/tidy/secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateApproleTidySecretId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigCertificateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsConfigCertificateCertName(string certName, string mountPath = default(string), AwsConfigCertificateRequest awsConfigCertificateRequest = default(AwsConfigCertificateRequest))
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->UpdateAwsConfigCertificateCertName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigCertificateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/certificate/{cert_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigCertificateCertName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigCertificateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsConfigCertificateCertNameAsync(string certName, string mountPath = default(string), AwsConfigCertificateRequest awsConfigCertificateRequest = default(AwsConfigCertificateRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->UpdateAwsConfigCertificateCertName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigCertificateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/certificate/{cert_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigCertificateCertName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigClientRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsConfigClient(string mountPath = default(string), AwsConfigClientRequest awsConfigClientRequest = default(AwsConfigClientRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigClientRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/client", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigClient", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigClientRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsConfigClientAsync(string mountPath = default(string), AwsConfigClientRequest awsConfigClientRequest = default(AwsConfigClientRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigClientRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/client", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigClient", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigIdentityRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsConfigIdentity(string mountPath = default(string), AwsConfigIdentityRequest awsConfigIdentityRequest = default(AwsConfigIdentityRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigIdentityRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/identity", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigIdentity", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigIdentityRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsConfigIdentityAsync(string mountPath = default(string), AwsConfigIdentityRequest awsConfigIdentityRequest = default(AwsConfigIdentityRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigIdentityRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/identity", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigIdentity", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsConfigRotateRoot(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigRotateRoot", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsConfigRotateRootAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigRotateRoot", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigStsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsConfigStsAccountId(string accountId, string mountPath = default(string), AwsConfigStsRequest awsConfigStsRequest = default(AwsConfigStsRequest))
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->UpdateAwsConfigStsAccountId");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigStsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/sts/{account_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigStsAccountId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigStsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsConfigStsAccountIdAsync(string accountId, string mountPath = default(string), AwsConfigStsRequest awsConfigStsRequest = default(AwsConfigStsRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->UpdateAwsConfigStsAccountId");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigStsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/sts/{account_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigStsAccountId", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigTidyIdentityAccesslistRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsConfigTidyIdentityAccesslist(string mountPath = default(string), AwsConfigTidyIdentityAccesslistRequest awsConfigTidyIdentityAccesslistRequest = default(AwsConfigTidyIdentityAccesslistRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyIdentityAccesslistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/tidy/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigTidyIdentityAccesslist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigTidyIdentityAccesslistRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsConfigTidyIdentityAccesslistAsync(string mountPath = default(string), AwsConfigTidyIdentityAccesslistRequest awsConfigTidyIdentityAccesslistRequest = default(AwsConfigTidyIdentityAccesslistRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyIdentityAccesslistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/tidy/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigTidyIdentityAccesslist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigTidyIdentityWhitelistRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsConfigTidyIdentityWhitelist(string mountPath = default(string), AwsConfigTidyIdentityWhitelistRequest awsConfigTidyIdentityWhitelistRequest = default(AwsConfigTidyIdentityWhitelistRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyIdentityWhitelistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/tidy/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigTidyIdentityWhitelist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigTidyIdentityWhitelistRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsConfigTidyIdentityWhitelistAsync(string mountPath = default(string), AwsConfigTidyIdentityWhitelistRequest awsConfigTidyIdentityWhitelistRequest = default(AwsConfigTidyIdentityWhitelistRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyIdentityWhitelistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/tidy/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigTidyIdentityWhitelist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigTidyRoletagBlacklistRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsConfigTidyRoletagBlacklist(string mountPath = default(string), AwsConfigTidyRoletagBlacklistRequest awsConfigTidyRoletagBlacklistRequest = default(AwsConfigTidyRoletagBlacklistRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyRoletagBlacklistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/tidy/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigTidyRoletagBlacklist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigTidyRoletagBlacklistRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsConfigTidyRoletagBlacklistAsync(string mountPath = default(string), AwsConfigTidyRoletagBlacklistRequest awsConfigTidyRoletagBlacklistRequest = default(AwsConfigTidyRoletagBlacklistRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyRoletagBlacklistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/tidy/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigTidyRoletagBlacklist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigTidyRoletagDenylistRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsConfigTidyRoletagDenylist(string mountPath = default(string), AwsConfigTidyRoletagDenylistRequest awsConfigTidyRoletagDenylistRequest = default(AwsConfigTidyRoletagDenylistRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyRoletagDenylistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/tidy/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigTidyRoletagDenylist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsConfigTidyRoletagDenylistRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsConfigTidyRoletagDenylistAsync(string mountPath = default(string), AwsConfigTidyRoletagDenylistRequest awsConfigTidyRoletagDenylistRequest = default(AwsConfigTidyRoletagDenylistRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyRoletagDenylistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/tidy/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsConfigTidyRoletagDenylist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsRoleRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsRoleRole(string role, string mountPath = default(string), AwsRoleRequest awsRoleRequest = default(AwsRoleRequest))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->UpdateAwsRoleRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = awsRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsRoleRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsRoleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsRoleRoleAsync(string role, string mountPath = default(string), AwsRoleRequest awsRoleRequest = default(AwsRoleRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->UpdateAwsRoleRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = awsRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsRoleRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsRoleTagRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsRoleRoleTag(string role, string mountPath = default(string), AwsRoleTagRequest awsRoleTagRequest = default(AwsRoleTagRequest))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->UpdateAwsRoleRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = awsRoleTagRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{role}/tag", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsRoleRoleTag", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsRoleTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsRoleRoleTagAsync(string role, string mountPath = default(string), AwsRoleTagRequest awsRoleTagRequest = default(AwsRoleTagRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->UpdateAwsRoleRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = awsRoleTagRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{role}/tag", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsRoleRoleTag", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsRoletagBlacklistRoleTag(string roleTag, string mountPath = default(string))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->UpdateAwsRoletagBlacklistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/roletag-blacklist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsRoletagBlacklistRoleTag", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsRoletagBlacklistRoleTagAsync(string roleTag, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->UpdateAwsRoletagBlacklistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/roletag-blacklist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsRoletagBlacklistRoleTag", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsRoletagDenylistRoleTag(string roleTag, string mountPath = default(string))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->UpdateAwsRoletagDenylistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/roletag-denylist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsRoletagDenylistRoleTag", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsRoletagDenylistRoleTagAsync(string roleTag, string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->UpdateAwsRoletagDenylistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/roletag-denylist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsRoletagDenylistRoleTag", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsTidyIdentityAccesslistRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsTidyIdentityAccesslist(string mountPath = default(string), AwsTidyIdentityAccesslistRequest awsTidyIdentityAccesslistRequest = default(AwsTidyIdentityAccesslistRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsTidyIdentityAccesslistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/tidy/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsTidyIdentityAccesslist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsTidyIdentityAccesslistRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsTidyIdentityAccesslistAsync(string mountPath = default(string), AwsTidyIdentityAccesslistRequest awsTidyIdentityAccesslistRequest = default(AwsTidyIdentityAccesslistRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsTidyIdentityAccesslistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/tidy/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsTidyIdentityAccesslist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsTidyIdentityWhitelistRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsTidyIdentityWhitelist(string mountPath = default(string), AwsTidyIdentityWhitelistRequest awsTidyIdentityWhitelistRequest = default(AwsTidyIdentityWhitelistRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsTidyIdentityWhitelistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/tidy/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsTidyIdentityWhitelist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsTidyIdentityWhitelistRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsTidyIdentityWhitelistAsync(string mountPath = default(string), AwsTidyIdentityWhitelistRequest awsTidyIdentityWhitelistRequest = default(AwsTidyIdentityWhitelistRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsTidyIdentityWhitelistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/tidy/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsTidyIdentityWhitelist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsTidyRoletagBlacklistRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsTidyRoletagBlacklist(string mountPath = default(string), AwsTidyRoletagBlacklistRequest awsTidyRoletagBlacklistRequest = default(AwsTidyRoletagBlacklistRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsTidyRoletagBlacklistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/tidy/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsTidyRoletagBlacklist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsTidyRoletagBlacklistRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsTidyRoletagBlacklistAsync(string mountPath = default(string), AwsTidyRoletagBlacklistRequest awsTidyRoletagBlacklistRequest = default(AwsTidyRoletagBlacklistRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsTidyRoletagBlacklistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/tidy/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsTidyRoletagBlacklist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsTidyRoletagDenylistRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateAwsTidyRoletagDenylist(string mountPath = default(string), AwsTidyRoletagDenylistRequest awsTidyRoletagDenylistRequest = default(AwsTidyRoletagDenylistRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsTidyRoletagDenylistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/tidy/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsTidyRoletagDenylist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="awsTidyRoletagDenylistRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateAwsTidyRoletagDenylistAsync(string mountPath = default(string), AwsTidyRoletagDenylistRequest awsTidyRoletagDenylistRequest = default(AwsTidyRoletagDenylistRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = awsTidyRoletagDenylistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/tidy/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateAwsTidyRoletagDenylist", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="certCertsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateCertCertsName(string name, string mountPath = default(string), CertCertsRequest certCertsRequest = default(CertCertsRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateCertCertsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = certCertsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/certs/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateCertCertsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="certCertsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateCertCertsNameAsync(string name, string mountPath = default(string), CertCertsRequest certCertsRequest = default(CertCertsRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateCertCertsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = certCertsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/certs/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateCertCertsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="certCrlsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateCertCrlsName(string name, string mountPath = default(string), CertCrlsRequest certCrlsRequest = default(CertCrlsRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateCertCrlsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = certCrlsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/crls/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateCertCrlsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="certCrlsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateCertCrlsNameAsync(string name, string mountPath = default(string), CertCrlsRequest certCrlsRequest = default(CertCrlsRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateCertCrlsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = certCrlsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/crls/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateCertCrlsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="cfRolesRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateCfRolesRole(string role, string mountPath = default(string), CfRolesRequest cfRolesRequest = default(CfRolesRequest))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->UpdateCfRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = cfRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateCfRolesRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="cfRolesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateCfRolesRoleAsync(string role, string mountPath = default(string), CfRolesRequest cfRolesRequest = default(CfRolesRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->UpdateCfRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = cfRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateCfRolesRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Add or remove labels for an existing &#39;gce&#39; role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpRoleLabelsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpRoleNameLabels(string name, string mountPath = default(string), GcpRoleLabelsRequest gcpRoleLabelsRequest = default(GcpRoleLabelsRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateGcpRoleNameLabels");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRoleLabelsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{name}/labels", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpRoleNameLabels", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Add or remove labels for an existing &#39;gce&#39; role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpRoleLabelsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpRoleNameLabelsAsync(string name, string mountPath = default(string), GcpRoleLabelsRequest gcpRoleLabelsRequest = default(GcpRoleLabelsRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateGcpRoleNameLabels");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRoleLabelsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{name}/labels", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpRoleNameLabels", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Add or remove service accounts for an existing &#x60;iam&#x60; role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpRoleServiceAccountsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGcpRoleNameServiceAccounts(string name, string mountPath = default(string), GcpRoleServiceAccountsRequest gcpRoleServiceAccountsRequest = default(GcpRoleServiceAccountsRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateGcpRoleNameServiceAccounts");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRoleServiceAccountsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{name}/service-accounts", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpRoleNameServiceAccounts", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Add or remove service accounts for an existing &#x60;iam&#x60; role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="gcpRoleServiceAccountsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGcpRoleNameServiceAccountsAsync(string name, string mountPath = default(string), GcpRoleServiceAccountsRequest gcpRoleServiceAccountsRequest = default(GcpRoleServiceAccountsRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateGcpRoleNameServiceAccounts");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRoleServiceAccountsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{name}/service-accounts", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGcpRoleNameServiceAccounts", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="githubMapTeamsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGithubMapTeamsKey(string key, string mountPath = default(string), GithubMapTeamsRequest githubMapTeamsRequest = default(GithubMapTeamsRequest))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->UpdateGithubMapTeamsKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = githubMapTeamsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/map/teams/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGithubMapTeamsKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="githubMapTeamsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGithubMapTeamsKeyAsync(string key, string mountPath = default(string), GithubMapTeamsRequest githubMapTeamsRequest = default(GithubMapTeamsRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->UpdateGithubMapTeamsKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = githubMapTeamsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/map/teams/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGithubMapTeamsKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="githubMapUsersRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateGithubMapUsersKey(string key, string mountPath = default(string), GithubMapUsersRequest githubMapUsersRequest = default(GithubMapUsersRequest))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->UpdateGithubMapUsersKey");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = githubMapUsersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/map/users/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGithubMapUsersKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="githubMapUsersRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateGithubMapUsersKeyAsync(string key, string mountPath = default(string), GithubMapUsersRequest githubMapUsersRequest = default(GithubMapUsersRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->UpdateGithubMapUsersKey");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = githubMapUsersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/map/users/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGithubMapUsersKey", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="kerberosConfigLdapRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateKerberosConfigLdap(string mountPath = default(string), KerberosConfigLdapRequest kerberosConfigLdapRequest = default(KerberosConfigLdapRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = kerberosConfigLdapRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config/ldap", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateKerberosConfigLdap", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="kerberosConfigLdapRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateKerberosConfigLdapAsync(string mountPath = default(string), KerberosConfigLdapRequest kerberosConfigLdapRequest = default(KerberosConfigLdapRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = kerberosConfigLdapRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config/ldap", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateKerberosConfigLdap", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="kerberosGroupsRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateKerberosGroupsName(string name, string mountPath = default(string), KerberosGroupsRequest kerberosGroupsRequest = default(KerberosGroupsRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateKerberosGroupsName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = kerberosGroupsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateKerberosGroupsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="kerberosGroupsRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateKerberosGroupsNameAsync(string name, string mountPath = default(string), KerberosGroupsRequest kerberosGroupsRequest = default(KerberosGroupsRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateKerberosGroupsName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = kerberosGroupsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateKerberosGroupsName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Authenticates to Vault using OCI credentials 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="ociLoginRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateOciLoginRole(string role, string mountPath = default(string), OciLoginRequest ociLoginRequest = default(OciLoginRequest))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->UpdateOciLoginRole");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = ociLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/login/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateOciLoginRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Authenticates to Vault using OCI credentials 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="ociLoginRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateOciLoginRoleAsync(string role, string mountPath = default(string), OciLoginRequest ociLoginRequest = default(OciLoginRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->UpdateOciLoginRole");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = ociLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/login/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateOciLoginRole", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure the JWT authentication backend. The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcConfigRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateOidcConfig(string mountPath = default(string), OidcConfigRequest oidcConfigRequest = default(OidcConfigRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = oidcConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateOidcConfig", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Configure the JWT authentication backend. The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcConfigRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateOidcConfigAsync(string mountPath = default(string), OidcConfigRequest oidcConfigRequest = default(OidcConfigRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = oidcConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateOidcConfig", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Authenticates to Vault using a JWT (or OIDC) token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcLoginRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateOidcLogin(string mountPath = default(string), OidcLoginRequest oidcLoginRequest = default(OidcLoginRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = oidcLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateOidcLogin", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Authenticates to Vault using a JWT (or OIDC) token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcLoginRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateOidcLoginAsync(string mountPath = default(string), OidcLoginRequest oidcLoginRequest = default(OidcLoginRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = oidcLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateOidcLogin", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Request an authorization URL to start an OIDC login flow. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcOidcAuthUrlRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateOidcOidcAuthUrl(string mountPath = default(string), OidcOidcAuthUrlRequest oidcOidcAuthUrlRequest = default(OidcOidcAuthUrlRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = oidcOidcAuthUrlRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/oidc/auth_url", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateOidcOidcAuthUrl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Request an authorization URL to start an OIDC login flow. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcOidcAuthUrlRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateOidcOidcAuthUrlAsync(string mountPath = default(string), OidcOidcAuthUrlRequest oidcOidcAuthUrlRequest = default(OidcOidcAuthUrlRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = oidcOidcAuthUrlRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/oidc/auth_url", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateOidcOidcAuthUrl", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Callback endpoint to handle form_posts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcOidcCallbackRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateOidcOidcCallback(string mountPath = default(string), OidcOidcCallbackRequest oidcOidcCallbackRequest = default(OidcOidcCallbackRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = oidcOidcCallbackRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/oidc/callback", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateOidcOidcCallback", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Callback endpoint to handle form_posts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcOidcCallbackRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateOidcOidcCallbackAsync(string mountPath = default(string), OidcOidcCallbackRequest oidcOidcCallbackRequest = default(OidcOidcCallbackRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = oidcOidcCallbackRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/oidc/callback", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateOidcOidcCallback", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Register an role with the backend. A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcRoleRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateOidcRoleName(string name, string mountPath = default(string), OidcRoleRequest oidcRoleRequest = default(OidcRoleRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateOidcRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = oidcRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateOidcRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Register an role with the backend. A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="oidcRoleRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateOidcRoleNameAsync(string name, string mountPath = default(string), OidcRoleRequest oidcRoleRequest = default(OidcRoleRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateOidcRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = oidcRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateOidcRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlusername">Username to be used for login. (URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="radiusLoginRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateRadiusLoginUrlusername(string urlusername, string mountPath = default(string), RadiusLoginRequest radiusLoginRequest = default(RadiusLoginRequest))
        {
            // verify the required parameter 'urlusername' is set
            if (urlusername == null)
                throw new VaultApiException(400, "Missing required parameter 'urlusername' when calling Auth->UpdateRadiusLoginUrlusername");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlusername", ClientUtils.ParameterToString(urlusername)); // path parameter
            requestOptions.Data = radiusLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/login/{urlusername}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateRadiusLoginUrlusername", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlusername">Username to be used for login. (URL parameter)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="radiusLoginRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateRadiusLoginUrlusernameAsync(string urlusername, string mountPath = default(string), RadiusLoginRequest radiusLoginRequest = default(RadiusLoginRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'urlusername' is set
            if (urlusername == null)
                throw new VaultApiException(400, "Missing required parameter 'urlusername' when calling Auth->UpdateRadiusLoginUrlusername");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlusername", ClientUtils.ParameterToString(urlusername)); // path parameter
            requestOptions.Data = radiusLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/login/{urlusername}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateRadiusLoginUrlusername", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="radiusUsersRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateRadiusUsersName(string name, string mountPath = default(string), RadiusUsersRequest radiusUsersRequest = default(RadiusUsersRequest))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateRadiusUsersName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = radiusUsersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateRadiusUsersName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="radiusUsersRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateRadiusUsersNameAsync(string name, string mountPath = default(string), RadiusUsersRequest radiusUsersRequest = default(RadiusUsersRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->UpdateRadiusUsersName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = radiusUsersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateRadiusUsersName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// The token create path is used to create new tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="format">Return json formatted output (optional)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenCreateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTokenCreate(string format = default(string), string mountPath = default(string), TokenCreateRequest tokenCreateRequest = default(TokenCreateRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/create", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenCreate", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// The token create path is used to create new tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="format">Return json formatted output (optional)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenCreateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTokenCreateAsync(string format = default(string), string mountPath = default(string), TokenCreateRequest tokenCreateRequest = default(TokenCreateRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/create", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenCreate", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// The token create path is used to create new orphan tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="format">Return json formatted output (optional)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenCreateOrphanRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTokenCreateOrphan(string format = default(string), string mountPath = default(string), TokenCreateOrphanRequest tokenCreateOrphanRequest = default(TokenCreateOrphanRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateOrphanRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/create-orphan", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenCreateOrphan", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// The token create path is used to create new orphan tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="format">Return json formatted output (optional)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenCreateOrphanRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTokenCreateOrphanAsync(string format = default(string), string mountPath = default(string), TokenCreateOrphanRequest tokenCreateOrphanRequest = default(TokenCreateOrphanRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateOrphanRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/create-orphan", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenCreateOrphan", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This token create path is used to create new tokens adhering to the given role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="format">Return json formatted output (optional)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenCreateRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTokenCreateRoleName(string roleName, string format = default(string), string mountPath = default(string), TokenCreateRequest tokenCreateRequest = default(TokenCreateRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateTokenCreateRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/create/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenCreateRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This token create path is used to create new tokens adhering to the given role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="format">Return json formatted output (optional)</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenCreateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTokenCreateRoleNameAsync(string roleName, string format = default(string), string mountPath = default(string), TokenCreateRequest tokenCreateRequest = default(TokenCreateRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateTokenCreateRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/create/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenCreateRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenLookupRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTokenLookup(string mountPath = default(string), TokenLookupRequest tokenLookupRequest = default(TokenLookupRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenLookup", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenLookupRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTokenLookupAsync(string mountPath = default(string), TokenLookupRequest tokenLookupRequest = default(TokenLookupRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenLookup", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenLookupAccessorRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTokenLookupAccessor(string mountPath = default(string), TokenLookupAccessorRequest tokenLookupAccessorRequest = default(TokenLookupAccessorRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupAccessorRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/lookup-accessor", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenLookupAccessor", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenLookupAccessorRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTokenLookupAccessorAsync(string mountPath = default(string), TokenLookupAccessorRequest tokenLookupAccessorRequest = default(TokenLookupAccessorRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupAccessorRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/lookup-accessor", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenLookupAccessor", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenLookupSelfRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTokenLookupSelf(string mountPath = default(string), TokenLookupSelfRequest tokenLookupSelfRequest = default(TokenLookupSelfRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupSelfRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/lookup-self", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenLookupSelf", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenLookupSelfRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTokenLookupSelfAsync(string mountPath = default(string), TokenLookupSelfRequest tokenLookupSelfRequest = default(TokenLookupSelfRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupSelfRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/lookup-self", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenLookupSelf", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will renew the given token and prevent expiration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRenewRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTokenRenew(string mountPath = default(string), TokenRenewRequest tokenRenewRequest = default(TokenRenewRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/renew", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenRenew", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will renew the given token and prevent expiration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRenewRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTokenRenewAsync(string mountPath = default(string), TokenRenewRequest tokenRenewRequest = default(TokenRenewRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/renew", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenRenew", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRenewAccessorRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTokenRenewAccessor(string mountPath = default(string), TokenRenewAccessorRequest tokenRenewAccessorRequest = default(TokenRenewAccessorRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewAccessorRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/renew-accessor", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenRenewAccessor", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRenewAccessorRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTokenRenewAccessorAsync(string mountPath = default(string), TokenRenewAccessorRequest tokenRenewAccessorRequest = default(TokenRenewAccessorRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewAccessorRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/renew-accessor", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenRenewAccessor", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will renew the token used to call it and prevent expiration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRenewSelfRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTokenRenewSelf(string mountPath = default(string), TokenRenewSelfRequest tokenRenewSelfRequest = default(TokenRenewSelfRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewSelfRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/renew-self", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenRenewSelf", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will renew the token used to call it and prevent expiration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRenewSelfRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTokenRenewSelfAsync(string mountPath = default(string), TokenRenewSelfRequest tokenRenewSelfRequest = default(TokenRenewSelfRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewSelfRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/renew-self", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenRenewSelf", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will delete the given token and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRevokeRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTokenRevoke(string mountPath = default(string), TokenRevokeRequest tokenRevokeRequest = default(TokenRevokeRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/revoke", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenRevoke", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will delete the given token and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRevokeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTokenRevokeAsync(string mountPath = default(string), TokenRevokeRequest tokenRevokeRequest = default(TokenRevokeRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/revoke", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenRevoke", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will delete the token associated with the accessor and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRevokeAccessorRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTokenRevokeAccessor(string mountPath = default(string), TokenRevokeAccessorRequest tokenRevokeAccessorRequest = default(TokenRevokeAccessorRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeAccessorRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/revoke-accessor", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenRevokeAccessor", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will delete the token associated with the accessor and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRevokeAccessorRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTokenRevokeAccessorAsync(string mountPath = default(string), TokenRevokeAccessorRequest tokenRevokeAccessorRequest = default(TokenRevokeAccessorRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeAccessorRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/revoke-accessor", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenRevokeAccessor", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will delete the token and orphan its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRevokeOrphanRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTokenRevokeOrphan(string mountPath = default(string), TokenRevokeOrphanRequest tokenRevokeOrphanRequest = default(TokenRevokeOrphanRequest))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeOrphanRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/revoke-orphan", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenRevokeOrphan", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will delete the token and orphan its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRevokeOrphanRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTokenRevokeOrphanAsync(string mountPath = default(string), TokenRevokeOrphanRequest tokenRevokeOrphanRequest = default(TokenRevokeOrphanRequest), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeOrphanRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/revoke-orphan", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenRevokeOrphan", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will delete the token used to call it and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTokenRevokeSelf(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/revoke-self", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenRevokeSelf", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint will delete the token used to call it and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTokenRevokeSelfAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/revoke-self", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenRevokeSelf", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRolesRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTokenRolesRoleName(string roleName, string mountPath = default(string), TokenRolesRequest tokenRolesRequest = default(TokenRolesRequest))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateTokenRolesRoleName");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = tokenRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/roles/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenRolesRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="tokenRolesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTokenRolesRoleNameAsync(string roleName, string mountPath = default(string), TokenRolesRequest tokenRolesRequest = default(TokenRolesRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->UpdateTokenRolesRoleName");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = tokenRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/roles/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenRolesRoleName", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateTokenTidy(string mountPath = default(string))
        {
            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenTidy", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateTokenTidyAsync(string mountPath = default(string), CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateTokenTidy", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username of the user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="userpassLoginRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateUserpassLoginUsername(string username, string mountPath = default(string), UserpassLoginRequest userpassLoginRequest = default(UserpassLoginRequest))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UpdateUserpassLoginUsername");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = userpassLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/login/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateUserpassLoginUsername", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username of the user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="userpassLoginRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateUserpassLoginUsernameAsync(string username, string mountPath = default(string), UserpassLoginRequest userpassLoginRequest = default(UserpassLoginRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UpdateUserpassLoginUsername");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = userpassLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/login/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateUserpassLoginUsername", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="userpassUsersRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateUserpassUsersUsername(string username, string mountPath = default(string), UserpassUsersRequest userpassUsersRequest = default(UserpassUsersRequest))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UpdateUserpassUsersUsername");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = userpassUsersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/users/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateUserpassUsersUsername", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="userpassUsersRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateUserpassUsersUsernameAsync(string username, string mountPath = default(string), UserpassUsersRequest userpassUsersRequest = default(UserpassUsersRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UpdateUserpassUsersUsername");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = userpassUsersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/users/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateUserpassUsersUsername", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Reset user&#39;s password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="userpassUsersPasswordRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateUserpassUsersUsernamePassword(string username, string mountPath = default(string), UserpassUsersPasswordRequest userpassUsersPasswordRequest = default(UserpassUsersPasswordRequest))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UpdateUserpassUsersUsernamePassword");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = userpassUsersPasswordRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/users/{username}/password", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateUserpassUsersUsernamePassword", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Reset user&#39;s password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="userpassUsersPasswordRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateUserpassUsersUsernamePasswordAsync(string username, string mountPath = default(string), UserpassUsersPasswordRequest userpassUsersPasswordRequest = default(UserpassUsersPasswordRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UpdateUserpassUsersUsernamePassword");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = userpassUsersPasswordRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/users/{username}/password", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateUserpassUsersUsernamePassword", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Update the policies associated with the username. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="userpassUsersPoliciesRequest"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateUserpassUsersUsernamePolicies(string username, string mountPath = default(string), UserpassUsersPoliciesRequest userpassUsersPoliciesRequest = default(UserpassUsersPoliciesRequest))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UpdateUserpassUsersUsernamePolicies");

            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = userpassUsersPoliciesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{mount_path}/users/{username}/policies", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateUserpassUsersUsernamePolicies", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }


        /// <summary>
        /// Update the policies associated with the username. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="mountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="userpassUsersPoliciesRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async Task<ApiResponse<Object>> UpdateUserpassUsersUsernamePoliciesAsync(string username, string mountPath = default(string), UserpassUsersPoliciesRequest userpassUsersPoliciesRequest = default(UserpassUsersPoliciesRequest), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->UpdateUserpassUsersUsernamePolicies");


            RequestOptions requestOptions = new RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (mountPath != null)
            {
                requestOptions.PathParameters.Add("mount_path", ClientUtils.ParameterToString(mountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = userpassUsersPoliciesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{mount_path}/users/{username}/policies", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateUserpassUsersUsernamePolicies", response);
                if (_exception != null) throw _exception;
            }

            return response;
        }

    }
}
