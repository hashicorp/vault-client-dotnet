/*
 * HashiCorp Vault API
 *
 * HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.
 *
 * The version of the OpenAPI document: 1.13.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Threading;
using System.Threading.Tasks;
using Vault.Client;
using Vault.Model;

namespace Vault.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuthSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthAlicloudRoleRole(string role, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthApproleRoleRoleName(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthApproleRoleRoleNameBindSecretId(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthApproleRoleRoleNameBoundCidrList(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthApproleRoleRoleNamePeriod(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthApproleRoleRoleNamePolicies(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthApproleRoleRoleNameSecretIdAccessorDestroy(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthApproleRoleRoleNameSecretIdBoundCidrs(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Invalidate an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthApproleRoleRoleNameSecretIdDestroy(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthApproleRoleRoleNameSecretIdNumUses(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthApproleRoleRoleNameSecretIdTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthApproleRoleRoleNameTokenBoundCidrs(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthApproleRoleRoleNameTokenMaxTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthApproleRoleRoleNameTokenNumUses(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthApproleRoleRoleNameTokenTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthAwsConfigCertificateCertName(string certName, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthAwsConfigClient(string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthAwsConfigStsAccountId(string accountId, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthAwsConfigTidyIdentityAccesslist(string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthAwsConfigTidyIdentityWhitelist(string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthAwsConfigTidyRoletagBlacklist(string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthAwsConfigTidyRoletagDenylist(string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthAwsIdentityAccesslistInstanceId(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthAwsIdentityWhitelistInstanceId(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthAwsRoleRole(string role, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthAwsRoletagBlacklistRoleTag(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthAwsRoletagDenylistRoleTag(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthAzureConfig(string azureMountPath = "azure", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthAzureRoleName(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthCertCertsName(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthCertCrlsName(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthCfConfig(string cfMountPath = "cf", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthCfRolesRole(string role, string cfMountPath = "cf", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Create a GCP role with associated policies and required attributes.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthGcpRoleName(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthGithubMapTeamsKey(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthGithubMapUsersKey(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Delete an existing role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthJwtRoleName(string name, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthKerberosGroupsName(string name, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthKubernetesRoleName(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthLdapGroupsName(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthLdapUsersName(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manages the configuration for the Vault Auth Plugin.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthOciConfig(string ociMountPath = "oci", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthOciRoleRole(string role, string ociMountPath = "oci", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Delete an existing role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthOidcRoleName(string name, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthOktaGroupsName(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthOktaUsersName(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthRadiusUsersName(string name, string radiusMountPath = "radius", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthTokenRolesRoleName(string roleName, string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> DeleteAuthUserpassUsersUsername(string username, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAlicloudRole(string list, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAlicloudRoleRole(string role, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAlicloudRoles(string list, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Lists all the roles registered with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthApproleRole(string list, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthApproleRoleRoleName(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthApproleRoleRoleNameBindSecretId(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthApproleRoleRoleNameBoundCidrList(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Enables cluster local secret IDs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthApproleRoleRoleNameLocalSecretIds(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthApproleRoleRoleNamePeriod(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthApproleRoleRoleNamePolicies(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Returns the &#39;role_id&#39; of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthApproleRoleRoleNameRoleId(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Generate a SecretID against this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthApproleRoleRoleNameSecretId(string roleName, string list, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthApproleRoleRoleNameSecretIdBoundCidrs(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthApproleRoleRoleNameSecretIdNumUses(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthApproleRoleRoleNameSecretIdTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthApproleRoleRoleNameTokenBoundCidrs(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthApproleRoleRoleNameTokenMaxTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthApproleRoleRoleNameTokenNumUses(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthApproleRoleRoleNameTokenTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsConfigCertificateCertName(string certName, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsConfigCertificates(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsConfigClient(string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsConfigIdentity(string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsConfigSts(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsConfigStsAccountId(string accountId, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsConfigTidyIdentityAccesslist(string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsConfigTidyIdentityWhitelist(string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsConfigTidyRoletagBlacklist(string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsConfigTidyRoletagDenylist(string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsIdentityAccesslist(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsIdentityAccesslistInstanceId(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsIdentityWhitelist(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsIdentityWhitelistInstanceId(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsRole(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsRoleRole(string role, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsRoles(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsRoletagBlacklist(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsRoletagBlacklistRoleTag(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsRoletagDenylist(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAwsRoletagDenylistRoleTag(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAzureConfig(string azureMountPath = "azure", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAzureRole(string list, string azureMountPath = "azure", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthAzureRoleName(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This path allows you to configure the centrify auth provider to interact with the Centrify Identity Services Platform for authenticating users.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;centrify&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthCentrifyConfig(string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthCertCerts(string list, string certMountPath = "cert", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthCertCertsName(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthCertConfig(string certMountPath = "cert", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthCertCrlsName(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthCfConfig(string cfMountPath = "cf", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthCfRoles(string list, string cfMountPath = "cf", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthCfRolesRole(string role, string cfMountPath = "cf", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Configure credentials used to query the GCP IAM API to verify authenticating service accounts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthGcpConfig(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthGcpRole(string list, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Create a GCP role with associated policies and required attributes.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthGcpRoleName(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthGcpRoles(string list, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthGithubConfig(string githubMountPath = "github", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Read mappings for teams
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthGithubMapTeams(string githubMountPath = "github", string list = "false", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthGithubMapTeamsKey(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Read mappings for users
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthGithubMapUsers(string githubMountPath = "github", string list = "false", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthGithubMapUsersKey(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Read the current JWT authentication backend configuration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthJwtConfig(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Callback endpoint to complete an OIDC login.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthJwtOidcCallback(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Lists all the roles registered with the backend.
        /// </summary>
        /// <remarks>
        /// The list will contain the names of the roles.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthJwtRole(string list, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Read an existing role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthJwtRoleName(string name, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthKerberosConfig(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthKerberosConfigLdap(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthKerberosGroups(string list, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthKerberosGroupsName(string name, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthKerberosLogin(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Configures the JWT Public Key and Kubernetes API information.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthKubernetesConfig(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Lists all the roles registered with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthKubernetesRole(string list, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthKubernetesRoleName(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Configure the LDAP server to connect to, along with its options.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthLdapConfig(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthLdapGroups(string list, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthLdapGroupsName(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthLdapUsers(string list, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthLdapUsersName(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manages the configuration for the Vault Auth Plugin.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthOciConfig(string ociMountPath = "oci", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthOciRole(string list, string ociMountPath = "oci", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthOciRoleRole(string role, string ociMountPath = "oci", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Read the current JWT authentication backend configuration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthOidcConfig(string oidcMountPath = "oidc", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Callback endpoint to complete an OIDC login.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthOidcOidcCallback(string oidcMountPath = "oidc", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Lists all the roles registered with the backend.
        /// </summary>
        /// <remarks>
        /// The list will contain the names of the roles.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthOidcRole(string list, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Read an existing role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthOidcRoleName(string name, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This endpoint allows you to configure the Okta and its configuration options.  The Okta organization are the characters at the front of the URL for Okta. Example https://ORG.okta.com
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthOktaConfig(string oktaMountPath = "okta", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthOktaGroups(string list, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthOktaGroupsName(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthOktaUsers(string list, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthOktaUsersName(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">Nonce provided during a login request to retrieve the number verification challenge for the matching request.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthOktaVerifyNonce(string nonce, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Configure the RADIUS server to connect to, along with its options.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthRadiusConfig(string radiusMountPath = "radius", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthRadiusUsers(string list, string radiusMountPath = "radius", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthRadiusUsersName(string name, string radiusMountPath = "radius", TimeSpan? wrapTTL = null);
        /// <summary>
        /// List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires &#39;sudo&#39; capability in addition to &#39;list&#39;.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthTokenAccessors(string list, string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthTokenLookup(string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthTokenLookupSelf(string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This endpoint lists configured roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthTokenRoles(string list, string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthTokenRolesRoleName(string roleName, string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthUserpassUsers(string list, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> GetAuthUserpassUsersUsername(string username, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Authenticates an RAM entity with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudLoginRequest"></param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAlicloudLogin(AlicloudLoginRequest alicloudLoginRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudRoleRequest"></param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAlicloudRoleRole(string role, AlicloudRoleRequest alicloudRoleRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="approleLoginRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleLogin(ApproleLoginRequest approleLoginRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleName(string roleName, ApproleRoleRequest approleRoleRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleBindSecretIdRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNameBindSecretId(string roleName, ApproleRoleBindSecretIdRequest approleRoleBindSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleBoundCidrListRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNameBoundCidrList(string roleName, ApproleRoleBoundCidrListRequest approleRoleBoundCidrListRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Assign a SecretID of choice against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleCustomSecretIdRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNameCustomSecretId(string roleName, ApproleRoleCustomSecretIdRequest approleRoleCustomSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRolePeriodRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNamePeriod(string roleName, ApproleRolePeriodRequest approleRolePeriodRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRolePoliciesRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNamePolicies(string roleName, ApproleRolePoliciesRequest approleRolePoliciesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Returns the &#39;role_id&#39; of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleRoleIdRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNameRoleId(string roleName, ApproleRoleRoleIdRequest approleRoleRoleIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Generate a SecretID against this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNameSecretId(string roleName, ApproleRoleSecretIdRequest approleRoleSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdAccessorDestroyRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNameSecretIdAccessorDestroy(string roleName, ApproleRoleSecretIdAccessorDestroyRequest approleRoleSecretIdAccessorDestroyRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdAccessorLookupRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNameSecretIdAccessorLookup(string roleName, ApproleRoleSecretIdAccessorLookupRequest approleRoleSecretIdAccessorLookupRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdBoundCidrsRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNameSecretIdBoundCidrs(string roleName, ApproleRoleSecretIdBoundCidrsRequest approleRoleSecretIdBoundCidrsRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Invalidate an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdDestroyRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNameSecretIdDestroy(string roleName, ApproleRoleSecretIdDestroyRequest approleRoleSecretIdDestroyRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Read the properties of an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdLookupRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNameSecretIdLookup(string roleName, ApproleRoleSecretIdLookupRequest approleRoleSecretIdLookupRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdNumUsesRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNameSecretIdNumUses(string roleName, ApproleRoleSecretIdNumUsesRequest approleRoleSecretIdNumUsesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdTtlRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNameSecretIdTtl(string roleName, ApproleRoleSecretIdTtlRequest approleRoleSecretIdTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenBoundCidrsRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNameTokenBoundCidrs(string roleName, ApproleRoleTokenBoundCidrsRequest approleRoleTokenBoundCidrsRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenMaxTtlRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNameTokenMaxTtl(string roleName, ApproleRoleTokenMaxTtlRequest approleRoleTokenMaxTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenNumUsesRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNameTokenNumUses(string roleName, ApproleRoleTokenNumUsesRequest approleRoleTokenNumUsesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenTtlRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleRoleRoleNameTokenTtl(string roleName, ApproleRoleTokenTtlRequest approleRoleTokenTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Trigger the clean-up of expired SecretID entries.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthApproleTidySecretId(string approleMountPath = "approle", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsConfigCertificateRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsConfigCertificateCertName(string certName, AwsConfigCertificateRequest awsConfigCertificateRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigClientRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsConfigClient(AwsConfigClientRequest awsConfigClientRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigIdentityRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsConfigIdentity(AwsConfigIdentityRequest awsConfigIdentityRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsConfigRotateRoot(string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsConfigStsRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsConfigStsAccountId(string accountId, AwsConfigStsRequest awsConfigStsRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyIdentityAccesslistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsConfigTidyIdentityAccesslist(AwsConfigTidyIdentityAccesslistRequest awsConfigTidyIdentityAccesslistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyIdentityWhitelistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsConfigTidyIdentityWhitelist(AwsConfigTidyIdentityWhitelistRequest awsConfigTidyIdentityWhitelistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyRoletagBlacklistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsConfigTidyRoletagBlacklist(AwsConfigTidyRoletagBlacklistRequest awsConfigTidyRoletagBlacklistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyRoletagDenylistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsConfigTidyRoletagDenylist(AwsConfigTidyRoletagDenylistRequest awsConfigTidyRoletagDenylistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsLoginRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsLogin(AwsLoginRequest awsLoginRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsRoleRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsRoleRole(string role, AwsRoleRequest awsRoleRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsRoleTagRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsRoleRoleTag(string role, AwsRoleTagRequest awsRoleTagRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsRoletagBlacklistRoleTag(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsRoletagDenylistRoleTag(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityAccesslistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsTidyIdentityAccesslist(AwsTidyIdentityAccesslistRequest awsTidyIdentityAccesslistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityWhitelistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsTidyIdentityWhitelist(AwsTidyIdentityWhitelistRequest awsTidyIdentityWhitelistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoletagBlacklistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsTidyRoletagBlacklist(AwsTidyRoletagBlacklistRequest awsTidyRoletagBlacklistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoletagDenylistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAwsTidyRoletagDenylist(AwsTidyRoletagDenylistRequest awsTidyRoletagDenylistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureConfigRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAzureConfig(AzureConfigRequest azureConfigRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureLoginRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAzureLogin(AzureLoginRequest azureLoginRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureRoleRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthAzureRoleName(string name, AzureRoleRequest azureRoleRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This path allows you to configure the centrify auth provider to interact with the Centrify Identity Services Platform for authenticating users.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyConfigRequest"></param>
        /// <param name="centrifyMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;centrify&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthCentrifyConfig(CentrifyConfigRequest centrifyConfigRequest, string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyLoginRequest"></param>
        /// <param name="centrifyMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;centrify&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthCentrifyLogin(CentrifyLoginRequest centrifyLoginRequest, string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certCertsRequest"></param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthCertCertsName(string name, CertCertsRequest certCertsRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certConfigRequest"></param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthCertConfig(CertConfigRequest certConfigRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certCrlsRequest"></param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthCertCrlsName(string name, CertCrlsRequest certCrlsRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certLoginRequest"></param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthCertLogin(CertLoginRequest certLoginRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfConfigRequest"></param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthCfConfig(CfConfigRequest cfConfigRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfLoginRequest"></param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthCfLogin(CfLoginRequest cfLoginRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfRolesRequest"></param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthCfRolesRole(string role, CfRolesRequest cfRolesRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Configure credentials used to query the GCP IAM API to verify authenticating service accounts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpConfigRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthGcpConfig(GcpConfigRequest gcpConfigRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpLoginRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthGcpLogin(GcpLoginRequest gcpLoginRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Create a GCP role with associated policies and required attributes.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthGcpRoleName(string name, GcpRoleRequest gcpRoleRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Add or remove labels for an existing &#39;gce&#39; role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleLabelsRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthGcpRoleNameLabels(string name, GcpRoleLabelsRequest gcpRoleLabelsRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Add or remove service accounts for an existing &#x60;iam&#x60; role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleServiceAccountsRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthGcpRoleNameServiceAccounts(string name, GcpRoleServiceAccountsRequest gcpRoleServiceAccountsRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubConfigRequest"></param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthGithubConfig(GithubConfigRequest githubConfigRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubLoginRequest"></param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthGithubLogin(GithubLoginRequest githubLoginRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMapTeamsRequest"></param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthGithubMapTeamsKey(string key, GithubMapTeamsRequest githubMapTeamsRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMapUsersRequest"></param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthGithubMapUsersKey(string key, GithubMapUsersRequest githubMapUsersRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Configure the JWT authentication backend.
        /// </summary>
        /// <remarks>
        /// The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtConfigRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthJwtConfig(JwtConfigRequest jwtConfigRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Authenticates to Vault using a JWT (or OIDC) token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtLoginRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthJwtLogin(JwtLoginRequest jwtLoginRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Request an authorization URL to start an OIDC login flow.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtOidcAuthUrlRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthJwtOidcAuthUrl(JwtOidcAuthUrlRequest jwtOidcAuthUrlRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Callback endpoint to handle form_posts.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtOidcCallbackRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthJwtOidcCallback(JwtOidcCallbackRequest jwtOidcCallbackRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtRoleRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthJwtRoleName(string name, JwtRoleRequest jwtRoleRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigRequest"></param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthKerberosConfig(KerberosConfigRequest kerberosConfigRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigLdapRequest"></param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthKerberosConfigLdap(KerberosConfigLdapRequest kerberosConfigLdapRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosGroupsRequest"></param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthKerberosGroupsName(string name, KerberosGroupsRequest kerberosGroupsRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosLoginRequest"></param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthKerberosLogin(KerberosLoginRequest kerberosLoginRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Configures the JWT Public Key and Kubernetes API information.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthKubernetesConfig(KubernetesConfigRequest kubernetesConfigRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Authenticates Kubernetes service accounts with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesLoginRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthKubernetesLogin(KubernetesLoginRequest kubernetesLoginRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesRoleRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthKubernetesRoleName(string name, KubernetesRoleRequest kubernetesRoleRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Configure the LDAP server to connect to, along with its options.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthLdapConfig(LdapConfigRequest ldapConfigRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapGroupsRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthLdapGroupsName(string name, LdapGroupsRequest ldapGroupsRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">DN (distinguished name) to be used for login.</param>
        /// <param name="ldapLoginRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthLdapLoginUsername(string username, LdapLoginRequest ldapLoginRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapUsersRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthLdapUsersName(string name, LdapUsersRequest ldapUsersRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manages the configuration for the Vault Auth Plugin.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociConfigRequest"></param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthOciConfig(OciConfigRequest ociConfigRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Authenticates to Vault using OCI credentials
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociLoginRequest"></param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthOciLoginRole(string role, OciLoginRequest ociLoginRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociRoleRequest"></param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthOciRoleRole(string role, OciRoleRequest ociRoleRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Configure the JWT authentication backend.
        /// </summary>
        /// <remarks>
        /// The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcConfigRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthOidcConfig(OidcConfigRequest oidcConfigRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Authenticates to Vault using a JWT (or OIDC) token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcLoginRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthOidcLogin(OidcLoginRequest oidcLoginRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Request an authorization URL to start an OIDC login flow.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcOidcAuthUrlRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthOidcOidcAuthUrl(OidcOidcAuthUrlRequest oidcOidcAuthUrlRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Callback endpoint to handle form_posts.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcOidcCallbackRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthOidcOidcCallback(OidcOidcCallbackRequest oidcOidcCallbackRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="oidcRoleRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthOidcRoleName(string name, OidcRoleRequest oidcRoleRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This endpoint allows you to configure the Okta and its configuration options.  The Okta organization are the characters at the front of the URL for Okta. Example https://ORG.okta.com
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaConfigRequest"></param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthOktaConfig(OktaConfigRequest oktaConfigRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaGroupsRequest"></param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthOktaGroupsName(string name, OktaGroupsRequest oktaGroupsRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username to be used for login.</param>
        /// <param name="oktaLoginRequest"></param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthOktaLoginUsername(string username, OktaLoginRequest oktaLoginRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaUsersRequest"></param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthOktaUsersName(string name, OktaUsersRequest oktaUsersRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Configure the RADIUS server to connect to, along with its options.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusConfigRequest"></param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthRadiusConfig(RadiusConfigRequest radiusConfigRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusLoginRequest"></param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthRadiusLogin(RadiusLoginRequest radiusLoginRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlusername">Username to be used for login. (URL parameter)</param>
        /// <param name="radiusLoginRequest"></param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthRadiusLoginUrlusername(string urlusername, RadiusLoginRequest radiusLoginRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusUsersRequest"></param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthRadiusUsersName(string name, RadiusUsersRequest radiusUsersRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null);
        /// <summary>
        /// The token create path is used to create new tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthTokenCreate(TokenCreateRequest tokenCreateRequest, string format = "json", string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// The token create path is used to create new orphan tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateOrphanRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthTokenCreateOrphan(TokenCreateOrphanRequest tokenCreateOrphanRequest, string format = "json", string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This token create path is used to create new tokens adhering to the given role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthTokenCreateRoleName(string roleName, TokenCreateRequest tokenCreateRequest, string format = "json", string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthTokenLookup(TokenLookupRequest tokenLookupRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupAccessorRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthTokenLookupAccessor(TokenLookupAccessorRequest tokenLookupAccessorRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupSelfRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthTokenLookupSelf(TokenLookupSelfRequest tokenLookupSelfRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This endpoint will renew the given token and prevent expiration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthTokenRenew(TokenRenewRequest tokenRenewRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewAccessorRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthTokenRenewAccessor(TokenRenewAccessorRequest tokenRenewAccessorRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This endpoint will renew the token used to call it and prevent expiration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewSelfRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthTokenRenewSelf(TokenRenewSelfRequest tokenRenewSelfRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This endpoint will delete the given token and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthTokenRevoke(TokenRevokeRequest tokenRevokeRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This endpoint will delete the token associated with the accessor and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeAccessorRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthTokenRevokeAccessor(TokenRevokeAccessorRequest tokenRevokeAccessorRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This endpoint will delete the token and orphan its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeOrphanRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthTokenRevokeOrphan(TokenRevokeOrphanRequest tokenRevokeOrphanRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This endpoint will delete the token used to call it and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthTokenRevokeSelf(string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenRolesRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthTokenRolesRoleName(string roleName, TokenRolesRequest tokenRolesRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthTokenTidy(string tokenMountPath = "token", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username of the user.</param>
        /// <param name="userpassLoginRequest"></param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthUserpassLoginUsername(string username, UserpassLoginRequest userpassLoginRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersRequest"></param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthUserpassUsersUsername(string username, UserpassUsersRequest userpassUsersRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Reset user&#39;s password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersPasswordRequest"></param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthUserpassUsersUsernamePassword(string username, UserpassUsersPasswordRequest userpassUsersPasswordRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null);
        /// <summary>
        /// Update the policies associated with the username.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersPoliciesRequest"></param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        VaultResponse<Object> PostAuthUserpassUsersUsernamePolicies(string username, UserpassUsersPoliciesRequest userpassUsersPoliciesRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuthAsync : IApiAccessor
    {
        #region Asynchronous Operations
   
        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthAlicloudRoleRoleAsync(string role, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameBindSecretIdAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameBoundCidrListAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNamePeriodAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNamePoliciesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameSecretIdAccessorDestroyAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Invalidate an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameSecretIdDestroyAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameSecretIdTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameTokenMaxTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameTokenNumUsesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameTokenTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthAwsConfigCertificateCertNameAsync(string certName, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthAwsConfigClientAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthAwsConfigStsAccountIdAsync(string accountId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthAwsConfigTidyIdentityAccesslistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthAwsConfigTidyIdentityWhitelistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthAwsConfigTidyRoletagBlacklistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthAwsConfigTidyRoletagDenylistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthAwsIdentityAccesslistInstanceIdAsync(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthAwsIdentityWhitelistInstanceIdAsync(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthAwsRoleRoleAsync(string role, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthAwsRoletagBlacklistRoleTagAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthAwsRoletagDenylistRoleTagAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthAzureConfigAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthAzureRoleNameAsync(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthCertCertsNameAsync(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthCertCrlsNameAsync(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthCfConfigAsync(string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthCfRolesRoleAsync(string role, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Create a GCP role with associated policies and required attributes.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthGcpRoleNameAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthGithubMapTeamsKeyAsync(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthGithubMapUsersKeyAsync(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete an existing role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthJwtRoleNameAsync(string name, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthKerberosGroupsNameAsync(string name, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthKubernetesRoleNameAsync(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthLdapGroupsNameAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthLdapUsersNameAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manages the configuration for the Vault Auth Plugin.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthOciConfigAsync(string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthOciRoleRoleAsync(string role, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Delete an existing role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthOidcRoleNameAsync(string name, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthOktaGroupsNameAsync(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthOktaUsersNameAsync(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthRadiusUsersNameAsync(string name, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthTokenRolesRoleNameAsync(string roleName, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> DeleteAuthUserpassUsersUsernameAsync(string username, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAlicloudRoleAsync(string list, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAlicloudRoleRoleAsync(string role, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAlicloudRolesAsync(string list, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Lists all the roles registered with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthApproleRoleAsync(string list, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameBindSecretIdAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameBoundCidrListAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Enables cluster local secret IDs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameLocalSecretIdsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthApproleRoleRoleNamePeriodAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthApproleRoleRoleNamePoliciesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the &#39;role_id&#39; of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameRoleIdAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a SecretID against this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameSecretIdAsync(string roleName, string list, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameSecretIdTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameTokenMaxTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameTokenNumUsesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameTokenTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsConfigCertificateCertNameAsync(string certName, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsConfigCertificatesAsync(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsConfigClientAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsConfigIdentityAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsConfigStsAsync(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsConfigStsAccountIdAsync(string accountId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsConfigTidyIdentityAccesslistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsConfigTidyIdentityWhitelistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsConfigTidyRoletagBlacklistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsConfigTidyRoletagDenylistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsIdentityAccesslistAsync(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsIdentityAccesslistInstanceIdAsync(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsIdentityWhitelistAsync(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsIdentityWhitelistInstanceIdAsync(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsRoleAsync(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsRoleRoleAsync(string role, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsRolesAsync(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsRoletagBlacklistAsync(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsRoletagBlacklistRoleTagAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsRoletagDenylistAsync(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAwsRoletagDenylistRoleTagAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAzureConfigAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAzureRoleAsync(string list, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthAzureRoleNameAsync(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This path allows you to configure the centrify auth provider to interact with the Centrify Identity Services Platform for authenticating users.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;centrify&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthCentrifyConfigAsync(string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthCertCertsAsync(string list, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthCertCertsNameAsync(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthCertConfigAsync(string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthCertCrlsNameAsync(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthCfConfigAsync(string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthCfRolesAsync(string list, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthCfRolesRoleAsync(string role, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure credentials used to query the GCP IAM API to verify authenticating service accounts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthGcpConfigAsync(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthGcpRoleAsync(string list, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Create a GCP role with associated policies and required attributes.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthGcpRoleNameAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthGcpRolesAsync(string list, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthGithubConfigAsync(string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read mappings for teams
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthGithubMapTeamsAsync(string githubMountPath = "github", string list = "false", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthGithubMapTeamsKeyAsync(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read mappings for users
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthGithubMapUsersAsync(string githubMountPath = "github", string list = "false", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthGithubMapUsersKeyAsync(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the current JWT authentication backend configuration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthJwtConfigAsync(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Callback endpoint to complete an OIDC login.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthJwtOidcCallbackAsync(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Lists all the roles registered with the backend.
        /// </summary>
        /// <remarks>
        /// The list will contain the names of the roles.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthJwtRoleAsync(string list, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read an existing role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthJwtRoleNameAsync(string name, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthKerberosConfigAsync(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthKerberosConfigLdapAsync(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthKerberosGroupsAsync(string list, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthKerberosGroupsNameAsync(string name, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthKerberosLoginAsync(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configures the JWT Public Key and Kubernetes API information.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthKubernetesConfigAsync(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Lists all the roles registered with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthKubernetesRoleAsync(string list, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthKubernetesRoleNameAsync(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the LDAP server to connect to, along with its options.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthLdapConfigAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthLdapGroupsAsync(string list, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthLdapGroupsNameAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthLdapUsersAsync(string list, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthLdapUsersNameAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manages the configuration for the Vault Auth Plugin.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthOciConfigAsync(string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Lists all the roles that are registered with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthOciRoleAsync(string list, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthOciRoleRoleAsync(string role, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the current JWT authentication backend configuration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthOidcConfigAsync(string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Callback endpoint to complete an OIDC login.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthOidcOidcCallbackAsync(string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Lists all the roles registered with the backend.
        /// </summary>
        /// <remarks>
        /// The list will contain the names of the roles.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthOidcRoleAsync(string list, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read an existing role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthOidcRoleNameAsync(string name, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint allows you to configure the Okta and its configuration options.  The Okta organization are the characters at the front of the URL for Okta. Example https://ORG.okta.com
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthOktaConfigAsync(string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthOktaGroupsAsync(string list, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthOktaGroupsNameAsync(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthOktaUsersAsync(string list, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthOktaUsersNameAsync(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">Nonce provided during a login request to retrieve the number verification challenge for the matching request.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthOktaVerifyNonceAsync(string nonce, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the RADIUS server to connect to, along with its options.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthRadiusConfigAsync(string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthRadiusUsersAsync(string list, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthRadiusUsersNameAsync(string name, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires &#39;sudo&#39; capability in addition to &#39;list&#39;.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthTokenAccessorsAsync(string list, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthTokenLookupAsync(string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthTokenLookupSelfAsync(string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint lists configured roles.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthTokenRolesAsync(string list, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthTokenRolesRoleNameAsync(string roleName, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthUserpassUsersAsync(string list, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> GetAuthUserpassUsersUsernameAsync(string username, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Authenticates an RAM entity with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudLoginRequest"></param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAlicloudLoginAsync(AlicloudLoginRequest alicloudLoginRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudRoleRequest"></param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAlicloudRoleRoleAsync(string role, AlicloudRoleRequest alicloudRoleRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="approleLoginRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleLoginAsync(ApproleLoginRequest approleLoginRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameAsync(string roleName, ApproleRoleRequest approleRoleRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Impose secret_id to be presented during login using this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleBindSecretIdRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameBindSecretIdAsync(string roleName, ApproleRoleBindSecretIdRequest approleRoleBindSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleBoundCidrListRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameBoundCidrListAsync(string roleName, ApproleRoleBoundCidrListRequest approleRoleBoundCidrListRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Assign a SecretID of choice against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleCustomSecretIdRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameCustomSecretIdAsync(string roleName, ApproleRoleCustomSecretIdRequest approleRoleCustomSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Updates the value of &#39;period&#39; on the role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRolePeriodRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNamePeriodAsync(string roleName, ApproleRolePeriodRequest approleRolePeriodRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Policies of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRolePoliciesRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNamePoliciesAsync(string roleName, ApproleRolePoliciesRequest approleRolePoliciesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Returns the &#39;role_id&#39; of the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleRoleIdRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameRoleIdAsync(string roleName, ApproleRoleRoleIdRequest approleRoleRoleIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Generate a SecretID against this role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameSecretIdAsync(string roleName, ApproleRoleSecretIdRequest approleRoleSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdAccessorDestroyRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameSecretIdAccessorDestroyAsync(string roleName, ApproleRoleSecretIdAccessorDestroyRequest approleRoleSecretIdAccessorDestroyRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdAccessorLookupRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameSecretIdAccessorLookupAsync(string roleName, ApproleRoleSecretIdAccessorLookupRequest approleRoleSecretIdAccessorLookupRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdBoundCidrsRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, ApproleRoleSecretIdBoundCidrsRequest approleRoleSecretIdBoundCidrsRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Invalidate an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdDestroyRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameSecretIdDestroyAsync(string roleName, ApproleRoleSecretIdDestroyRequest approleRoleSecretIdDestroyRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read the properties of an issued secret_id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdLookupRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameSecretIdLookupAsync(string roleName, ApproleRoleSecretIdLookupRequest approleRoleSecretIdLookupRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Use limit of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdNumUsesRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, ApproleRoleSecretIdNumUsesRequest approleRoleSecretIdNumUsesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds of the SecretID generated against the role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdTtlRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameSecretIdTtlAsync(string roleName, ApproleRoleSecretIdTtlRequest approleRoleSecretIdTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenBoundCidrsRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, ApproleRoleTokenBoundCidrsRequest approleRoleTokenBoundCidrsRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenMaxTtlRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameTokenMaxTtlAsync(string roleName, ApproleRoleTokenMaxTtlRequest approleRoleTokenMaxTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Number of times issued tokens can be used
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenNumUsesRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameTokenNumUsesAsync(string roleName, ApproleRoleTokenNumUsesRequest approleRoleTokenNumUsesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenTtlRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameTokenTtlAsync(string roleName, ApproleRoleTokenTtlRequest approleRoleTokenTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Trigger the clean-up of expired SecretID entries.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthApproleTidySecretIdAsync(string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsConfigCertificateRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsConfigCertificateCertNameAsync(string certName, AwsConfigCertificateRequest awsConfigCertificateRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigClientRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsConfigClientAsync(AwsConfigClientRequest awsConfigClientRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigIdentityRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsConfigIdentityAsync(AwsConfigIdentityRequest awsConfigIdentityRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsConfigRotateRootAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsConfigStsRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsConfigStsAccountIdAsync(string accountId, AwsConfigStsRequest awsConfigStsRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyIdentityAccesslistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsConfigTidyIdentityAccesslistAsync(AwsConfigTidyIdentityAccesslistRequest awsConfigTidyIdentityAccesslistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyIdentityWhitelistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsConfigTidyIdentityWhitelistAsync(AwsConfigTidyIdentityWhitelistRequest awsConfigTidyIdentityWhitelistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyRoletagBlacklistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsConfigTidyRoletagBlacklistAsync(AwsConfigTidyRoletagBlacklistRequest awsConfigTidyRoletagBlacklistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyRoletagDenylistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsConfigTidyRoletagDenylistAsync(AwsConfigTidyRoletagDenylistRequest awsConfigTidyRoletagDenylistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsLoginRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsLoginAsync(AwsLoginRequest awsLoginRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsRoleRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsRoleRoleAsync(string role, AwsRoleRequest awsRoleRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsRoleTagRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsRoleRoleTagAsync(string role, AwsRoleTagRequest awsRoleTagRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsRoletagBlacklistRoleTagAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsRoletagDenylistRoleTagAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityAccesslistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsTidyIdentityAccesslistAsync(AwsTidyIdentityAccesslistRequest awsTidyIdentityAccesslistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityWhitelistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsTidyIdentityWhitelistAsync(AwsTidyIdentityWhitelistRequest awsTidyIdentityWhitelistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoletagBlacklistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsTidyRoletagBlacklistAsync(AwsTidyRoletagBlacklistRequest awsTidyRoletagBlacklistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoletagDenylistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAwsTidyRoletagDenylistAsync(AwsTidyRoletagDenylistRequest awsTidyRoletagDenylistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureConfigRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAzureConfigAsync(AzureConfigRequest azureConfigRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureLoginRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAzureLoginAsync(AzureLoginRequest azureLoginRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureRoleRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthAzureRoleNameAsync(string name, AzureRoleRequest azureRoleRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This path allows you to configure the centrify auth provider to interact with the Centrify Identity Services Platform for authenticating users.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyConfigRequest"></param>
        /// <param name="centrifyMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;centrify&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthCentrifyConfigAsync(CentrifyConfigRequest centrifyConfigRequest, string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyLoginRequest"></param>
        /// <param name="centrifyMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;centrify&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthCentrifyLoginAsync(CentrifyLoginRequest centrifyLoginRequest, string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage trusted certificates used for authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certCertsRequest"></param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthCertCertsNameAsync(string name, CertCertsRequest certCertsRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certConfigRequest"></param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthCertConfigAsync(CertConfigRequest certConfigRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certCrlsRequest"></param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthCertCrlsNameAsync(string name, CertCrlsRequest certCrlsRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certLoginRequest"></param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthCertLoginAsync(CertLoginRequest certLoginRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfConfigRequest"></param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthCfConfigAsync(CfConfigRequest cfConfigRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfLoginRequest"></param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthCfLoginAsync(CfLoginRequest cfLoginRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfRolesRequest"></param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthCfRolesRoleAsync(string role, CfRolesRequest cfRolesRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure credentials used to query the GCP IAM API to verify authenticating service accounts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpConfigRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthGcpConfigAsync(GcpConfigRequest gcpConfigRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpLoginRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthGcpLoginAsync(GcpLoginRequest gcpLoginRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Create a GCP role with associated policies and required attributes.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthGcpRoleNameAsync(string name, GcpRoleRequest gcpRoleRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Add or remove labels for an existing &#39;gce&#39; role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleLabelsRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthGcpRoleNameLabelsAsync(string name, GcpRoleLabelsRequest gcpRoleLabelsRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Add or remove service accounts for an existing &#x60;iam&#x60; role
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleServiceAccountsRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthGcpRoleNameServiceAccountsAsync(string name, GcpRoleServiceAccountsRequest gcpRoleServiceAccountsRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubConfigRequest"></param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthGithubConfigAsync(GithubConfigRequest githubConfigRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubLoginRequest"></param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthGithubLoginAsync(GithubLoginRequest githubLoginRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single teams mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMapTeamsRequest"></param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthGithubMapTeamsKeyAsync(string key, GithubMapTeamsRequest githubMapTeamsRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Read/write/delete a single users mapping
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMapUsersRequest"></param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthGithubMapUsersKeyAsync(string key, GithubMapUsersRequest githubMapUsersRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the JWT authentication backend.
        /// </summary>
        /// <remarks>
        /// The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtConfigRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthJwtConfigAsync(JwtConfigRequest jwtConfigRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Authenticates to Vault using a JWT (or OIDC) token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtLoginRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthJwtLoginAsync(JwtLoginRequest jwtLoginRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Request an authorization URL to start an OIDC login flow.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtOidcAuthUrlRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthJwtOidcAuthUrlAsync(JwtOidcAuthUrlRequest jwtOidcAuthUrlRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Callback endpoint to handle form_posts.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtOidcCallbackRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthJwtOidcCallbackAsync(JwtOidcCallbackRequest jwtOidcCallbackRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtRoleRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthJwtRoleNameAsync(string name, JwtRoleRequest jwtRoleRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigRequest"></param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthKerberosConfigAsync(KerberosConfigRequest kerberosConfigRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigLdapRequest"></param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthKerberosConfigLdapAsync(KerberosConfigLdapRequest kerberosConfigLdapRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosGroupsRequest"></param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthKerberosGroupsNameAsync(string name, KerberosGroupsRequest kerberosGroupsRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosLoginRequest"></param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthKerberosLoginAsync(KerberosLoginRequest kerberosLoginRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configures the JWT Public Key and Kubernetes API information.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthKubernetesConfigAsync(KubernetesConfigRequest kubernetesConfigRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Authenticates Kubernetes service accounts with Vault.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesLoginRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthKubernetesLoginAsync(KubernetesLoginRequest kubernetesLoginRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesRoleRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthKubernetesRoleNameAsync(string name, KubernetesRoleRequest kubernetesRoleRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the LDAP server to connect to, along with its options.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthLdapConfigAsync(LdapConfigRequest ldapConfigRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapGroupsRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthLdapGroupsNameAsync(string name, LdapGroupsRequest ldapGroupsRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">DN (distinguished name) to be used for login.</param>
        /// <param name="ldapLoginRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthLdapLoginUsernameAsync(string username, LdapLoginRequest ldapLoginRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapUsersRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthLdapUsersNameAsync(string name, LdapUsersRequest ldapUsersRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manages the configuration for the Vault Auth Plugin.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociConfigRequest"></param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthOciConfigAsync(OciConfigRequest ociConfigRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Authenticates to Vault using OCI credentials
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociLoginRequest"></param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthOciLoginRoleAsync(string role, OciLoginRequest ociLoginRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Create a role and associate policies to it.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociRoleRequest"></param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthOciRoleRoleAsync(string role, OciRoleRequest ociRoleRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the JWT authentication backend.
        /// </summary>
        /// <remarks>
        /// The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcConfigRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthOidcConfigAsync(OidcConfigRequest oidcConfigRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Authenticates to Vault using a JWT (or OIDC) token.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcLoginRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthOidcLoginAsync(OidcLoginRequest oidcLoginRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Request an authorization URL to start an OIDC login flow.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcOidcAuthUrlRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthOidcOidcAuthUrlAsync(OidcOidcAuthUrlRequest oidcOidcAuthUrlRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Callback endpoint to handle form_posts.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcOidcCallbackRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthOidcOidcCallbackAsync(OidcOidcCallbackRequest oidcOidcCallbackRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Register an role with the backend.
        /// </summary>
        /// <remarks>
        /// A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="oidcRoleRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthOidcRoleNameAsync(string name, OidcRoleRequest oidcRoleRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint allows you to configure the Okta and its configuration options.  The Okta organization are the characters at the front of the URL for Okta. Example https://ORG.okta.com
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaConfigRequest"></param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthOktaConfigAsync(OktaConfigRequest oktaConfigRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaGroupsRequest"></param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthOktaGroupsNameAsync(string name, OktaGroupsRequest oktaGroupsRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username to be used for login.</param>
        /// <param name="oktaLoginRequest"></param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthOktaLoginUsernameAsync(string username, OktaLoginRequest oktaLoginRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage additional groups for users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaUsersRequest"></param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthOktaUsersNameAsync(string name, OktaUsersRequest oktaUsersRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Configure the RADIUS server to connect to, along with its options.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusConfigRequest"></param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthRadiusConfigAsync(RadiusConfigRequest radiusConfigRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusLoginRequest"></param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthRadiusLoginAsync(RadiusLoginRequest radiusLoginRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlusername">Username to be used for login. (URL parameter)</param>
        /// <param name="radiusLoginRequest"></param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthRadiusLoginUrlusernameAsync(string urlusername, RadiusLoginRequest radiusLoginRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusUsersRequest"></param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthRadiusUsersNameAsync(string name, RadiusUsersRequest radiusUsersRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// The token create path is used to create new tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthTokenCreateAsync(TokenCreateRequest tokenCreateRequest, string format = "json", string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// The token create path is used to create new orphan tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateOrphanRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthTokenCreateOrphanAsync(TokenCreateOrphanRequest tokenCreateOrphanRequest, string format = "json", string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This token create path is used to create new tokens adhering to the given role.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthTokenCreateRoleNameAsync(string roleName, TokenCreateRequest tokenCreateRequest, string format = "json", string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthTokenLookupAsync(TokenLookupRequest tokenLookupRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupAccessorRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthTokenLookupAccessorAsync(TokenLookupAccessorRequest tokenLookupAccessorRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will lookup a token and its properties.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupSelfRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthTokenLookupSelfAsync(TokenLookupSelfRequest tokenLookupSelfRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will renew the given token and prevent expiration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthTokenRenewAsync(TokenRenewRequest tokenRenewRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewAccessorRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthTokenRenewAccessorAsync(TokenRenewAccessorRequest tokenRenewAccessorRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will renew the token used to call it and prevent expiration.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewSelfRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthTokenRenewSelfAsync(TokenRenewSelfRequest tokenRenewSelfRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will delete the given token and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthTokenRevokeAsync(TokenRevokeRequest tokenRevokeRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will delete the token associated with the accessor and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeAccessorRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthTokenRevokeAccessorAsync(TokenRevokeAccessorRequest tokenRevokeAccessorRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will delete the token and orphan its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeOrphanRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthTokenRevokeOrphanAsync(TokenRevokeOrphanRequest tokenRevokeOrphanRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint will delete the token used to call it and all of its child tokens.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthTokenRevokeSelfAsync(string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenRolesRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthTokenRolesRoleNameAsync(string roleName, TokenRolesRequest tokenRolesRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthTokenTidyAsync(string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Log in with a username and password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username of the user.</param>
        /// <param name="userpassLoginRequest"></param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthUserpassLoginUsernameAsync(string username, UserpassLoginRequest userpassLoginRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Manage users allowed to authenticate.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersRequest"></param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthUserpassUsersUsernameAsync(string username, UserpassUsersRequest userpassUsersRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Reset user&#39;s password.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersPasswordRequest"></param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthUserpassUsersUsernamePasswordAsync(string username, UserpassUsersPasswordRequest userpassUsersPasswordRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
   
        /// <summary>
        /// Update the policies associated with the username.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersPoliciesRequest"></param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        Task<VaultResponse<Object>> PostAuthUserpassUsersUsernamePoliciesAsync(string username, UserpassUsersPoliciesRequest userpassUsersPoliciesRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAuth : IAuthSync, IAuthAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class Auth : IAuth
    {
        private Vault.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Constructor for Auth
        /// </summary>
        public Auth(ApiClient apiClient)
        {
            if (apiClient == null) throw new ArgumentNullException("ApiClient");
            
            this.Configuration = apiClient.Configuration;
            this.Client = apiClient;
            this.AsynchronousClient = apiClient;
            this.ExceptionFactory = VaultConfiguration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Vault.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Vault.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public VaultConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Vault.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthAlicloudRoleRole(string role, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->DeleteAuthAlicloudRoleRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{alicloud_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAlicloudRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthAlicloudRoleRoleAsync(string role, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->DeleteAuthAlicloudRoleRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{alicloud_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAlicloudRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthApproleRoleRoleName(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthApproleRoleRoleNameBindSecretId(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameBindSecretId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameBindSecretIdAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameBindSecretId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthApproleRoleRoleNameBoundCidrList(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameBoundCidrList");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameBoundCidrListAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameBoundCidrList");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthApproleRoleRoleNamePeriod(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNamePeriod");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/period", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNamePeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNamePeriodAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNamePeriod");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/period", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNamePeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthApproleRoleRoleNamePolicies(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNamePolicies");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/policies", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNamePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNamePoliciesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNamePolicies");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/policies", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNamePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthApproleRoleRoleNameSecretIdAccessorDestroy(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameSecretIdAccessorDestroy");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameSecretIdAccessorDestroy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameSecretIdAccessorDestroyAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameSecretIdAccessorDestroy");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameSecretIdAccessorDestroy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthApproleRoleRoleNameSecretIdBoundCidrs(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameSecretIdBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameSecretIdBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Invalidate an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthApproleRoleRoleNameSecretIdDestroy(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameSecretIdDestroy");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id/destroy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameSecretIdDestroy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Invalidate an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameSecretIdDestroyAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameSecretIdDestroy");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id/destroy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameSecretIdDestroy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthApproleRoleRoleNameSecretIdNumUses(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameSecretIdNumUses");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameSecretIdNumUses");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthApproleRoleRoleNameSecretIdTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameSecretIdTtl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameSecretIdTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameSecretIdTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthApproleRoleRoleNameTokenBoundCidrs(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameTokenBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameTokenBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthApproleRoleRoleNameTokenMaxTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameTokenMaxTtl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameTokenMaxTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameTokenMaxTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthApproleRoleRoleNameTokenNumUses(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameTokenNumUses");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/token-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameTokenNumUsesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameTokenNumUses");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthApproleRoleRoleNameTokenTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameTokenTtl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{approle_mount_path}/role/{role_name}/token-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthApproleRoleRoleNameTokenTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthApproleRoleRoleNameTokenTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthApproleRoleRoleNameTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthAwsConfigCertificateCertName(string certName, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->DeleteAuthAwsConfigCertificateCertName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/config/certificate/{cert_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsConfigCertificateCertName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthAwsConfigCertificateCertNameAsync(string certName, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->DeleteAuthAwsConfigCertificateCertName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/config/certificate/{cert_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsConfigCertificateCertName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthAwsConfigClient(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/config/client", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsConfigClient", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthAwsConfigClientAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/config/client", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsConfigClient", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthAwsConfigStsAccountId(string accountId, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->DeleteAuthAwsConfigStsAccountId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/config/sts/{account_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsConfigStsAccountId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthAwsConfigStsAccountIdAsync(string accountId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->DeleteAuthAwsConfigStsAccountId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/config/sts/{account_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsConfigStsAccountId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthAwsConfigTidyIdentityAccesslist(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/config/tidy/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsConfigTidyIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthAwsConfigTidyIdentityAccesslistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/config/tidy/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsConfigTidyIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthAwsConfigTidyIdentityWhitelist(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/config/tidy/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsConfigTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthAwsConfigTidyIdentityWhitelistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/config/tidy/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsConfigTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthAwsConfigTidyRoletagBlacklist(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/config/tidy/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsConfigTidyRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthAwsConfigTidyRoletagBlacklistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/config/tidy/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsConfigTidyRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthAwsConfigTidyRoletagDenylist(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/config/tidy/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsConfigTidyRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthAwsConfigTidyRoletagDenylistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/config/tidy/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsConfigTidyRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthAwsIdentityAccesslistInstanceId(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->DeleteAuthAwsIdentityAccesslistInstanceId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/identity-accesslist/{instance_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsIdentityAccesslistInstanceId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthAwsIdentityAccesslistInstanceIdAsync(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->DeleteAuthAwsIdentityAccesslistInstanceId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/identity-accesslist/{instance_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsIdentityAccesslistInstanceId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthAwsIdentityWhitelistInstanceId(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->DeleteAuthAwsIdentityWhitelistInstanceId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/identity-whitelist/{instance_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsIdentityWhitelistInstanceId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthAwsIdentityWhitelistInstanceIdAsync(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->DeleteAuthAwsIdentityWhitelistInstanceId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/identity-whitelist/{instance_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsIdentityWhitelistInstanceId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthAwsRoleRole(string role, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->DeleteAuthAwsRoleRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthAwsRoleRoleAsync(string role, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->DeleteAuthAwsRoleRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthAwsRoletagBlacklistRoleTag(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->DeleteAuthAwsRoletagBlacklistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/roletag-blacklist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsRoletagBlacklistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthAwsRoletagBlacklistRoleTagAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->DeleteAuthAwsRoletagBlacklistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/roletag-blacklist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsRoletagBlacklistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthAwsRoletagDenylistRoleTag(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->DeleteAuthAwsRoletagDenylistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{aws_mount_path}/roletag-denylist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsRoletagDenylistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthAwsRoletagDenylistRoleTagAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->DeleteAuthAwsRoletagDenylistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{aws_mount_path}/roletag-denylist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAwsRoletagDenylistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthAzureConfig(string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{azure_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAzureConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthAzureConfigAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{azure_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAzureConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthAzureRoleName(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthAzureRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{azure_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAzureRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthAzureRoleNameAsync(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthAzureRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{azure_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthAzureRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthCertCertsName(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthCertCertsName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{cert_mount_path}/certs/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthCertCertsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthCertCertsNameAsync(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthCertCertsName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{cert_mount_path}/certs/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthCertCertsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthCertCrlsName(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthCertCrlsName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{cert_mount_path}/crls/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthCertCrlsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthCertCrlsNameAsync(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthCertCrlsName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{cert_mount_path}/crls/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthCertCrlsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthCfConfig(string cfMountPath = "cf", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cfMountPath != null)
            {
                requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{cf_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthCfConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthCfConfigAsync(string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cfMountPath != null)
            {
                requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{cf_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthCfConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthCfRolesRole(string role, string cfMountPath = "cf", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->DeleteAuthCfRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cfMountPath != null)
            {
                requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{cf_mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthCfRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthCfRolesRoleAsync(string role, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->DeleteAuthCfRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cfMountPath != null)
            {
                requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{cf_mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthCfRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a GCP role with associated policies and required attributes. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthGcpRoleName(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthGcpRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{gcp_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthGcpRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a GCP role with associated policies and required attributes. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthGcpRoleNameAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthGcpRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{gcp_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthGcpRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthGithubMapTeamsKey(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->DeleteAuthGithubMapTeamsKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{github_mount_path}/map/teams/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthGithubMapTeamsKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthGithubMapTeamsKeyAsync(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->DeleteAuthGithubMapTeamsKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{github_mount_path}/map/teams/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthGithubMapTeamsKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthGithubMapUsersKey(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->DeleteAuthGithubMapUsersKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{github_mount_path}/map/users/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthGithubMapUsersKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthGithubMapUsersKeyAsync(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->DeleteAuthGithubMapUsersKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{github_mount_path}/map/users/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthGithubMapUsersKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete an existing role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthJwtRoleName(string name, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthJwtRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{jwt_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthJwtRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete an existing role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthJwtRoleNameAsync(string name, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthJwtRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{jwt_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthJwtRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthKerberosGroupsName(string name, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthKerberosGroupsName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{kerberos_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthKerberosGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthKerberosGroupsNameAsync(string name, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthKerberosGroupsName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{kerberos_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthKerberosGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthKubernetesRoleName(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthKubernetesRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{kubernetes_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthKubernetesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthKubernetesRoleNameAsync(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthKubernetesRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{kubernetes_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthKubernetesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthLdapGroupsName(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthLdapGroupsName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{ldap_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthLdapGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthLdapGroupsNameAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthLdapGroupsName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{ldap_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthLdapGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthLdapUsersName(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthLdapUsersName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{ldap_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthLdapUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthLdapUsersNameAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthLdapUsersName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{ldap_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthLdapUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manages the configuration for the Vault Auth Plugin. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthOciConfig(string ociMountPath = "oci", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ociMountPath != null)
            {
                requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{oci_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthOciConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manages the configuration for the Vault Auth Plugin. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthOciConfigAsync(string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ociMountPath != null)
            {
                requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{oci_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthOciConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthOciRoleRole(string role, string ociMountPath = "oci", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->DeleteAuthOciRoleRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ociMountPath != null)
            {
                requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{oci_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthOciRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthOciRoleRoleAsync(string role, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->DeleteAuthOciRoleRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ociMountPath != null)
            {
                requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{oci_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthOciRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete an existing role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthOidcRoleName(string name, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthOidcRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{oidc_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthOidcRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Delete an existing role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthOidcRoleNameAsync(string name, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthOidcRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{oidc_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthOidcRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthOktaGroupsName(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthOktaGroupsName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{okta_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthOktaGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthOktaGroupsNameAsync(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthOktaGroupsName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{okta_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthOktaGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthOktaUsersName(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthOktaUsersName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{okta_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthOktaUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthOktaUsersNameAsync(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthOktaUsersName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{okta_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthOktaUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthRadiusUsersName(string name, string radiusMountPath = "radius", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthRadiusUsersName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (radiusMountPath != null)
            {
                requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{radius_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthRadiusUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthRadiusUsersNameAsync(string name, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->DeleteAuthRadiusUsersName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (radiusMountPath != null)
            {
                requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{radius_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthRadiusUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthTokenRolesRoleName(string roleName, string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthTokenRolesRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{token_mount_path}/roles/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthTokenRolesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthTokenRolesRoleNameAsync(string roleName, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->DeleteAuthTokenRolesRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{token_mount_path}/roles/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthTokenRolesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> DeleteAuthUserpassUsersUsername(string username, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->DeleteAuthUserpassUsersUsername");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            if (userpassMountPath != null)
            {
                requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Delete<Object>("/auth/{userpass_mount_path}/users/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthUserpassUsersUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> DeleteAuthUserpassUsersUsernameAsync(string username, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->DeleteAuthUserpassUsersUsername");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            if (userpassMountPath != null)
            {
                requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.DeleteAsync<Object>("/auth/{userpass_mount_path}/users/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("DeleteAuthUserpassUsersUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAlicloudRole(string list, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAlicloudRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{alicloud_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAlicloudRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAlicloudRoleAsync(string list, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAlicloudRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{alicloud_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAlicloudRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAlicloudRoleRole(string role, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->GetAuthAlicloudRoleRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{alicloud_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAlicloudRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAlicloudRoleRoleAsync(string role, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->GetAuthAlicloudRoleRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{alicloud_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAlicloudRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAlicloudRoles(string list, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAlicloudRoles");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{alicloud_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAlicloudRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAlicloudRolesAsync(string list, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAlicloudRoles");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{alicloud_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAlicloudRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles registered with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthApproleRole(string list, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthApproleRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{approle_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles registered with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthApproleRoleAsync(string list, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthApproleRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{approle_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthApproleRoleRoleName(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{approle_mount_path}/role/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{approle_mount_path}/role/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthApproleRoleRoleNameBindSecretId(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameBindSecretId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameBindSecretIdAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameBindSecretId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthApproleRoleRoleNameBoundCidrList(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameBoundCidrList");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameBoundCidrListAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameBoundCidrList");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enables cluster local secret IDs 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthApproleRoleRoleNameLocalSecretIds(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameLocalSecretIds");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{approle_mount_path}/role/{role_name}/local-secret-ids", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameLocalSecretIds", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Enables cluster local secret IDs 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameLocalSecretIdsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameLocalSecretIds");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/local-secret-ids", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameLocalSecretIds", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthApproleRoleRoleNamePeriod(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNamePeriod");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{approle_mount_path}/role/{role_name}/period", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNamePeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthApproleRoleRoleNamePeriodAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNamePeriod");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/period", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNamePeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthApproleRoleRoleNamePolicies(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNamePolicies");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{approle_mount_path}/role/{role_name}/policies", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNamePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthApproleRoleRoleNamePoliciesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNamePolicies");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/policies", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNamePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the &#39;role_id&#39; of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthApproleRoleRoleNameRoleId(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameRoleId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{approle_mount_path}/role/{role_name}/role-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameRoleId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the &#39;role_id&#39; of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameRoleIdAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameRoleId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/role-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameRoleId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a SecretID against this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthApproleRoleRoleNameSecretId(string roleName, string list, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameSecretId");

            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthApproleRoleRoleNameSecretId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a SecretID against this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameSecretIdAsync(string roleName, string list, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameSecretId");

            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthApproleRoleRoleNameSecretId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthApproleRoleRoleNameSecretIdBoundCidrs(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameSecretIdBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameSecretIdBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthApproleRoleRoleNameSecretIdNumUses(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameSecretIdNumUses");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameSecretIdNumUses");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthApproleRoleRoleNameSecretIdTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameSecretIdTtl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameSecretIdTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameSecretIdTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthApproleRoleRoleNameTokenBoundCidrs(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameTokenBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameTokenBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthApproleRoleRoleNameTokenMaxTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameTokenMaxTtl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameTokenMaxTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameTokenMaxTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthApproleRoleRoleNameTokenNumUses(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameTokenNumUses");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{approle_mount_path}/role/{role_name}/token-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameTokenNumUsesAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameTokenNumUses");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthApproleRoleRoleNameTokenTtl(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameTokenTtl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{approle_mount_path}/role/{role_name}/token-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthApproleRoleRoleNameTokenTtlAsync(string roleName, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthApproleRoleRoleNameTokenTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthApproleRoleRoleNameTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsConfigCertificateCertName(string certName, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->GetAuthAwsConfigCertificateCertName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/certificate/{cert_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigCertificateCertName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsConfigCertificateCertNameAsync(string certName, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->GetAuthAwsConfigCertificateCertName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/certificate/{cert_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigCertificateCertName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsConfigCertificates(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAwsConfigCertificates");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/certificates", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigCertificates", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsConfigCertificatesAsync(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAwsConfigCertificates");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/certificates", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigCertificates", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsConfigClient(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/client", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigClient", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsConfigClientAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/client", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigClient", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsConfigIdentity(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/identity", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigIdentity", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsConfigIdentityAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/identity", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigIdentity", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsConfigSts(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAwsConfigSts");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/sts", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigSts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsConfigStsAsync(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAwsConfigSts");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/sts", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigSts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsConfigStsAccountId(string accountId, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->GetAuthAwsConfigStsAccountId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/sts/{account_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigStsAccountId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsConfigStsAccountIdAsync(string accountId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->GetAuthAwsConfigStsAccountId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/sts/{account_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigStsAccountId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsConfigTidyIdentityAccesslist(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/tidy/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigTidyIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsConfigTidyIdentityAccesslistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/tidy/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigTidyIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsConfigTidyIdentityWhitelist(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/tidy/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsConfigTidyIdentityWhitelistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/tidy/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsConfigTidyRoletagBlacklist(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/tidy/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigTidyRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsConfigTidyRoletagBlacklistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/tidy/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigTidyRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsConfigTidyRoletagDenylist(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/config/tidy/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigTidyRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsConfigTidyRoletagDenylistAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/config/tidy/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsConfigTidyRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsIdentityAccesslist(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAwsIdentityAccesslist");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsIdentityAccesslistAsync(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAwsIdentityAccesslist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsIdentityAccesslistInstanceId(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->GetAuthAwsIdentityAccesslistInstanceId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/identity-accesslist/{instance_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsIdentityAccesslistInstanceId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsIdentityAccesslistInstanceIdAsync(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->GetAuthAwsIdentityAccesslistInstanceId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/identity-accesslist/{instance_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsIdentityAccesslistInstanceId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsIdentityWhitelist(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAwsIdentityWhitelist");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsIdentityWhitelistAsync(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAwsIdentityWhitelist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsIdentityWhitelistInstanceId(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->GetAuthAwsIdentityWhitelistInstanceId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/identity-whitelist/{instance_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsIdentityWhitelistInstanceId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="instanceId">EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsIdentityWhitelistInstanceIdAsync(string instanceId, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'instanceId' is set
            if (instanceId == null)
                throw new VaultApiException(400, "Missing required parameter 'instanceId' when calling Auth->GetAuthAwsIdentityWhitelistInstanceId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("instance_id", ClientUtils.ParameterToString(instanceId)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/identity-whitelist/{instance_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsIdentityWhitelistInstanceId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsRole(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAwsRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsRoleAsync(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAwsRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsRoleRole(string role, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->GetAuthAwsRoleRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsRoleRoleAsync(string role, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->GetAuthAwsRoleRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsRoles(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAwsRoles");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsRolesAsync(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAwsRoles");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsRoletagBlacklist(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAwsRoletagBlacklist");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsRoletagBlacklistAsync(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAwsRoletagBlacklist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsRoletagBlacklistRoleTag(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->GetAuthAwsRoletagBlacklistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/roletag-blacklist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsRoletagBlacklistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsRoletagBlacklistRoleTagAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->GetAuthAwsRoletagBlacklistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/roletag-blacklist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsRoletagBlacklistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsRoletagDenylist(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAwsRoletagDenylist");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsRoletagDenylistAsync(string list, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAwsRoletagDenylist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAwsRoletagDenylistRoleTag(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->GetAuthAwsRoletagDenylistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{aws_mount_path}/roletag-denylist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsRoletagDenylistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAwsRoletagDenylistRoleTagAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->GetAuthAwsRoletagDenylistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{aws_mount_path}/roletag-denylist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAwsRoletagDenylistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAzureConfig(string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{azure_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAzureConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAzureConfigAsync(string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{azure_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAzureConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAzureRole(string list, string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAzureRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{azure_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAzureRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAzureRoleAsync(string list, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthAzureRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{azure_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAzureRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthAzureRoleName(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthAzureRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{azure_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAzureRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthAzureRoleNameAsync(string name, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthAzureRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{azure_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthAzureRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This path allows you to configure the centrify auth provider to interact with the Centrify Identity Services Platform for authenticating users. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;centrify&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthCentrifyConfig(string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (centrifyMountPath != null)
            {
                requestOptions.PathParameters.Add("centrify_mount_path", ClientUtils.ParameterToString(centrifyMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{centrify_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthCentrifyConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This path allows you to configure the centrify auth provider to interact with the Centrify Identity Services Platform for authenticating users. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;centrify&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthCentrifyConfigAsync(string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (centrifyMountPath != null)
            {
                requestOptions.PathParameters.Add("centrify_mount_path", ClientUtils.ParameterToString(centrifyMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{centrify_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthCentrifyConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthCertCerts(string list, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthCertCerts");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{cert_mount_path}/certs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthCertCerts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthCertCertsAsync(string list, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthCertCerts");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{cert_mount_path}/certs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthCertCerts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthCertCertsName(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthCertCertsName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{cert_mount_path}/certs/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthCertCertsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthCertCertsNameAsync(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthCertCertsName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{cert_mount_path}/certs/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthCertCertsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthCertConfig(string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{cert_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthCertConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthCertConfigAsync(string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{cert_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthCertConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthCertCrlsName(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthCertCrlsName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{cert_mount_path}/crls/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthCertCrlsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthCertCrlsNameAsync(string name, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthCertCrlsName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{cert_mount_path}/crls/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthCertCrlsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthCfConfig(string cfMountPath = "cf", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cfMountPath != null)
            {
                requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{cf_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthCfConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthCfConfigAsync(string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cfMountPath != null)
            {
                requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{cf_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthCfConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthCfRoles(string list, string cfMountPath = "cf", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthCfRoles");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cfMountPath != null)
            {
                requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{cf_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthCfRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthCfRolesAsync(string list, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthCfRoles");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cfMountPath != null)
            {
                requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{cf_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthCfRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthCfRolesRole(string role, string cfMountPath = "cf", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->GetAuthCfRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cfMountPath != null)
            {
                requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{cf_mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthCfRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthCfRolesRoleAsync(string role, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->GetAuthCfRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cfMountPath != null)
            {
                requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{cf_mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthCfRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure credentials used to query the GCP IAM API to verify authenticating service accounts 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthGcpConfig(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{gcp_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGcpConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure credentials used to query the GCP IAM API to verify authenticating service accounts 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthGcpConfigAsync(string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{gcp_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGcpConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthGcpRole(string list, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthGcpRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{gcp_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGcpRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthGcpRoleAsync(string list, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthGcpRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{gcp_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGcpRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a GCP role with associated policies and required attributes. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthGcpRoleName(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthGcpRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{gcp_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGcpRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a GCP role with associated policies and required attributes. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthGcpRoleNameAsync(string name, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthGcpRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{gcp_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGcpRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthGcpRoles(string list, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthGcpRoles");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{gcp_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGcpRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthGcpRolesAsync(string list, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthGcpRoles");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{gcp_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGcpRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthGithubConfig(string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{github_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGithubConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthGithubConfigAsync(string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{github_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGithubConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read mappings for teams 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthGithubMapTeams(string githubMountPath = "github", string list = "false", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{github_mount_path}/map/teams", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGithubMapTeams", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read mappings for teams 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthGithubMapTeamsAsync(string githubMountPath = "github", string list = "false", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{github_mount_path}/map/teams", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGithubMapTeams", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthGithubMapTeamsKey(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->GetAuthGithubMapTeamsKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{github_mount_path}/map/teams/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGithubMapTeamsKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthGithubMapTeamsKeyAsync(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->GetAuthGithubMapTeamsKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{github_mount_path}/map/teams/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGithubMapTeamsKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read mappings for users 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthGithubMapUsers(string githubMountPath = "github", string list = "false", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{github_mount_path}/map/users", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGithubMapUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read mappings for users 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="list">Return a list if &#x60;true&#x60; (optional, default to &quot;false&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthGithubMapUsersAsync(string githubMountPath = "github", string list = "false", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            if (list != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{github_mount_path}/map/users", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGithubMapUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthGithubMapUsersKey(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->GetAuthGithubMapUsersKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{github_mount_path}/map/users/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGithubMapUsersKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthGithubMapUsersKeyAsync(string key, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->GetAuthGithubMapUsersKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{github_mount_path}/map/users/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthGithubMapUsersKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the current JWT authentication backend configuration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthJwtConfig(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{jwt_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthJwtConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the current JWT authentication backend configuration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthJwtConfigAsync(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{jwt_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthJwtConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Callback endpoint to complete an OIDC login. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthJwtOidcCallback(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{jwt_mount_path}/oidc/callback", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthJwtOidcCallback", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Callback endpoint to complete an OIDC login. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthJwtOidcCallbackAsync(string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{jwt_mount_path}/oidc/callback", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthJwtOidcCallback", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles registered with the backend. The list will contain the names of the roles.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthJwtRole(string list, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthJwtRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{jwt_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthJwtRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles registered with the backend. The list will contain the names of the roles.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthJwtRoleAsync(string list, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthJwtRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{jwt_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthJwtRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read an existing role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthJwtRoleName(string name, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthJwtRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{jwt_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthJwtRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read an existing role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthJwtRoleNameAsync(string name, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthJwtRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{jwt_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthJwtRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthKerberosConfig(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{kerberos_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthKerberosConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthKerberosConfigAsync(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{kerberos_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthKerberosConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthKerberosConfigLdap(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{kerberos_mount_path}/config/ldap", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthKerberosConfigLdap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthKerberosConfigLdapAsync(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{kerberos_mount_path}/config/ldap", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthKerberosConfigLdap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthKerberosGroups(string list, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthKerberosGroups");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{kerberos_mount_path}/groups", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthKerberosGroups", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthKerberosGroupsAsync(string list, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthKerberosGroups");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{kerberos_mount_path}/groups", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthKerberosGroups", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthKerberosGroupsName(string name, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthKerberosGroupsName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{kerberos_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthKerberosGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthKerberosGroupsNameAsync(string name, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthKerberosGroupsName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{kerberos_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthKerberosGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthKerberosLogin(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{kerberos_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthKerberosLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthKerberosLoginAsync(string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{kerberos_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthKerberosLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures the JWT Public Key and Kubernetes API information. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthKubernetesConfig(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{kubernetes_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthKubernetesConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures the JWT Public Key and Kubernetes API information. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthKubernetesConfigAsync(string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{kubernetes_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthKubernetesConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles registered with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthKubernetesRole(string list, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthKubernetesRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{kubernetes_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthKubernetesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles registered with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthKubernetesRoleAsync(string list, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthKubernetesRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{kubernetes_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthKubernetesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthKubernetesRoleName(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthKubernetesRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{kubernetes_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthKubernetesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthKubernetesRoleNameAsync(string name, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthKubernetesRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{kubernetes_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthKubernetesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the LDAP server to connect to, along with its options. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthLdapConfig(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{ldap_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthLdapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the LDAP server to connect to, along with its options. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthLdapConfigAsync(string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{ldap_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthLdapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthLdapGroups(string list, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthLdapGroups");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{ldap_mount_path}/groups", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthLdapGroups", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthLdapGroupsAsync(string list, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthLdapGroups");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{ldap_mount_path}/groups", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthLdapGroups", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthLdapGroupsName(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthLdapGroupsName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{ldap_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthLdapGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthLdapGroupsNameAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthLdapGroupsName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{ldap_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthLdapGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthLdapUsers(string list, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthLdapUsers");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{ldap_mount_path}/users", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthLdapUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthLdapUsersAsync(string list, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthLdapUsers");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{ldap_mount_path}/users", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthLdapUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthLdapUsersName(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthLdapUsersName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{ldap_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthLdapUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthLdapUsersNameAsync(string name, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthLdapUsersName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{ldap_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthLdapUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manages the configuration for the Vault Auth Plugin. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthOciConfig(string ociMountPath = "oci", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ociMountPath != null)
            {
                requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{oci_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOciConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manages the configuration for the Vault Auth Plugin. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthOciConfigAsync(string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ociMountPath != null)
            {
                requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{oci_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOciConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthOciRole(string list, string ociMountPath = "oci", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthOciRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ociMountPath != null)
            {
                requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{oci_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOciRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles that are registered with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthOciRoleAsync(string list, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthOciRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ociMountPath != null)
            {
                requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{oci_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOciRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthOciRoleRole(string role, string ociMountPath = "oci", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->GetAuthOciRoleRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ociMountPath != null)
            {
                requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{oci_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOciRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthOciRoleRoleAsync(string role, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->GetAuthOciRoleRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ociMountPath != null)
            {
                requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{oci_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOciRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the current JWT authentication backend configuration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthOidcConfig(string oidcMountPath = "oidc", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{oidc_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOidcConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the current JWT authentication backend configuration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthOidcConfigAsync(string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{oidc_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOidcConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Callback endpoint to complete an OIDC login. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthOidcOidcCallback(string oidcMountPath = "oidc", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{oidc_mount_path}/oidc/callback", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOidcOidcCallback", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Callback endpoint to complete an OIDC login. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthOidcOidcCallbackAsync(string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{oidc_mount_path}/oidc/callback", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOidcOidcCallback", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles registered with the backend. The list will contain the names of the roles.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthOidcRole(string list, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthOidcRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{oidc_mount_path}/role", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOidcRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Lists all the roles registered with the backend. The list will contain the names of the roles.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthOidcRoleAsync(string list, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthOidcRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{oidc_mount_path}/role", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOidcRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read an existing role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthOidcRoleName(string name, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthOidcRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{oidc_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOidcRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read an existing role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthOidcRoleNameAsync(string name, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthOidcRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{oidc_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOidcRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint allows you to configure the Okta and its configuration options.  The Okta organization are the characters at the front of the URL for Okta. Example https://ORG.okta.com 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthOktaConfig(string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{okta_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOktaConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint allows you to configure the Okta and its configuration options.  The Okta organization are the characters at the front of the URL for Okta. Example https://ORG.okta.com 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthOktaConfigAsync(string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{okta_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOktaConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthOktaGroups(string list, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthOktaGroups");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{okta_mount_path}/groups", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOktaGroups", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthOktaGroupsAsync(string list, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthOktaGroups");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{okta_mount_path}/groups", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOktaGroups", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthOktaGroupsName(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthOktaGroupsName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{okta_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOktaGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthOktaGroupsNameAsync(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthOktaGroupsName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{okta_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOktaGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthOktaUsers(string list, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthOktaUsers");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{okta_mount_path}/users", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOktaUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthOktaUsersAsync(string list, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthOktaUsers");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{okta_mount_path}/users", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOktaUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthOktaUsersName(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthOktaUsersName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{okta_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOktaUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthOktaUsersNameAsync(string name, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthOktaUsersName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{okta_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOktaUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">Nonce provided during a login request to retrieve the number verification challenge for the matching request.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthOktaVerifyNonce(string nonce, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'nonce' is set
            if (nonce == null)
                throw new VaultApiException(400, "Missing required parameter 'nonce' when calling Auth->GetAuthOktaVerifyNonce");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("nonce", ClientUtils.ParameterToString(nonce)); // path parameter
            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{okta_mount_path}/verify/{nonce}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOktaVerifyNonce", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="nonce">Nonce provided during a login request to retrieve the number verification challenge for the matching request.</param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthOktaVerifyNonceAsync(string nonce, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'nonce' is set
            if (nonce == null)
                throw new VaultApiException(400, "Missing required parameter 'nonce' when calling Auth->GetAuthOktaVerifyNonce");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("nonce", ClientUtils.ParameterToString(nonce)); // path parameter
            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{okta_mount_path}/verify/{nonce}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthOktaVerifyNonce", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the RADIUS server to connect to, along with its options. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthRadiusConfig(string radiusMountPath = "radius", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (radiusMountPath != null)
            {
                requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{radius_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthRadiusConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the RADIUS server to connect to, along with its options. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthRadiusConfigAsync(string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (radiusMountPath != null)
            {
                requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{radius_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthRadiusConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthRadiusUsers(string list, string radiusMountPath = "radius", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthRadiusUsers");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (radiusMountPath != null)
            {
                requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{radius_mount_path}/users", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthRadiusUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthRadiusUsersAsync(string list, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthRadiusUsers");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (radiusMountPath != null)
            {
                requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{radius_mount_path}/users", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthRadiusUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthRadiusUsersName(string name, string radiusMountPath = "radius", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthRadiusUsersName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (radiusMountPath != null)
            {
                requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{radius_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthRadiusUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthRadiusUsersNameAsync(string name, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->GetAuthRadiusUsersName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (radiusMountPath != null)
            {
                requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{radius_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthRadiusUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires &#39;sudo&#39; capability in addition to &#39;list&#39;. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthTokenAccessors(string list, string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthTokenAccessors");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{token_mount_path}/accessors/", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthTokenAccessors", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires &#39;sudo&#39; capability in addition to &#39;list&#39;. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthTokenAccessorsAsync(string list, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthTokenAccessors");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{token_mount_path}/accessors/", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthTokenAccessors", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthTokenLookup(string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{token_mount_path}/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthTokenLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthTokenLookupAsync(string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{token_mount_path}/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthTokenLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthTokenLookupSelf(string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{token_mount_path}/lookup-self", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthTokenLookupSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthTokenLookupSelfAsync(string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{token_mount_path}/lookup-self", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthTokenLookupSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint lists configured roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthTokenRoles(string list, string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthTokenRoles");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{token_mount_path}/roles", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthTokenRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint lists configured roles. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthTokenRolesAsync(string list, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthTokenRoles");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{token_mount_path}/roles", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthTokenRoles", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthTokenRolesRoleName(string roleName, string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthTokenRolesRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{token_mount_path}/roles/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthTokenRolesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthTokenRolesRoleNameAsync(string roleName, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->GetAuthTokenRolesRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{token_mount_path}/roles/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthTokenRolesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthUserpassUsers(string list, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthUserpassUsers");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (userpassMountPath != null)
            {
                requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{userpass_mount_path}/users", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthUserpassUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="list">Must be set to &#x60;true&#x60;</param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthUserpassUsersAsync(string list, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'list' is set
            if (list == null)
                throw new VaultApiException(400, "Missing required parameter 'list' when calling Auth->GetAuthUserpassUsers");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (userpassMountPath != null)
            {
                requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter
            }
            requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "list", list));

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{userpass_mount_path}/users", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthUserpassUsers", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> GetAuthUserpassUsersUsername(string username, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->GetAuthUserpassUsersUsername");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            if (userpassMountPath != null)
            {
                requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Get<Object>("/auth/{userpass_mount_path}/users/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthUserpassUsersUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> GetAuthUserpassUsersUsernameAsync(string username, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->GetAuthUserpassUsersUsername");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            if (userpassMountPath != null)
            {
                requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.GetAsync<Object>("/auth/{userpass_mount_path}/users/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("GetAuthUserpassUsersUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates an RAM entity with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudLoginRequest"></param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAlicloudLogin(AlicloudLoginRequest alicloudLoginRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'alicloudLoginRequest' is set
            if (alicloudLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'alicloudLoginRequest' when calling Auth->PostAuthAlicloudLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.Data = alicloudLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{alicloud_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAlicloudLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates an RAM entity with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="alicloudLoginRequest"></param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAlicloudLoginAsync(AlicloudLoginRequest alicloudLoginRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'alicloudLoginRequest' is set
            if (alicloudLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'alicloudLoginRequest' when calling Auth->PostAuthAlicloudLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.Data = alicloudLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{alicloud_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAlicloudLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudRoleRequest"></param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAlicloudRoleRole(string role, AlicloudRoleRequest alicloudRoleRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->PostAuthAlicloudRoleRole");

            // verify the required parameter 'alicloudRoleRequest' is set
            if (alicloudRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'alicloudRoleRequest' when calling Auth->PostAuthAlicloudRoleRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = alicloudRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{alicloud_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAlicloudRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role as it should appear in Vault.</param>
        /// <param name="alicloudRoleRequest"></param>
        /// <param name="alicloudMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;alicloud&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAlicloudRoleRoleAsync(string role, AlicloudRoleRequest alicloudRoleRequest, string alicloudMountPath = "alicloud", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->PostAuthAlicloudRoleRole");

            // verify the required parameter 'alicloudRoleRequest' is set
            if (alicloudRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'alicloudRoleRequest' when calling Auth->PostAuthAlicloudRoleRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (alicloudMountPath != null)
            {
                requestOptions.PathParameters.Add("alicloud_mount_path", ClientUtils.ParameterToString(alicloudMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = alicloudRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{alicloud_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAlicloudRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="approleLoginRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleLogin(ApproleLoginRequest approleLoginRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'approleLoginRequest' is set
            if (approleLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleLoginRequest' when calling Auth->PostAuthApproleLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.Data = approleLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="approleLoginRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleLoginAsync(ApproleLoginRequest approleLoginRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'approleLoginRequest' is set
            if (approleLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleLoginRequest' when calling Auth->PostAuthApproleLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.Data = approleLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleName(string roleName, ApproleRoleRequest approleRoleRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleName");

            // verify the required parameter 'approleRoleRequest' is set
            if (approleRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleRequest' when calling Auth->PostAuthApproleRoleRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameAsync(string roleName, ApproleRoleRequest approleRoleRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleName");

            // verify the required parameter 'approleRoleRequest' is set
            if (approleRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleRequest' when calling Auth->PostAuthApproleRoleRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleBindSecretIdRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNameBindSecretId(string roleName, ApproleRoleBindSecretIdRequest approleRoleBindSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameBindSecretId");

            // verify the required parameter 'approleRoleBindSecretIdRequest' is set
            if (approleRoleBindSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleBindSecretIdRequest' when calling Auth->PostAuthApproleRoleRoleNameBindSecretId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleBindSecretIdRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Impose secret_id to be presented during login using this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleBindSecretIdRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameBindSecretIdAsync(string roleName, ApproleRoleBindSecretIdRequest approleRoleBindSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameBindSecretId");

            // verify the required parameter 'approleRoleBindSecretIdRequest' is set
            if (approleRoleBindSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleBindSecretIdRequest' when calling Auth->PostAuthApproleRoleRoleNameBindSecretId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleBindSecretIdRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/bind-secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameBindSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleBoundCidrListRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNameBoundCidrList(string roleName, ApproleRoleBoundCidrListRequest approleRoleBoundCidrListRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameBoundCidrList");

            // verify the required parameter 'approleRoleBoundCidrListRequest' is set
            if (approleRoleBoundCidrListRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleBoundCidrListRequest' when calling Auth->PostAuthApproleRoleRoleNameBoundCidrList");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleBoundCidrListRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleBoundCidrListRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameBoundCidrListAsync(string roleName, ApproleRoleBoundCidrListRequest approleRoleBoundCidrListRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameBoundCidrList");

            // verify the required parameter 'approleRoleBoundCidrListRequest' is set
            if (approleRoleBoundCidrListRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleBoundCidrListRequest' when calling Auth->PostAuthApproleRoleRoleNameBoundCidrList");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleBoundCidrListRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameBoundCidrList", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Assign a SecretID of choice against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleCustomSecretIdRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNameCustomSecretId(string roleName, ApproleRoleCustomSecretIdRequest approleRoleCustomSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameCustomSecretId");

            // verify the required parameter 'approleRoleCustomSecretIdRequest' is set
            if (approleRoleCustomSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleCustomSecretIdRequest' when calling Auth->PostAuthApproleRoleRoleNameCustomSecretId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleCustomSecretIdRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/custom-secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameCustomSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Assign a SecretID of choice against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleCustomSecretIdRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameCustomSecretIdAsync(string roleName, ApproleRoleCustomSecretIdRequest approleRoleCustomSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameCustomSecretId");

            // verify the required parameter 'approleRoleCustomSecretIdRequest' is set
            if (approleRoleCustomSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleCustomSecretIdRequest' when calling Auth->PostAuthApproleRoleRoleNameCustomSecretId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleCustomSecretIdRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/custom-secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameCustomSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRolePeriodRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNamePeriod(string roleName, ApproleRolePeriodRequest approleRolePeriodRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNamePeriod");

            // verify the required parameter 'approleRolePeriodRequest' is set
            if (approleRolePeriodRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRolePeriodRequest' when calling Auth->PostAuthApproleRoleRoleNamePeriod");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRolePeriodRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/period", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNamePeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Updates the value of &#39;period&#39; on the role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRolePeriodRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNamePeriodAsync(string roleName, ApproleRolePeriodRequest approleRolePeriodRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNamePeriod");

            // verify the required parameter 'approleRolePeriodRequest' is set
            if (approleRolePeriodRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRolePeriodRequest' when calling Auth->PostAuthApproleRoleRoleNamePeriod");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRolePeriodRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/period", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNamePeriod", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRolePoliciesRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNamePolicies(string roleName, ApproleRolePoliciesRequest approleRolePoliciesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNamePolicies");

            // verify the required parameter 'approleRolePoliciesRequest' is set
            if (approleRolePoliciesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRolePoliciesRequest' when calling Auth->PostAuthApproleRoleRoleNamePolicies");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRolePoliciesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/policies", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNamePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Policies of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRolePoliciesRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNamePoliciesAsync(string roleName, ApproleRolePoliciesRequest approleRolePoliciesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNamePolicies");

            // verify the required parameter 'approleRolePoliciesRequest' is set
            if (approleRolePoliciesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRolePoliciesRequest' when calling Auth->PostAuthApproleRoleRoleNamePolicies");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRolePoliciesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/policies", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNamePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the &#39;role_id&#39; of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleRoleIdRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNameRoleId(string roleName, ApproleRoleRoleIdRequest approleRoleRoleIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameRoleId");

            // verify the required parameter 'approleRoleRoleIdRequest' is set
            if (approleRoleRoleIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleRoleIdRequest' when calling Auth->PostAuthApproleRoleRoleNameRoleId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleRoleIdRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/role-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameRoleId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Returns the &#39;role_id&#39; of the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleRoleIdRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameRoleIdAsync(string roleName, ApproleRoleRoleIdRequest approleRoleRoleIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameRoleId");

            // verify the required parameter 'approleRoleRoleIdRequest' is set
            if (approleRoleRoleIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleRoleIdRequest' when calling Auth->PostAuthApproleRoleRoleNameRoleId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleRoleIdRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/role-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameRoleId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a SecretID against this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNameSecretId(string roleName, ApproleRoleSecretIdRequest approleRoleSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameSecretId");

            // verify the required parameter 'approleRoleSecretIdRequest' is set
            if (approleRoleSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdRequest' when calling Auth->PostAuthApproleRoleRoleNameSecretId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Generate a SecretID against this role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameSecretIdAsync(string roleName, ApproleRoleSecretIdRequest approleRoleSecretIdRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameSecretId");

            // verify the required parameter 'approleRoleSecretIdRequest' is set
            if (approleRoleSecretIdRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdRequest' when calling Auth->PostAuthApproleRoleRoleNameSecretId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameSecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdAccessorDestroyRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNameSecretIdAccessorDestroy(string roleName, ApproleRoleSecretIdAccessorDestroyRequest approleRoleSecretIdAccessorDestroyRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameSecretIdAccessorDestroy");

            // verify the required parameter 'approleRoleSecretIdAccessorDestroyRequest' is set
            if (approleRoleSecretIdAccessorDestroyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdAccessorDestroyRequest' when calling Auth->PostAuthApproleRoleRoleNameSecretIdAccessorDestroy");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdAccessorDestroyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameSecretIdAccessorDestroy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdAccessorDestroyRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameSecretIdAccessorDestroyAsync(string roleName, ApproleRoleSecretIdAccessorDestroyRequest approleRoleSecretIdAccessorDestroyRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameSecretIdAccessorDestroy");

            // verify the required parameter 'approleRoleSecretIdAccessorDestroyRequest' is set
            if (approleRoleSecretIdAccessorDestroyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdAccessorDestroyRequest' when calling Auth->PostAuthApproleRoleRoleNameSecretIdAccessorDestroy");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdAccessorDestroyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameSecretIdAccessorDestroy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdAccessorLookupRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNameSecretIdAccessorLookup(string roleName, ApproleRoleSecretIdAccessorLookupRequest approleRoleSecretIdAccessorLookupRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameSecretIdAccessorLookup");

            // verify the required parameter 'approleRoleSecretIdAccessorLookupRequest' is set
            if (approleRoleSecretIdAccessorLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdAccessorLookupRequest' when calling Auth->PostAuthApproleRoleRoleNameSecretIdAccessorLookup");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdAccessorLookupRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameSecretIdAccessorLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdAccessorLookupRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameSecretIdAccessorLookupAsync(string roleName, ApproleRoleSecretIdAccessorLookupRequest approleRoleSecretIdAccessorLookupRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameSecretIdAccessorLookup");

            // verify the required parameter 'approleRoleSecretIdAccessorLookupRequest' is set
            if (approleRoleSecretIdAccessorLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdAccessorLookupRequest' when calling Auth->PostAuthApproleRoleRoleNameSecretIdAccessorLookup");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdAccessorLookupRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameSecretIdAccessorLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdBoundCidrsRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNameSecretIdBoundCidrs(string roleName, ApproleRoleSecretIdBoundCidrsRequest approleRoleSecretIdBoundCidrsRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameSecretIdBoundCidrs");

            // verify the required parameter 'approleRoleSecretIdBoundCidrsRequest' is set
            if (approleRoleSecretIdBoundCidrsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdBoundCidrsRequest' when calling Auth->PostAuthApproleRoleRoleNameSecretIdBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdBoundCidrsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdBoundCidrsRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameSecretIdBoundCidrsAsync(string roleName, ApproleRoleSecretIdBoundCidrsRequest approleRoleSecretIdBoundCidrsRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameSecretIdBoundCidrs");

            // verify the required parameter 'approleRoleSecretIdBoundCidrsRequest' is set
            if (approleRoleSecretIdBoundCidrsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdBoundCidrsRequest' when calling Auth->PostAuthApproleRoleRoleNameSecretIdBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdBoundCidrsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameSecretIdBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Invalidate an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdDestroyRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNameSecretIdDestroy(string roleName, ApproleRoleSecretIdDestroyRequest approleRoleSecretIdDestroyRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameSecretIdDestroy");

            // verify the required parameter 'approleRoleSecretIdDestroyRequest' is set
            if (approleRoleSecretIdDestroyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdDestroyRequest' when calling Auth->PostAuthApproleRoleRoleNameSecretIdDestroy");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdDestroyRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id/destroy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameSecretIdDestroy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Invalidate an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdDestroyRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameSecretIdDestroyAsync(string roleName, ApproleRoleSecretIdDestroyRequest approleRoleSecretIdDestroyRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameSecretIdDestroy");

            // verify the required parameter 'approleRoleSecretIdDestroyRequest' is set
            if (approleRoleSecretIdDestroyRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdDestroyRequest' when calling Auth->PostAuthApproleRoleRoleNameSecretIdDestroy");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdDestroyRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id/destroy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameSecretIdDestroy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the properties of an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdLookupRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNameSecretIdLookup(string roleName, ApproleRoleSecretIdLookupRequest approleRoleSecretIdLookupRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameSecretIdLookup");

            // verify the required parameter 'approleRoleSecretIdLookupRequest' is set
            if (approleRoleSecretIdLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdLookupRequest' when calling Auth->PostAuthApproleRoleRoleNameSecretIdLookup");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdLookupRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameSecretIdLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read the properties of an issued secret_id 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdLookupRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameSecretIdLookupAsync(string roleName, ApproleRoleSecretIdLookupRequest approleRoleSecretIdLookupRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameSecretIdLookup");

            // verify the required parameter 'approleRoleSecretIdLookupRequest' is set
            if (approleRoleSecretIdLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdLookupRequest' when calling Auth->PostAuthApproleRoleRoleNameSecretIdLookup");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdLookupRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameSecretIdLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdNumUsesRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNameSecretIdNumUses(string roleName, ApproleRoleSecretIdNumUsesRequest approleRoleSecretIdNumUsesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameSecretIdNumUses");

            // verify the required parameter 'approleRoleSecretIdNumUsesRequest' is set
            if (approleRoleSecretIdNumUsesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdNumUsesRequest' when calling Auth->PostAuthApproleRoleRoleNameSecretIdNumUses");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdNumUsesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Use limit of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdNumUsesRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameSecretIdNumUsesAsync(string roleName, ApproleRoleSecretIdNumUsesRequest approleRoleSecretIdNumUsesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameSecretIdNumUses");

            // verify the required parameter 'approleRoleSecretIdNumUsesRequest' is set
            if (approleRoleSecretIdNumUsesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdNumUsesRequest' when calling Auth->PostAuthApproleRoleRoleNameSecretIdNumUses");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdNumUsesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameSecretIdNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdTtlRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNameSecretIdTtl(string roleName, ApproleRoleSecretIdTtlRequest approleRoleSecretIdTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameSecretIdTtl");

            // verify the required parameter 'approleRoleSecretIdTtlRequest' is set
            if (approleRoleSecretIdTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdTtlRequest' when calling Auth->PostAuthApproleRoleRoleNameSecretIdTtl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdTtlRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds of the SecretID generated against the role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleSecretIdTtlRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameSecretIdTtlAsync(string roleName, ApproleRoleSecretIdTtlRequest approleRoleSecretIdTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameSecretIdTtl");

            // verify the required parameter 'approleRoleSecretIdTtlRequest' is set
            if (approleRoleSecretIdTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleSecretIdTtlRequest' when calling Auth->PostAuthApproleRoleRoleNameSecretIdTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleSecretIdTtlRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameSecretIdTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenBoundCidrsRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNameTokenBoundCidrs(string roleName, ApproleRoleTokenBoundCidrsRequest approleRoleTokenBoundCidrsRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameTokenBoundCidrs");

            // verify the required parameter 'approleRoleTokenBoundCidrsRequest' is set
            if (approleRoleTokenBoundCidrsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleTokenBoundCidrsRequest' when calling Auth->PostAuthApproleRoleRoleNameTokenBoundCidrs");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenBoundCidrsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenBoundCidrsRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameTokenBoundCidrsAsync(string roleName, ApproleRoleTokenBoundCidrsRequest approleRoleTokenBoundCidrsRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameTokenBoundCidrs");

            // verify the required parameter 'approleRoleTokenBoundCidrsRequest' is set
            if (approleRoleTokenBoundCidrsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleTokenBoundCidrsRequest' when calling Auth->PostAuthApproleRoleRoleNameTokenBoundCidrs");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenBoundCidrsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameTokenBoundCidrs", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenMaxTtlRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNameTokenMaxTtl(string roleName, ApproleRoleTokenMaxTtlRequest approleRoleTokenMaxTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameTokenMaxTtl");

            // verify the required parameter 'approleRoleTokenMaxTtlRequest' is set
            if (approleRoleTokenMaxTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleTokenMaxTtlRequest' when calling Auth->PostAuthApproleRoleRoleNameTokenMaxTtl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenMaxTtlRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenMaxTtlRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameTokenMaxTtlAsync(string roleName, ApproleRoleTokenMaxTtlRequest approleRoleTokenMaxTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameTokenMaxTtl");

            // verify the required parameter 'approleRoleTokenMaxTtlRequest' is set
            if (approleRoleTokenMaxTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleTokenMaxTtlRequest' when calling Auth->PostAuthApproleRoleRoleNameTokenMaxTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenMaxTtlRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-max-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameTokenMaxTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenNumUsesRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNameTokenNumUses(string roleName, ApproleRoleTokenNumUsesRequest approleRoleTokenNumUsesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameTokenNumUses");

            // verify the required parameter 'approleRoleTokenNumUsesRequest' is set
            if (approleRoleTokenNumUsesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleTokenNumUsesRequest' when calling Auth->PostAuthApproleRoleRoleNameTokenNumUses");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenNumUsesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/token-num-uses", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Number of times issued tokens can be used 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenNumUsesRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameTokenNumUsesAsync(string roleName, ApproleRoleTokenNumUsesRequest approleRoleTokenNumUsesRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameTokenNumUses");

            // verify the required parameter 'approleRoleTokenNumUsesRequest' is set
            if (approleRoleTokenNumUsesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleTokenNumUsesRequest' when calling Auth->PostAuthApproleRoleRoleNameTokenNumUses");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenNumUsesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-num-uses", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameTokenNumUses", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenTtlRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleRoleRoleNameTokenTtl(string roleName, ApproleRoleTokenTtlRequest approleRoleTokenTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameTokenTtl");

            // verify the required parameter 'approleRoleTokenTtlRequest' is set
            if (approleRoleTokenTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleTokenTtlRequest' when calling Auth->PostAuthApproleRoleRoleNameTokenTtl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenTtlRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/role/{role_name}/token-ttl", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role. Must be less than 4096 bytes.</param>
        /// <param name="approleRoleTokenTtlRequest"></param>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleRoleRoleNameTokenTtlAsync(string roleName, ApproleRoleTokenTtlRequest approleRoleTokenTtlRequest, string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthApproleRoleRoleNameTokenTtl");

            // verify the required parameter 'approleRoleTokenTtlRequest' is set
            if (approleRoleTokenTtlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'approleRoleTokenTtlRequest' when calling Auth->PostAuthApproleRoleRoleNameTokenTtl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            requestOptions.Data = approleRoleTokenTtlRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/role/{role_name}/token-ttl", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleRoleRoleNameTokenTtl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Trigger the clean-up of expired SecretID entries. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthApproleTidySecretId(string approleMountPath = "approle", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{approle_mount_path}/tidy/secret-id", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleTidySecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Trigger the clean-up of expired SecretID entries. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="approleMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;approle&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthApproleTidySecretIdAsync(string approleMountPath = "approle", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (approleMountPath != null)
            {
                requestOptions.PathParameters.Add("approle_mount_path", ClientUtils.ParameterToString(approleMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{approle_mount_path}/tidy/secret-id", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthApproleTidySecretId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsConfigCertificateRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsConfigCertificateCertName(string certName, AwsConfigCertificateRequest awsConfigCertificateRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->PostAuthAwsConfigCertificateCertName");

            // verify the required parameter 'awsConfigCertificateRequest' is set
            if (awsConfigCertificateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigCertificateRequest' when calling Auth->PostAuthAwsConfigCertificateCertName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter
            requestOptions.Data = awsConfigCertificateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/certificate/{cert_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigCertificateCertName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certName">Name of the certificate.</param>
        /// <param name="awsConfigCertificateRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsConfigCertificateCertNameAsync(string certName, AwsConfigCertificateRequest awsConfigCertificateRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'certName' is set
            if (certName == null)
                throw new VaultApiException(400, "Missing required parameter 'certName' when calling Auth->PostAuthAwsConfigCertificateCertName");

            // verify the required parameter 'awsConfigCertificateRequest' is set
            if (awsConfigCertificateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigCertificateRequest' when calling Auth->PostAuthAwsConfigCertificateCertName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("cert_name", ClientUtils.ParameterToString(certName)); // path parameter
            requestOptions.Data = awsConfigCertificateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/certificate/{cert_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigCertificateCertName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigClientRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsConfigClient(AwsConfigClientRequest awsConfigClientRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'awsConfigClientRequest' is set
            if (awsConfigClientRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigClientRequest' when calling Auth->PostAuthAwsConfigClient");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigClientRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/client", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigClient", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigClientRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsConfigClientAsync(AwsConfigClientRequest awsConfigClientRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsConfigClientRequest' is set
            if (awsConfigClientRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigClientRequest' when calling Auth->PostAuthAwsConfigClient");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigClientRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/client", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigClient", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigIdentityRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsConfigIdentity(AwsConfigIdentityRequest awsConfigIdentityRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'awsConfigIdentityRequest' is set
            if (awsConfigIdentityRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigIdentityRequest' when calling Auth->PostAuthAwsConfigIdentity");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigIdentityRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/identity", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigIdentity", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigIdentityRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsConfigIdentityAsync(AwsConfigIdentityRequest awsConfigIdentityRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsConfigIdentityRequest' is set
            if (awsConfigIdentityRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigIdentityRequest' when calling Auth->PostAuthAwsConfigIdentity");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigIdentityRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/identity", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigIdentity", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsConfigRotateRoot(string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/rotate-root", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsConfigRotateRootAsync(string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/rotate-root", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigRotateRoot", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsConfigStsRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsConfigStsAccountId(string accountId, AwsConfigStsRequest awsConfigStsRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->PostAuthAwsConfigStsAccountId");

            // verify the required parameter 'awsConfigStsRequest' is set
            if (awsConfigStsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigStsRequest' when calling Auth->PostAuthAwsConfigStsAccountId");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigStsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/sts/{account_id}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigStsAccountId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.</param>
        /// <param name="awsConfigStsRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsConfigStsAccountIdAsync(string accountId, AwsConfigStsRequest awsConfigStsRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new VaultApiException(400, "Missing required parameter 'accountId' when calling Auth->PostAuthAwsConfigStsAccountId");

            // verify the required parameter 'awsConfigStsRequest' is set
            if (awsConfigStsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigStsRequest' when calling Auth->PostAuthAwsConfigStsAccountId");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("account_id", ClientUtils.ParameterToString(accountId)); // path parameter
            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigStsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/sts/{account_id}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigStsAccountId", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyIdentityAccesslistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsConfigTidyIdentityAccesslist(AwsConfigTidyIdentityAccesslistRequest awsConfigTidyIdentityAccesslistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'awsConfigTidyIdentityAccesslistRequest' is set
            if (awsConfigTidyIdentityAccesslistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigTidyIdentityAccesslistRequest' when calling Auth->PostAuthAwsConfigTidyIdentityAccesslist");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyIdentityAccesslistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/tidy/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigTidyIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyIdentityAccesslistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsConfigTidyIdentityAccesslistAsync(AwsConfigTidyIdentityAccesslistRequest awsConfigTidyIdentityAccesslistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsConfigTidyIdentityAccesslistRequest' is set
            if (awsConfigTidyIdentityAccesslistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigTidyIdentityAccesslistRequest' when calling Auth->PostAuthAwsConfigTidyIdentityAccesslist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyIdentityAccesslistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/tidy/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigTidyIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyIdentityWhitelistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsConfigTidyIdentityWhitelist(AwsConfigTidyIdentityWhitelistRequest awsConfigTidyIdentityWhitelistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'awsConfigTidyIdentityWhitelistRequest' is set
            if (awsConfigTidyIdentityWhitelistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigTidyIdentityWhitelistRequest' when calling Auth->PostAuthAwsConfigTidyIdentityWhitelist");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyIdentityWhitelistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/tidy/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyIdentityWhitelistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsConfigTidyIdentityWhitelistAsync(AwsConfigTidyIdentityWhitelistRequest awsConfigTidyIdentityWhitelistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsConfigTidyIdentityWhitelistRequest' is set
            if (awsConfigTidyIdentityWhitelistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigTidyIdentityWhitelistRequest' when calling Auth->PostAuthAwsConfigTidyIdentityWhitelist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyIdentityWhitelistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/tidy/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyRoletagBlacklistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsConfigTidyRoletagBlacklist(AwsConfigTidyRoletagBlacklistRequest awsConfigTidyRoletagBlacklistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'awsConfigTidyRoletagBlacklistRequest' is set
            if (awsConfigTidyRoletagBlacklistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigTidyRoletagBlacklistRequest' when calling Auth->PostAuthAwsConfigTidyRoletagBlacklist");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyRoletagBlacklistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/tidy/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigTidyRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyRoletagBlacklistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsConfigTidyRoletagBlacklistAsync(AwsConfigTidyRoletagBlacklistRequest awsConfigTidyRoletagBlacklistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsConfigTidyRoletagBlacklistRequest' is set
            if (awsConfigTidyRoletagBlacklistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigTidyRoletagBlacklistRequest' when calling Auth->PostAuthAwsConfigTidyRoletagBlacklist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyRoletagBlacklistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/tidy/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigTidyRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyRoletagDenylistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsConfigTidyRoletagDenylist(AwsConfigTidyRoletagDenylistRequest awsConfigTidyRoletagDenylistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'awsConfigTidyRoletagDenylistRequest' is set
            if (awsConfigTidyRoletagDenylistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigTidyRoletagDenylistRequest' when calling Auth->PostAuthAwsConfigTidyRoletagDenylist");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyRoletagDenylistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/config/tidy/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigTidyRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsConfigTidyRoletagDenylistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsConfigTidyRoletagDenylistAsync(AwsConfigTidyRoletagDenylistRequest awsConfigTidyRoletagDenylistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsConfigTidyRoletagDenylistRequest' is set
            if (awsConfigTidyRoletagDenylistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsConfigTidyRoletagDenylistRequest' when calling Auth->PostAuthAwsConfigTidyRoletagDenylist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsConfigTidyRoletagDenylistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/config/tidy/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsConfigTidyRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsLoginRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsLogin(AwsLoginRequest awsLoginRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'awsLoginRequest' is set
            if (awsLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsLoginRequest' when calling Auth->PostAuthAwsLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsLoginRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsLoginAsync(AwsLoginRequest awsLoginRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsLoginRequest' is set
            if (awsLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsLoginRequest' when calling Auth->PostAuthAwsLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsRoleRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsRoleRole(string role, AwsRoleRequest awsRoleRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->PostAuthAwsRoleRole");

            // verify the required parameter 'awsRoleRequest' is set
            if (awsRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsRoleRequest' when calling Auth->PostAuthAwsRoleRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = awsRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsRoleRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsRoleRoleAsync(string role, AwsRoleRequest awsRoleRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->PostAuthAwsRoleRole");

            // verify the required parameter 'awsRoleRequest' is set
            if (awsRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsRoleRequest' when calling Auth->PostAuthAwsRoleRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = awsRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsRoleTagRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsRoleRoleTag(string role, AwsRoleTagRequest awsRoleTagRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->PostAuthAwsRoleRoleTag");

            // verify the required parameter 'awsRoleTagRequest' is set
            if (awsRoleTagRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsRoleTagRequest' when calling Auth->PostAuthAwsRoleRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = awsRoleTagRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/role/{role}/tag", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsRoleRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="awsRoleTagRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsRoleRoleTagAsync(string role, AwsRoleTagRequest awsRoleTagRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->PostAuthAwsRoleRoleTag");

            // verify the required parameter 'awsRoleTagRequest' is set
            if (awsRoleTagRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsRoleTagRequest' when calling Auth->PostAuthAwsRoleRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = awsRoleTagRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/role/{role}/tag", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsRoleRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsRoletagBlacklistRoleTag(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->PostAuthAwsRoletagBlacklistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/roletag-blacklist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsRoletagBlacklistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsRoletagBlacklistRoleTagAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->PostAuthAwsRoletagBlacklistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/roletag-blacklist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsRoletagBlacklistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsRoletagDenylistRoleTag(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->PostAuthAwsRoletagDenylistRoleTag");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/roletag-denylist/{role_tag}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsRoletagDenylistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleTag">Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.</param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsRoletagDenylistRoleTagAsync(string roleTag, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleTag' is set
            if (roleTag == null)
                throw new VaultApiException(400, "Missing required parameter 'roleTag' when calling Auth->PostAuthAwsRoletagDenylistRoleTag");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role_tag", ClientUtils.ParameterToString(roleTag)); // path parameter

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/roletag-denylist/{role_tag}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsRoletagDenylistRoleTag", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityAccesslistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsTidyIdentityAccesslist(AwsTidyIdentityAccesslistRequest awsTidyIdentityAccesslistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'awsTidyIdentityAccesslistRequest' is set
            if (awsTidyIdentityAccesslistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyIdentityAccesslistRequest' when calling Auth->PostAuthAwsTidyIdentityAccesslist");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsTidyIdentityAccesslistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/tidy/identity-accesslist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsTidyIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityAccesslistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsTidyIdentityAccesslistAsync(AwsTidyIdentityAccesslistRequest awsTidyIdentityAccesslistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsTidyIdentityAccesslistRequest' is set
            if (awsTidyIdentityAccesslistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyIdentityAccesslistRequest' when calling Auth->PostAuthAwsTidyIdentityAccesslist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsTidyIdentityAccesslistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/tidy/identity-accesslist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsTidyIdentityAccesslist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityWhitelistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsTidyIdentityWhitelist(AwsTidyIdentityWhitelistRequest awsTidyIdentityWhitelistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'awsTidyIdentityWhitelistRequest' is set
            if (awsTidyIdentityWhitelistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyIdentityWhitelistRequest' when calling Auth->PostAuthAwsTidyIdentityWhitelist");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsTidyIdentityWhitelistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/tidy/identity-whitelist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyIdentityWhitelistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsTidyIdentityWhitelistAsync(AwsTidyIdentityWhitelistRequest awsTidyIdentityWhitelistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsTidyIdentityWhitelistRequest' is set
            if (awsTidyIdentityWhitelistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyIdentityWhitelistRequest' when calling Auth->PostAuthAwsTidyIdentityWhitelist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsTidyIdentityWhitelistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/tidy/identity-whitelist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsTidyIdentityWhitelist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoletagBlacklistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsTidyRoletagBlacklist(AwsTidyRoletagBlacklistRequest awsTidyRoletagBlacklistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'awsTidyRoletagBlacklistRequest' is set
            if (awsTidyRoletagBlacklistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyRoletagBlacklistRequest' when calling Auth->PostAuthAwsTidyRoletagBlacklist");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsTidyRoletagBlacklistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/tidy/roletag-blacklist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsTidyRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoletagBlacklistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsTidyRoletagBlacklistAsync(AwsTidyRoletagBlacklistRequest awsTidyRoletagBlacklistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsTidyRoletagBlacklistRequest' is set
            if (awsTidyRoletagBlacklistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyRoletagBlacklistRequest' when calling Auth->PostAuthAwsTidyRoletagBlacklist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsTidyRoletagBlacklistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/tidy/roletag-blacklist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsTidyRoletagBlacklist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoletagDenylistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAwsTidyRoletagDenylist(AwsTidyRoletagDenylistRequest awsTidyRoletagDenylistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'awsTidyRoletagDenylistRequest' is set
            if (awsTidyRoletagDenylistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyRoletagDenylistRequest' when calling Auth->PostAuthAwsTidyRoletagDenylist");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsTidyRoletagDenylistRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{aws_mount_path}/tidy/roletag-denylist", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsTidyRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="awsTidyRoletagDenylistRequest"></param>
        /// <param name="awsMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;aws&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAwsTidyRoletagDenylistAsync(AwsTidyRoletagDenylistRequest awsTidyRoletagDenylistRequest, string awsMountPath = "aws", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'awsTidyRoletagDenylistRequest' is set
            if (awsTidyRoletagDenylistRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'awsTidyRoletagDenylistRequest' when calling Auth->PostAuthAwsTidyRoletagDenylist");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (awsMountPath != null)
            {
                requestOptions.PathParameters.Add("aws_mount_path", ClientUtils.ParameterToString(awsMountPath)); // path parameter
            }
            requestOptions.Data = awsTidyRoletagDenylistRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{aws_mount_path}/tidy/roletag-denylist", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAwsTidyRoletagDenylist", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureConfigRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAzureConfig(AzureConfigRequest azureConfigRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'azureConfigRequest' is set
            if (azureConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureConfigRequest' when calling Auth->PostAuthAzureConfig");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.Data = azureConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{azure_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAzureConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureConfigRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAzureConfigAsync(AzureConfigRequest azureConfigRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'azureConfigRequest' is set
            if (azureConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureConfigRequest' when calling Auth->PostAuthAzureConfig");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.Data = azureConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{azure_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAzureConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureLoginRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAzureLogin(AzureLoginRequest azureLoginRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'azureLoginRequest' is set
            if (azureLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureLoginRequest' when calling Auth->PostAuthAzureLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.Data = azureLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{azure_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAzureLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="azureLoginRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAzureLoginAsync(AzureLoginRequest azureLoginRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'azureLoginRequest' is set
            if (azureLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureLoginRequest' when calling Auth->PostAuthAzureLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.Data = azureLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{azure_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAzureLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureRoleRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthAzureRoleName(string name, AzureRoleRequest azureRoleRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthAzureRoleName");

            // verify the required parameter 'azureRoleRequest' is set
            if (azureRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureRoleRequest' when calling Auth->PostAuthAzureRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = azureRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{azure_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAzureRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="azureRoleRequest"></param>
        /// <param name="azureMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;azure&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthAzureRoleNameAsync(string name, AzureRoleRequest azureRoleRequest, string azureMountPath = "azure", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthAzureRoleName");

            // verify the required parameter 'azureRoleRequest' is set
            if (azureRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'azureRoleRequest' when calling Auth->PostAuthAzureRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (azureMountPath != null)
            {
                requestOptions.PathParameters.Add("azure_mount_path", ClientUtils.ParameterToString(azureMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = azureRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{azure_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthAzureRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This path allows you to configure the centrify auth provider to interact with the Centrify Identity Services Platform for authenticating users. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyConfigRequest"></param>
        /// <param name="centrifyMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;centrify&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthCentrifyConfig(CentrifyConfigRequest centrifyConfigRequest, string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'centrifyConfigRequest' is set
            if (centrifyConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'centrifyConfigRequest' when calling Auth->PostAuthCentrifyConfig");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (centrifyMountPath != null)
            {
                requestOptions.PathParameters.Add("centrify_mount_path", ClientUtils.ParameterToString(centrifyMountPath)); // path parameter
            }
            requestOptions.Data = centrifyConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{centrify_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCentrifyConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This path allows you to configure the centrify auth provider to interact with the Centrify Identity Services Platform for authenticating users. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyConfigRequest"></param>
        /// <param name="centrifyMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;centrify&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthCentrifyConfigAsync(CentrifyConfigRequest centrifyConfigRequest, string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'centrifyConfigRequest' is set
            if (centrifyConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'centrifyConfigRequest' when calling Auth->PostAuthCentrifyConfig");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (centrifyMountPath != null)
            {
                requestOptions.PathParameters.Add("centrify_mount_path", ClientUtils.ParameterToString(centrifyMountPath)); // path parameter
            }
            requestOptions.Data = centrifyConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{centrify_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCentrifyConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyLoginRequest"></param>
        /// <param name="centrifyMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;centrify&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthCentrifyLogin(CentrifyLoginRequest centrifyLoginRequest, string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'centrifyLoginRequest' is set
            if (centrifyLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'centrifyLoginRequest' when calling Auth->PostAuthCentrifyLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (centrifyMountPath != null)
            {
                requestOptions.PathParameters.Add("centrify_mount_path", ClientUtils.ParameterToString(centrifyMountPath)); // path parameter
            }
            requestOptions.Data = centrifyLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{centrify_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCentrifyLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="centrifyLoginRequest"></param>
        /// <param name="centrifyMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;centrify&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthCentrifyLoginAsync(CentrifyLoginRequest centrifyLoginRequest, string centrifyMountPath = "centrify", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'centrifyLoginRequest' is set
            if (centrifyLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'centrifyLoginRequest' when calling Auth->PostAuthCentrifyLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (centrifyMountPath != null)
            {
                requestOptions.PathParameters.Add("centrify_mount_path", ClientUtils.ParameterToString(centrifyMountPath)); // path parameter
            }
            requestOptions.Data = centrifyLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{centrify_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCentrifyLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certCertsRequest"></param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthCertCertsName(string name, CertCertsRequest certCertsRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthCertCertsName");

            // verify the required parameter 'certCertsRequest' is set
            if (certCertsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certCertsRequest' when calling Auth->PostAuthCertCertsName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = certCertsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{cert_mount_path}/certs/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCertCertsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage trusted certificates used for authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certCertsRequest"></param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthCertCertsNameAsync(string name, CertCertsRequest certCertsRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthCertCertsName");

            // verify the required parameter 'certCertsRequest' is set
            if (certCertsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certCertsRequest' when calling Auth->PostAuthCertCertsName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = certCertsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{cert_mount_path}/certs/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCertCertsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certConfigRequest"></param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthCertConfig(CertConfigRequest certConfigRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'certConfigRequest' is set
            if (certConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certConfigRequest' when calling Auth->PostAuthCertConfig");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.Data = certConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{cert_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCertConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certConfigRequest"></param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthCertConfigAsync(CertConfigRequest certConfigRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'certConfigRequest' is set
            if (certConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certConfigRequest' when calling Auth->PostAuthCertConfig");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.Data = certConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{cert_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCertConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certCrlsRequest"></param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthCertCrlsName(string name, CertCrlsRequest certCrlsRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthCertCrlsName");

            // verify the required parameter 'certCrlsRequest' is set
            if (certCrlsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certCrlsRequest' when calling Auth->PostAuthCertCrlsName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = certCrlsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{cert_mount_path}/crls/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCertCrlsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage Certificate Revocation Lists checked during authentication. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">The name of the certificate</param>
        /// <param name="certCrlsRequest"></param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthCertCrlsNameAsync(string name, CertCrlsRequest certCrlsRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthCertCrlsName");

            // verify the required parameter 'certCrlsRequest' is set
            if (certCrlsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certCrlsRequest' when calling Auth->PostAuthCertCrlsName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = certCrlsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{cert_mount_path}/crls/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCertCrlsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certLoginRequest"></param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthCertLogin(CertLoginRequest certLoginRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'certLoginRequest' is set
            if (certLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certLoginRequest' when calling Auth->PostAuthCertLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.Data = certLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{cert_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCertLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="certLoginRequest"></param>
        /// <param name="certMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cert&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthCertLoginAsync(CertLoginRequest certLoginRequest, string certMountPath = "cert", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'certLoginRequest' is set
            if (certLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'certLoginRequest' when calling Auth->PostAuthCertLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (certMountPath != null)
            {
                requestOptions.PathParameters.Add("cert_mount_path", ClientUtils.ParameterToString(certMountPath)); // path parameter
            }
            requestOptions.Data = certLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{cert_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCertLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfConfigRequest"></param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthCfConfig(CfConfigRequest cfConfigRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'cfConfigRequest' is set
            if (cfConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'cfConfigRequest' when calling Auth->PostAuthCfConfig");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cfMountPath != null)
            {
                requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter
            }
            requestOptions.Data = cfConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{cf_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCfConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfConfigRequest"></param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthCfConfigAsync(CfConfigRequest cfConfigRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'cfConfigRequest' is set
            if (cfConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'cfConfigRequest' when calling Auth->PostAuthCfConfig");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cfMountPath != null)
            {
                requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter
            }
            requestOptions.Data = cfConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{cf_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCfConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfLoginRequest"></param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthCfLogin(CfLoginRequest cfLoginRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'cfLoginRequest' is set
            if (cfLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'cfLoginRequest' when calling Auth->PostAuthCfLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cfMountPath != null)
            {
                requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter
            }
            requestOptions.Data = cfLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{cf_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCfLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="cfLoginRequest"></param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthCfLoginAsync(CfLoginRequest cfLoginRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'cfLoginRequest' is set
            if (cfLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'cfLoginRequest' when calling Auth->PostAuthCfLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cfMountPath != null)
            {
                requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter
            }
            requestOptions.Data = cfLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{cf_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCfLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfRolesRequest"></param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthCfRolesRole(string role, CfRolesRequest cfRolesRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->PostAuthCfRolesRole");

            // verify the required parameter 'cfRolesRequest' is set
            if (cfRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'cfRolesRequest' when calling Auth->PostAuthCfRolesRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cfMountPath != null)
            {
                requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = cfRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{cf_mount_path}/roles/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCfRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">The name of the role.</param>
        /// <param name="cfRolesRequest"></param>
        /// <param name="cfMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;cf&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthCfRolesRoleAsync(string role, CfRolesRequest cfRolesRequest, string cfMountPath = "cf", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->PostAuthCfRolesRole");

            // verify the required parameter 'cfRolesRequest' is set
            if (cfRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'cfRolesRequest' when calling Auth->PostAuthCfRolesRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (cfMountPath != null)
            {
                requestOptions.PathParameters.Add("cf_mount_path", ClientUtils.ParameterToString(cfMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = cfRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{cf_mount_path}/roles/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthCfRolesRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure credentials used to query the GCP IAM API to verify authenticating service accounts 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpConfigRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthGcpConfig(GcpConfigRequest gcpConfigRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'gcpConfigRequest' is set
            if (gcpConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpConfigRequest' when calling Auth->PostAuthGcpConfig");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.Data = gcpConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{gcp_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGcpConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure credentials used to query the GCP IAM API to verify authenticating service accounts 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpConfigRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthGcpConfigAsync(GcpConfigRequest gcpConfigRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'gcpConfigRequest' is set
            if (gcpConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpConfigRequest' when calling Auth->PostAuthGcpConfig");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.Data = gcpConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{gcp_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGcpConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpLoginRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthGcpLogin(GcpLoginRequest gcpLoginRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'gcpLoginRequest' is set
            if (gcpLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpLoginRequest' when calling Auth->PostAuthGcpLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.Data = gcpLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{gcp_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGcpLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="gcpLoginRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthGcpLoginAsync(GcpLoginRequest gcpLoginRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'gcpLoginRequest' is set
            if (gcpLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpLoginRequest' when calling Auth->PostAuthGcpLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.Data = gcpLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{gcp_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGcpLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a GCP role with associated policies and required attributes. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthGcpRoleName(string name, GcpRoleRequest gcpRoleRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthGcpRoleName");

            // verify the required parameter 'gcpRoleRequest' is set
            if (gcpRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRoleRequest' when calling Auth->PostAuthGcpRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{gcp_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGcpRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a GCP role with associated policies and required attributes. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthGcpRoleNameAsync(string name, GcpRoleRequest gcpRoleRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthGcpRoleName");

            // verify the required parameter 'gcpRoleRequest' is set
            if (gcpRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRoleRequest' when calling Auth->PostAuthGcpRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{gcp_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGcpRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Add or remove labels for an existing &#39;gce&#39; role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleLabelsRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthGcpRoleNameLabels(string name, GcpRoleLabelsRequest gcpRoleLabelsRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthGcpRoleNameLabels");

            // verify the required parameter 'gcpRoleLabelsRequest' is set
            if (gcpRoleLabelsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRoleLabelsRequest' when calling Auth->PostAuthGcpRoleNameLabels");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRoleLabelsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{gcp_mount_path}/role/{name}/labels", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGcpRoleNameLabels", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Add or remove labels for an existing &#39;gce&#39; role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleLabelsRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthGcpRoleNameLabelsAsync(string name, GcpRoleLabelsRequest gcpRoleLabelsRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthGcpRoleNameLabels");

            // verify the required parameter 'gcpRoleLabelsRequest' is set
            if (gcpRoleLabelsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRoleLabelsRequest' when calling Auth->PostAuthGcpRoleNameLabels");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRoleLabelsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{gcp_mount_path}/role/{name}/labels", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGcpRoleNameLabels", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Add or remove service accounts for an existing &#x60;iam&#x60; role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleServiceAccountsRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthGcpRoleNameServiceAccounts(string name, GcpRoleServiceAccountsRequest gcpRoleServiceAccountsRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthGcpRoleNameServiceAccounts");

            // verify the required parameter 'gcpRoleServiceAccountsRequest' is set
            if (gcpRoleServiceAccountsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRoleServiceAccountsRequest' when calling Auth->PostAuthGcpRoleNameServiceAccounts");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRoleServiceAccountsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{gcp_mount_path}/role/{name}/service-accounts", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGcpRoleNameServiceAccounts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Add or remove service accounts for an existing &#x60;iam&#x60; role 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="gcpRoleServiceAccountsRequest"></param>
        /// <param name="gcpMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;gcp&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthGcpRoleNameServiceAccountsAsync(string name, GcpRoleServiceAccountsRequest gcpRoleServiceAccountsRequest, string gcpMountPath = "gcp", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthGcpRoleNameServiceAccounts");

            // verify the required parameter 'gcpRoleServiceAccountsRequest' is set
            if (gcpRoleServiceAccountsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'gcpRoleServiceAccountsRequest' when calling Auth->PostAuthGcpRoleNameServiceAccounts");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (gcpMountPath != null)
            {
                requestOptions.PathParameters.Add("gcp_mount_path", ClientUtils.ParameterToString(gcpMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = gcpRoleServiceAccountsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{gcp_mount_path}/role/{name}/service-accounts", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGcpRoleNameServiceAccounts", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubConfigRequest"></param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthGithubConfig(GithubConfigRequest githubConfigRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'githubConfigRequest' is set
            if (githubConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubConfigRequest' when calling Auth->PostAuthGithubConfig");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            requestOptions.Data = githubConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{github_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGithubConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubConfigRequest"></param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthGithubConfigAsync(GithubConfigRequest githubConfigRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'githubConfigRequest' is set
            if (githubConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubConfigRequest' when calling Auth->PostAuthGithubConfig");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            requestOptions.Data = githubConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{github_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGithubConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubLoginRequest"></param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthGithubLogin(GithubLoginRequest githubLoginRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'githubLoginRequest' is set
            if (githubLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubLoginRequest' when calling Auth->PostAuthGithubLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            requestOptions.Data = githubLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{github_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGithubLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="githubLoginRequest"></param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthGithubLoginAsync(GithubLoginRequest githubLoginRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'githubLoginRequest' is set
            if (githubLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubLoginRequest' when calling Auth->PostAuthGithubLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            requestOptions.Data = githubLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{github_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGithubLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMapTeamsRequest"></param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthGithubMapTeamsKey(string key, GithubMapTeamsRequest githubMapTeamsRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->PostAuthGithubMapTeamsKey");

            // verify the required parameter 'githubMapTeamsRequest' is set
            if (githubMapTeamsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubMapTeamsRequest' when calling Auth->PostAuthGithubMapTeamsKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = githubMapTeamsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{github_mount_path}/map/teams/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGithubMapTeamsKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single teams mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the teams mapping</param>
        /// <param name="githubMapTeamsRequest"></param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthGithubMapTeamsKeyAsync(string key, GithubMapTeamsRequest githubMapTeamsRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->PostAuthGithubMapTeamsKey");

            // verify the required parameter 'githubMapTeamsRequest' is set
            if (githubMapTeamsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubMapTeamsRequest' when calling Auth->PostAuthGithubMapTeamsKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = githubMapTeamsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{github_mount_path}/map/teams/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGithubMapTeamsKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMapUsersRequest"></param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthGithubMapUsersKey(string key, GithubMapUsersRequest githubMapUsersRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->PostAuthGithubMapUsersKey");

            // verify the required parameter 'githubMapUsersRequest' is set
            if (githubMapUsersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubMapUsersRequest' when calling Auth->PostAuthGithubMapUsersKey");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = githubMapUsersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{github_mount_path}/map/users/{key}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGithubMapUsersKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Read/write/delete a single users mapping 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="key">Key for the users mapping</param>
        /// <param name="githubMapUsersRequest"></param>
        /// <param name="githubMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;github&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthGithubMapUsersKeyAsync(string key, GithubMapUsersRequest githubMapUsersRequest, string githubMountPath = "github", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'key' is set
            if (key == null)
                throw new VaultApiException(400, "Missing required parameter 'key' when calling Auth->PostAuthGithubMapUsersKey");

            // verify the required parameter 'githubMapUsersRequest' is set
            if (githubMapUsersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'githubMapUsersRequest' when calling Auth->PostAuthGithubMapUsersKey");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (githubMountPath != null)
            {
                requestOptions.PathParameters.Add("github_mount_path", ClientUtils.ParameterToString(githubMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("key", ClientUtils.ParameterToString(key)); // path parameter
            requestOptions.Data = githubMapUsersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{github_mount_path}/map/users/{key}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthGithubMapUsersKey", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the JWT authentication backend. The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtConfigRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthJwtConfig(JwtConfigRequest jwtConfigRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'jwtConfigRequest' is set
            if (jwtConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtConfigRequest' when calling Auth->PostAuthJwtConfig");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }
            requestOptions.Data = jwtConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{jwt_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthJwtConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the JWT authentication backend. The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtConfigRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthJwtConfigAsync(JwtConfigRequest jwtConfigRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'jwtConfigRequest' is set
            if (jwtConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtConfigRequest' when calling Auth->PostAuthJwtConfig");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }
            requestOptions.Data = jwtConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{jwt_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthJwtConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates to Vault using a JWT (or OIDC) token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtLoginRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthJwtLogin(JwtLoginRequest jwtLoginRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'jwtLoginRequest' is set
            if (jwtLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtLoginRequest' when calling Auth->PostAuthJwtLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }
            requestOptions.Data = jwtLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{jwt_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthJwtLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates to Vault using a JWT (or OIDC) token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtLoginRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthJwtLoginAsync(JwtLoginRequest jwtLoginRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'jwtLoginRequest' is set
            if (jwtLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtLoginRequest' when calling Auth->PostAuthJwtLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }
            requestOptions.Data = jwtLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{jwt_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthJwtLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request an authorization URL to start an OIDC login flow. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtOidcAuthUrlRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthJwtOidcAuthUrl(JwtOidcAuthUrlRequest jwtOidcAuthUrlRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'jwtOidcAuthUrlRequest' is set
            if (jwtOidcAuthUrlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtOidcAuthUrlRequest' when calling Auth->PostAuthJwtOidcAuthUrl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }
            requestOptions.Data = jwtOidcAuthUrlRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{jwt_mount_path}/oidc/auth_url", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthJwtOidcAuthUrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request an authorization URL to start an OIDC login flow. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtOidcAuthUrlRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthJwtOidcAuthUrlAsync(JwtOidcAuthUrlRequest jwtOidcAuthUrlRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'jwtOidcAuthUrlRequest' is set
            if (jwtOidcAuthUrlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtOidcAuthUrlRequest' when calling Auth->PostAuthJwtOidcAuthUrl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }
            requestOptions.Data = jwtOidcAuthUrlRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{jwt_mount_path}/oidc/auth_url", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthJwtOidcAuthUrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Callback endpoint to handle form_posts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtOidcCallbackRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthJwtOidcCallback(JwtOidcCallbackRequest jwtOidcCallbackRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'jwtOidcCallbackRequest' is set
            if (jwtOidcCallbackRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtOidcCallbackRequest' when calling Auth->PostAuthJwtOidcCallback");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }
            requestOptions.Data = jwtOidcCallbackRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{jwt_mount_path}/oidc/callback", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthJwtOidcCallback", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Callback endpoint to handle form_posts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="jwtOidcCallbackRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthJwtOidcCallbackAsync(JwtOidcCallbackRequest jwtOidcCallbackRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'jwtOidcCallbackRequest' is set
            if (jwtOidcCallbackRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtOidcCallbackRequest' when calling Auth->PostAuthJwtOidcCallback");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }
            requestOptions.Data = jwtOidcCallbackRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{jwt_mount_path}/oidc/callback", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthJwtOidcCallback", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtRoleRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthJwtRoleName(string name, JwtRoleRequest jwtRoleRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthJwtRoleName");

            // verify the required parameter 'jwtRoleRequest' is set
            if (jwtRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtRoleRequest' when calling Auth->PostAuthJwtRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = jwtRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{jwt_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthJwtRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="jwtRoleRequest"></param>
        /// <param name="jwtMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;jwt&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthJwtRoleNameAsync(string name, JwtRoleRequest jwtRoleRequest, string jwtMountPath = "jwt", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthJwtRoleName");

            // verify the required parameter 'jwtRoleRequest' is set
            if (jwtRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'jwtRoleRequest' when calling Auth->PostAuthJwtRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (jwtMountPath != null)
            {
                requestOptions.PathParameters.Add("jwt_mount_path", ClientUtils.ParameterToString(jwtMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = jwtRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{jwt_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthJwtRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigRequest"></param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthKerberosConfig(KerberosConfigRequest kerberosConfigRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'kerberosConfigRequest' is set
            if (kerberosConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosConfigRequest' when calling Auth->PostAuthKerberosConfig");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }
            requestOptions.Data = kerberosConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{kerberos_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthKerberosConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigRequest"></param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthKerberosConfigAsync(KerberosConfigRequest kerberosConfigRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'kerberosConfigRequest' is set
            if (kerberosConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosConfigRequest' when calling Auth->PostAuthKerberosConfig");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }
            requestOptions.Data = kerberosConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{kerberos_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthKerberosConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigLdapRequest"></param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthKerberosConfigLdap(KerberosConfigLdapRequest kerberosConfigLdapRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'kerberosConfigLdapRequest' is set
            if (kerberosConfigLdapRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosConfigLdapRequest' when calling Auth->PostAuthKerberosConfigLdap");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }
            requestOptions.Data = kerberosConfigLdapRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{kerberos_mount_path}/config/ldap", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthKerberosConfigLdap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosConfigLdapRequest"></param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthKerberosConfigLdapAsync(KerberosConfigLdapRequest kerberosConfigLdapRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'kerberosConfigLdapRequest' is set
            if (kerberosConfigLdapRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosConfigLdapRequest' when calling Auth->PostAuthKerberosConfigLdap");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }
            requestOptions.Data = kerberosConfigLdapRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{kerberos_mount_path}/config/ldap", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthKerberosConfigLdap", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosGroupsRequest"></param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthKerberosGroupsName(string name, KerberosGroupsRequest kerberosGroupsRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthKerberosGroupsName");

            // verify the required parameter 'kerberosGroupsRequest' is set
            if (kerberosGroupsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosGroupsRequest' when calling Auth->PostAuthKerberosGroupsName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = kerberosGroupsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{kerberos_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthKerberosGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="kerberosGroupsRequest"></param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthKerberosGroupsNameAsync(string name, KerberosGroupsRequest kerberosGroupsRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthKerberosGroupsName");

            // verify the required parameter 'kerberosGroupsRequest' is set
            if (kerberosGroupsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosGroupsRequest' when calling Auth->PostAuthKerberosGroupsName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = kerberosGroupsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{kerberos_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthKerberosGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosLoginRequest"></param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthKerberosLogin(KerberosLoginRequest kerberosLoginRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'kerberosLoginRequest' is set
            if (kerberosLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosLoginRequest' when calling Auth->PostAuthKerberosLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }
            requestOptions.Data = kerberosLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{kerberos_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthKerberosLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kerberosLoginRequest"></param>
        /// <param name="kerberosMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kerberos&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthKerberosLoginAsync(KerberosLoginRequest kerberosLoginRequest, string kerberosMountPath = "kerberos", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'kerberosLoginRequest' is set
            if (kerberosLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kerberosLoginRequest' when calling Auth->PostAuthKerberosLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kerberosMountPath != null)
            {
                requestOptions.PathParameters.Add("kerberos_mount_path", ClientUtils.ParameterToString(kerberosMountPath)); // path parameter
            }
            requestOptions.Data = kerberosLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{kerberos_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthKerberosLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures the JWT Public Key and Kubernetes API information. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthKubernetesConfig(KubernetesConfigRequest kubernetesConfigRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'kubernetesConfigRequest' is set
            if (kubernetesConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesConfigRequest' when calling Auth->PostAuthKubernetesConfig");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.Data = kubernetesConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{kubernetes_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthKubernetesConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configures the JWT Public Key and Kubernetes API information. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesConfigRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthKubernetesConfigAsync(KubernetesConfigRequest kubernetesConfigRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'kubernetesConfigRequest' is set
            if (kubernetesConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesConfigRequest' when calling Auth->PostAuthKubernetesConfig");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.Data = kubernetesConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{kubernetes_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthKubernetesConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates Kubernetes service accounts with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesLoginRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthKubernetesLogin(KubernetesLoginRequest kubernetesLoginRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'kubernetesLoginRequest' is set
            if (kubernetesLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesLoginRequest' when calling Auth->PostAuthKubernetesLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.Data = kubernetesLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{kubernetes_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthKubernetesLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates Kubernetes service accounts with Vault. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="kubernetesLoginRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthKubernetesLoginAsync(KubernetesLoginRequest kubernetesLoginRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'kubernetesLoginRequest' is set
            if (kubernetesLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesLoginRequest' when calling Auth->PostAuthKubernetesLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.Data = kubernetesLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{kubernetes_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthKubernetesLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesRoleRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthKubernetesRoleName(string name, KubernetesRoleRequest kubernetesRoleRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthKubernetesRoleName");

            // verify the required parameter 'kubernetesRoleRequest' is set
            if (kubernetesRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesRoleRequest' when calling Auth->PostAuthKubernetesRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = kubernetesRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{kubernetes_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthKubernetesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="kubernetesRoleRequest"></param>
        /// <param name="kubernetesMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;kubernetes&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthKubernetesRoleNameAsync(string name, KubernetesRoleRequest kubernetesRoleRequest, string kubernetesMountPath = "kubernetes", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthKubernetesRoleName");

            // verify the required parameter 'kubernetesRoleRequest' is set
            if (kubernetesRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'kubernetesRoleRequest' when calling Auth->PostAuthKubernetesRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (kubernetesMountPath != null)
            {
                requestOptions.PathParameters.Add("kubernetes_mount_path", ClientUtils.ParameterToString(kubernetesMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = kubernetesRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{kubernetes_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthKubernetesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the LDAP server to connect to, along with its options. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthLdapConfig(LdapConfigRequest ldapConfigRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'ldapConfigRequest' is set
            if (ldapConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapConfigRequest' when calling Auth->PostAuthLdapConfig");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.Data = ldapConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{ldap_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthLdapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the LDAP server to connect to, along with its options. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ldapConfigRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthLdapConfigAsync(LdapConfigRequest ldapConfigRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'ldapConfigRequest' is set
            if (ldapConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapConfigRequest' when calling Auth->PostAuthLdapConfig");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.Data = ldapConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{ldap_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthLdapConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapGroupsRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthLdapGroupsName(string name, LdapGroupsRequest ldapGroupsRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthLdapGroupsName");

            // verify the required parameter 'ldapGroupsRequest' is set
            if (ldapGroupsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapGroupsRequest' when calling Auth->PostAuthLdapGroupsName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapGroupsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{ldap_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthLdapGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP group.</param>
        /// <param name="ldapGroupsRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthLdapGroupsNameAsync(string name, LdapGroupsRequest ldapGroupsRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthLdapGroupsName");

            // verify the required parameter 'ldapGroupsRequest' is set
            if (ldapGroupsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapGroupsRequest' when calling Auth->PostAuthLdapGroupsName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapGroupsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{ldap_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthLdapGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">DN (distinguished name) to be used for login.</param>
        /// <param name="ldapLoginRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthLdapLoginUsername(string username, LdapLoginRequest ldapLoginRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->PostAuthLdapLoginUsername");

            // verify the required parameter 'ldapLoginRequest' is set
            if (ldapLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLoginRequest' when calling Auth->PostAuthLdapLoginUsername");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = ldapLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{ldap_mount_path}/login/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthLdapLoginUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">DN (distinguished name) to be used for login.</param>
        /// <param name="ldapLoginRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthLdapLoginUsernameAsync(string username, LdapLoginRequest ldapLoginRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->PostAuthLdapLoginUsername");

            // verify the required parameter 'ldapLoginRequest' is set
            if (ldapLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapLoginRequest' when calling Auth->PostAuthLdapLoginUsername");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = ldapLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{ldap_mount_path}/login/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthLdapLoginUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapUsersRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthLdapUsersName(string name, LdapUsersRequest ldapUsersRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthLdapUsersName");

            // verify the required parameter 'ldapUsersRequest' is set
            if (ldapUsersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapUsersRequest' when calling Auth->PostAuthLdapUsersName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapUsersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{ldap_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthLdapUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the LDAP user.</param>
        /// <param name="ldapUsersRequest"></param>
        /// <param name="ldapMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;ldap&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthLdapUsersNameAsync(string name, LdapUsersRequest ldapUsersRequest, string ldapMountPath = "ldap", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthLdapUsersName");

            // verify the required parameter 'ldapUsersRequest' is set
            if (ldapUsersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ldapUsersRequest' when calling Auth->PostAuthLdapUsersName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ldapMountPath != null)
            {
                requestOptions.PathParameters.Add("ldap_mount_path", ClientUtils.ParameterToString(ldapMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            requestOptions.Data = ldapUsersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{ldap_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthLdapUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manages the configuration for the Vault Auth Plugin. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociConfigRequest"></param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthOciConfig(OciConfigRequest ociConfigRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'ociConfigRequest' is set
            if (ociConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ociConfigRequest' when calling Auth->PostAuthOciConfig");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ociMountPath != null)
            {
                requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter
            }
            requestOptions.Data = ociConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{oci_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOciConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manages the configuration for the Vault Auth Plugin. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="ociConfigRequest"></param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthOciConfigAsync(OciConfigRequest ociConfigRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'ociConfigRequest' is set
            if (ociConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ociConfigRequest' when calling Auth->PostAuthOciConfig");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ociMountPath != null)
            {
                requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter
            }
            requestOptions.Data = ociConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{oci_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOciConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates to Vault using OCI credentials 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociLoginRequest"></param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthOciLoginRole(string role, OciLoginRequest ociLoginRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->PostAuthOciLoginRole");

            // verify the required parameter 'ociLoginRequest' is set
            if (ociLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ociLoginRequest' when calling Auth->PostAuthOciLoginRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ociMountPath != null)
            {
                requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = ociLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{oci_mount_path}/login/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOciLoginRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates to Vault using OCI credentials 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociLoginRequest"></param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthOciLoginRoleAsync(string role, OciLoginRequest ociLoginRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->PostAuthOciLoginRole");

            // verify the required parameter 'ociLoginRequest' is set
            if (ociLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ociLoginRequest' when calling Auth->PostAuthOciLoginRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ociMountPath != null)
            {
                requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = ociLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{oci_mount_path}/login/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOciLoginRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociRoleRequest"></param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthOciRoleRole(string role, OciRoleRequest ociRoleRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->PostAuthOciRoleRole");

            // verify the required parameter 'ociRoleRequest' is set
            if (ociRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ociRoleRequest' when calling Auth->PostAuthOciRoleRole");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ociMountPath != null)
            {
                requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = ociRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{oci_mount_path}/role/{role}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOciRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Create a role and associate policies to it. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="role">Name of the role.</param>
        /// <param name="ociRoleRequest"></param>
        /// <param name="ociMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oci&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthOciRoleRoleAsync(string role, OciRoleRequest ociRoleRequest, string ociMountPath = "oci", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'role' is set
            if (role == null)
                throw new VaultApiException(400, "Missing required parameter 'role' when calling Auth->PostAuthOciRoleRole");

            // verify the required parameter 'ociRoleRequest' is set
            if (ociRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'ociRoleRequest' when calling Auth->PostAuthOciRoleRole");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (ociMountPath != null)
            {
                requestOptions.PathParameters.Add("oci_mount_path", ClientUtils.ParameterToString(ociMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("role", ClientUtils.ParameterToString(role)); // path parameter
            requestOptions.Data = ociRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{oci_mount_path}/role/{role}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOciRoleRole", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the JWT authentication backend. The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcConfigRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthOidcConfig(OidcConfigRequest oidcConfigRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'oidcConfigRequest' is set
            if (oidcConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oidcConfigRequest' when calling Auth->PostAuthOidcConfig");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }
            requestOptions.Data = oidcConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{oidc_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOidcConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the JWT authentication backend. The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcConfigRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthOidcConfigAsync(OidcConfigRequest oidcConfigRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'oidcConfigRequest' is set
            if (oidcConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oidcConfigRequest' when calling Auth->PostAuthOidcConfig");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }
            requestOptions.Data = oidcConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{oidc_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOidcConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates to Vault using a JWT (or OIDC) token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcLoginRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthOidcLogin(OidcLoginRequest oidcLoginRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'oidcLoginRequest' is set
            if (oidcLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oidcLoginRequest' when calling Auth->PostAuthOidcLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }
            requestOptions.Data = oidcLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{oidc_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOidcLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Authenticates to Vault using a JWT (or OIDC) token. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcLoginRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthOidcLoginAsync(OidcLoginRequest oidcLoginRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'oidcLoginRequest' is set
            if (oidcLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oidcLoginRequest' when calling Auth->PostAuthOidcLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }
            requestOptions.Data = oidcLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{oidc_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOidcLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request an authorization URL to start an OIDC login flow. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcOidcAuthUrlRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthOidcOidcAuthUrl(OidcOidcAuthUrlRequest oidcOidcAuthUrlRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'oidcOidcAuthUrlRequest' is set
            if (oidcOidcAuthUrlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oidcOidcAuthUrlRequest' when calling Auth->PostAuthOidcOidcAuthUrl");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }
            requestOptions.Data = oidcOidcAuthUrlRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{oidc_mount_path}/oidc/auth_url", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOidcOidcAuthUrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Request an authorization URL to start an OIDC login flow. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcOidcAuthUrlRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthOidcOidcAuthUrlAsync(OidcOidcAuthUrlRequest oidcOidcAuthUrlRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'oidcOidcAuthUrlRequest' is set
            if (oidcOidcAuthUrlRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oidcOidcAuthUrlRequest' when calling Auth->PostAuthOidcOidcAuthUrl");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }
            requestOptions.Data = oidcOidcAuthUrlRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{oidc_mount_path}/oidc/auth_url", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOidcOidcAuthUrl", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Callback endpoint to handle form_posts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcOidcCallbackRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthOidcOidcCallback(OidcOidcCallbackRequest oidcOidcCallbackRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'oidcOidcCallbackRequest' is set
            if (oidcOidcCallbackRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oidcOidcCallbackRequest' when calling Auth->PostAuthOidcOidcCallback");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }
            requestOptions.Data = oidcOidcCallbackRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{oidc_mount_path}/oidc/callback", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOidcOidcCallback", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Callback endpoint to handle form_posts. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oidcOidcCallbackRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthOidcOidcCallbackAsync(OidcOidcCallbackRequest oidcOidcCallbackRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'oidcOidcCallbackRequest' is set
            if (oidcOidcCallbackRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oidcOidcCallbackRequest' when calling Auth->PostAuthOidcOidcCallback");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }
            requestOptions.Data = oidcOidcCallbackRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{oidc_mount_path}/oidc/callback", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOidcOidcCallback", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="oidcRoleRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthOidcRoleName(string name, OidcRoleRequest oidcRoleRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthOidcRoleName");

            // verify the required parameter 'oidcRoleRequest' is set
            if (oidcRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oidcRoleRequest' when calling Auth->PostAuthOidcRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }
            requestOptions.Data = oidcRoleRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{oidc_mount_path}/role/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOidcRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Register an role with the backend. A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the role.</param>
        /// <param name="oidcRoleRequest"></param>
        /// <param name="oidcMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;oidc&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthOidcRoleNameAsync(string name, OidcRoleRequest oidcRoleRequest, string oidcMountPath = "oidc", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthOidcRoleName");

            // verify the required parameter 'oidcRoleRequest' is set
            if (oidcRoleRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oidcRoleRequest' when calling Auth->PostAuthOidcRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oidcMountPath != null)
            {
                requestOptions.PathParameters.Add("oidc_mount_path", ClientUtils.ParameterToString(oidcMountPath)); // path parameter
            }
            requestOptions.Data = oidcRoleRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{oidc_mount_path}/role/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOidcRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint allows you to configure the Okta and its configuration options.  The Okta organization are the characters at the front of the URL for Okta. Example https://ORG.okta.com 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaConfigRequest"></param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthOktaConfig(OktaConfigRequest oktaConfigRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'oktaConfigRequest' is set
            if (oktaConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaConfigRequest' when calling Auth->PostAuthOktaConfig");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }
            requestOptions.Data = oktaConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{okta_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOktaConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint allows you to configure the Okta and its configuration options.  The Okta organization are the characters at the front of the URL for Okta. Example https://ORG.okta.com 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="oktaConfigRequest"></param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthOktaConfigAsync(OktaConfigRequest oktaConfigRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'oktaConfigRequest' is set
            if (oktaConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaConfigRequest' when calling Auth->PostAuthOktaConfig");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }
            requestOptions.Data = oktaConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{okta_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOktaConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaGroupsRequest"></param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthOktaGroupsName(string name, OktaGroupsRequest oktaGroupsRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthOktaGroupsName");

            // verify the required parameter 'oktaGroupsRequest' is set
            if (oktaGroupsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaGroupsRequest' when calling Auth->PostAuthOktaGroupsName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }
            requestOptions.Data = oktaGroupsRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{okta_mount_path}/groups/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOktaGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the Okta group.</param>
        /// <param name="oktaGroupsRequest"></param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthOktaGroupsNameAsync(string name, OktaGroupsRequest oktaGroupsRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthOktaGroupsName");

            // verify the required parameter 'oktaGroupsRequest' is set
            if (oktaGroupsRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaGroupsRequest' when calling Auth->PostAuthOktaGroupsName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }
            requestOptions.Data = oktaGroupsRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{okta_mount_path}/groups/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOktaGroupsName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username to be used for login.</param>
        /// <param name="oktaLoginRequest"></param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthOktaLoginUsername(string username, OktaLoginRequest oktaLoginRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->PostAuthOktaLoginUsername");

            // verify the required parameter 'oktaLoginRequest' is set
            if (oktaLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaLoginRequest' when calling Auth->PostAuthOktaLoginUsername");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = oktaLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{okta_mount_path}/login/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOktaLoginUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username to be used for login.</param>
        /// <param name="oktaLoginRequest"></param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthOktaLoginUsernameAsync(string username, OktaLoginRequest oktaLoginRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->PostAuthOktaLoginUsername");

            // verify the required parameter 'oktaLoginRequest' is set
            if (oktaLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaLoginRequest' when calling Auth->PostAuthOktaLoginUsername");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            requestOptions.Data = oktaLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{okta_mount_path}/login/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOktaLoginUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaUsersRequest"></param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthOktaUsersName(string name, OktaUsersRequest oktaUsersRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthOktaUsersName");

            // verify the required parameter 'oktaUsersRequest' is set
            if (oktaUsersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaUsersRequest' when calling Auth->PostAuthOktaUsersName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }
            requestOptions.Data = oktaUsersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{okta_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOktaUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage additional groups for users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the user.</param>
        /// <param name="oktaUsersRequest"></param>
        /// <param name="oktaMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;okta&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthOktaUsersNameAsync(string name, OktaUsersRequest oktaUsersRequest, string oktaMountPath = "okta", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthOktaUsersName");

            // verify the required parameter 'oktaUsersRequest' is set
            if (oktaUsersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'oktaUsersRequest' when calling Auth->PostAuthOktaUsersName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (oktaMountPath != null)
            {
                requestOptions.PathParameters.Add("okta_mount_path", ClientUtils.ParameterToString(oktaMountPath)); // path parameter
            }
            requestOptions.Data = oktaUsersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{okta_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthOktaUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the RADIUS server to connect to, along with its options. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusConfigRequest"></param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthRadiusConfig(RadiusConfigRequest radiusConfigRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'radiusConfigRequest' is set
            if (radiusConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusConfigRequest' when calling Auth->PostAuthRadiusConfig");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (radiusMountPath != null)
            {
                requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter
            }
            requestOptions.Data = radiusConfigRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{radius_mount_path}/config", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthRadiusConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Configure the RADIUS server to connect to, along with its options. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusConfigRequest"></param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthRadiusConfigAsync(RadiusConfigRequest radiusConfigRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'radiusConfigRequest' is set
            if (radiusConfigRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusConfigRequest' when calling Auth->PostAuthRadiusConfig");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (radiusMountPath != null)
            {
                requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter
            }
            requestOptions.Data = radiusConfigRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{radius_mount_path}/config", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthRadiusConfig", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusLoginRequest"></param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthRadiusLogin(RadiusLoginRequest radiusLoginRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'radiusLoginRequest' is set
            if (radiusLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusLoginRequest' when calling Auth->PostAuthRadiusLogin");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (radiusMountPath != null)
            {
                requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter
            }
            requestOptions.Data = radiusLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{radius_mount_path}/login", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthRadiusLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="radiusLoginRequest"></param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthRadiusLoginAsync(RadiusLoginRequest radiusLoginRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'radiusLoginRequest' is set
            if (radiusLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusLoginRequest' when calling Auth->PostAuthRadiusLogin");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (radiusMountPath != null)
            {
                requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter
            }
            requestOptions.Data = radiusLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{radius_mount_path}/login", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthRadiusLogin", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlusername">Username to be used for login. (URL parameter)</param>
        /// <param name="radiusLoginRequest"></param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthRadiusLoginUrlusername(string urlusername, RadiusLoginRequest radiusLoginRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'urlusername' is set
            if (urlusername == null)
                throw new VaultApiException(400, "Missing required parameter 'urlusername' when calling Auth->PostAuthRadiusLoginUrlusername");

            // verify the required parameter 'radiusLoginRequest' is set
            if (radiusLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusLoginRequest' when calling Auth->PostAuthRadiusLoginUrlusername");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (radiusMountPath != null)
            {
                requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlusername", ClientUtils.ParameterToString(urlusername)); // path parameter
            requestOptions.Data = radiusLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{radius_mount_path}/login/{urlusername}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthRadiusLoginUrlusername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="urlusername">Username to be used for login. (URL parameter)</param>
        /// <param name="radiusLoginRequest"></param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthRadiusLoginUrlusernameAsync(string urlusername, RadiusLoginRequest radiusLoginRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'urlusername' is set
            if (urlusername == null)
                throw new VaultApiException(400, "Missing required parameter 'urlusername' when calling Auth->PostAuthRadiusLoginUrlusername");

            // verify the required parameter 'radiusLoginRequest' is set
            if (radiusLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusLoginRequest' when calling Auth->PostAuthRadiusLoginUrlusername");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (radiusMountPath != null)
            {
                requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter
            }
            requestOptions.PathParameters.Add("urlusername", ClientUtils.ParameterToString(urlusername)); // path parameter
            requestOptions.Data = radiusLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{radius_mount_path}/login/{urlusername}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthRadiusLoginUrlusername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusUsersRequest"></param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthRadiusUsersName(string name, RadiusUsersRequest radiusUsersRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthRadiusUsersName");

            // verify the required parameter 'radiusUsersRequest' is set
            if (radiusUsersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusUsersRequest' when calling Auth->PostAuthRadiusUsersName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (radiusMountPath != null)
            {
                requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter
            }
            requestOptions.Data = radiusUsersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{radius_mount_path}/users/{name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthRadiusUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Name of the RADIUS user.</param>
        /// <param name="radiusUsersRequest"></param>
        /// <param name="radiusMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;radius&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthRadiusUsersNameAsync(string name, RadiusUsersRequest radiusUsersRequest, string radiusMountPath = "radius", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new VaultApiException(400, "Missing required parameter 'name' when calling Auth->PostAuthRadiusUsersName");

            // verify the required parameter 'radiusUsersRequest' is set
            if (radiusUsersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'radiusUsersRequest' when calling Auth->PostAuthRadiusUsersName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("name", ClientUtils.ParameterToString(name)); // path parameter
            if (radiusMountPath != null)
            {
                requestOptions.PathParameters.Add("radius_mount_path", ClientUtils.ParameterToString(radiusMountPath)); // path parameter
            }
            requestOptions.Data = radiusUsersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{radius_mount_path}/users/{name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthRadiusUsersName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// The token create path is used to create new tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthTokenCreate(TokenCreateRequest tokenCreateRequest, string format = "json", string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'tokenCreateRequest' is set
            if (tokenCreateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateRequest' when calling Auth->PostAuthTokenCreate");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{token_mount_path}/create", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenCreate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// The token create path is used to create new tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthTokenCreateAsync(TokenCreateRequest tokenCreateRequest, string format = "json", string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenCreateRequest' is set
            if (tokenCreateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateRequest' when calling Auth->PostAuthTokenCreate");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{token_mount_path}/create", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenCreate", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// The token create path is used to create new orphan tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateOrphanRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthTokenCreateOrphan(TokenCreateOrphanRequest tokenCreateOrphanRequest, string format = "json", string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'tokenCreateOrphanRequest' is set
            if (tokenCreateOrphanRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateOrphanRequest' when calling Auth->PostAuthTokenCreateOrphan");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateOrphanRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{token_mount_path}/create-orphan", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenCreateOrphan", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// The token create path is used to create new orphan tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenCreateOrphanRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthTokenCreateOrphanAsync(TokenCreateOrphanRequest tokenCreateOrphanRequest, string format = "json", string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenCreateOrphanRequest' is set
            if (tokenCreateOrphanRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateOrphanRequest' when calling Auth->PostAuthTokenCreateOrphan");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateOrphanRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{token_mount_path}/create-orphan", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenCreateOrphan", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This token create path is used to create new tokens adhering to the given role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthTokenCreateRoleName(string roleName, TokenCreateRequest tokenCreateRequest, string format = "json", string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthTokenCreateRoleName");

            // verify the required parameter 'tokenCreateRequest' is set
            if (tokenCreateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateRequest' when calling Auth->PostAuthTokenCreateRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{token_mount_path}/create/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenCreateRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This token create path is used to create new tokens adhering to the given role. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenCreateRequest"></param>
        /// <param name="format">Return json formatted output (optional, default to &quot;json&quot;)</param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthTokenCreateRoleNameAsync(string roleName, TokenCreateRequest tokenCreateRequest, string format = "json", string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthTokenCreateRoleName");

            // verify the required parameter 'tokenCreateRequest' is set
            if (tokenCreateRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenCreateRequest' when calling Auth->PostAuthTokenCreateRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            if (format != null)
            {
                requestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "format", format));
            }
            requestOptions.Data = tokenCreateRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{token_mount_path}/create/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenCreateRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthTokenLookup(TokenLookupRequest tokenLookupRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'tokenLookupRequest' is set
            if (tokenLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenLookupRequest' when calling Auth->PostAuthTokenLookup");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{token_mount_path}/lookup", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthTokenLookupAsync(TokenLookupRequest tokenLookupRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenLookupRequest' is set
            if (tokenLookupRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenLookupRequest' when calling Auth->PostAuthTokenLookup");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{token_mount_path}/lookup", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenLookup", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupAccessorRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthTokenLookupAccessor(TokenLookupAccessorRequest tokenLookupAccessorRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'tokenLookupAccessorRequest' is set
            if (tokenLookupAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenLookupAccessorRequest' when calling Auth->PostAuthTokenLookupAccessor");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupAccessorRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{token_mount_path}/lookup-accessor", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenLookupAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupAccessorRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthTokenLookupAccessorAsync(TokenLookupAccessorRequest tokenLookupAccessorRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenLookupAccessorRequest' is set
            if (tokenLookupAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenLookupAccessorRequest' when calling Auth->PostAuthTokenLookupAccessor");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupAccessorRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{token_mount_path}/lookup-accessor", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenLookupAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupSelfRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthTokenLookupSelf(TokenLookupSelfRequest tokenLookupSelfRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'tokenLookupSelfRequest' is set
            if (tokenLookupSelfRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenLookupSelfRequest' when calling Auth->PostAuthTokenLookupSelf");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupSelfRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{token_mount_path}/lookup-self", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenLookupSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will lookup a token and its properties. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenLookupSelfRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthTokenLookupSelfAsync(TokenLookupSelfRequest tokenLookupSelfRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenLookupSelfRequest' is set
            if (tokenLookupSelfRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenLookupSelfRequest' when calling Auth->PostAuthTokenLookupSelf");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenLookupSelfRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{token_mount_path}/lookup-self", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenLookupSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will renew the given token and prevent expiration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthTokenRenew(TokenRenewRequest tokenRenewRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'tokenRenewRequest' is set
            if (tokenRenewRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewRequest' when calling Auth->PostAuthTokenRenew");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{token_mount_path}/renew", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenRenew", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will renew the given token and prevent expiration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthTokenRenewAsync(TokenRenewRequest tokenRenewRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenRenewRequest' is set
            if (tokenRenewRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewRequest' when calling Auth->PostAuthTokenRenew");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{token_mount_path}/renew", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenRenew", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewAccessorRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthTokenRenewAccessor(TokenRenewAccessorRequest tokenRenewAccessorRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'tokenRenewAccessorRequest' is set
            if (tokenRenewAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewAccessorRequest' when calling Auth->PostAuthTokenRenewAccessor");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewAccessorRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{token_mount_path}/renew-accessor", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenRenewAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewAccessorRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthTokenRenewAccessorAsync(TokenRenewAccessorRequest tokenRenewAccessorRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenRenewAccessorRequest' is set
            if (tokenRenewAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewAccessorRequest' when calling Auth->PostAuthTokenRenewAccessor");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewAccessorRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{token_mount_path}/renew-accessor", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenRenewAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will renew the token used to call it and prevent expiration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewSelfRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthTokenRenewSelf(TokenRenewSelfRequest tokenRenewSelfRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'tokenRenewSelfRequest' is set
            if (tokenRenewSelfRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewSelfRequest' when calling Auth->PostAuthTokenRenewSelf");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewSelfRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{token_mount_path}/renew-self", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenRenewSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will renew the token used to call it and prevent expiration. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRenewSelfRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthTokenRenewSelfAsync(TokenRenewSelfRequest tokenRenewSelfRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenRenewSelfRequest' is set
            if (tokenRenewSelfRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRenewSelfRequest' when calling Auth->PostAuthTokenRenewSelf");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenRenewSelfRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{token_mount_path}/renew-self", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenRenewSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the given token and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthTokenRevoke(TokenRevokeRequest tokenRevokeRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'tokenRevokeRequest' is set
            if (tokenRevokeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeRequest' when calling Auth->PostAuthTokenRevoke");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{token_mount_path}/revoke", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the given token and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthTokenRevokeAsync(TokenRevokeRequest tokenRevokeRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenRevokeRequest' is set
            if (tokenRevokeRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeRequest' when calling Auth->PostAuthTokenRevoke");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{token_mount_path}/revoke", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenRevoke", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the token associated with the accessor and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeAccessorRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthTokenRevokeAccessor(TokenRevokeAccessorRequest tokenRevokeAccessorRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'tokenRevokeAccessorRequest' is set
            if (tokenRevokeAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeAccessorRequest' when calling Auth->PostAuthTokenRevokeAccessor");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeAccessorRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{token_mount_path}/revoke-accessor", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenRevokeAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the token associated with the accessor and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeAccessorRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthTokenRevokeAccessorAsync(TokenRevokeAccessorRequest tokenRevokeAccessorRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenRevokeAccessorRequest' is set
            if (tokenRevokeAccessorRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeAccessorRequest' when calling Auth->PostAuthTokenRevokeAccessor");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeAccessorRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{token_mount_path}/revoke-accessor", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenRevokeAccessor", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the token and orphan its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeOrphanRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthTokenRevokeOrphan(TokenRevokeOrphanRequest tokenRevokeOrphanRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'tokenRevokeOrphanRequest' is set
            if (tokenRevokeOrphanRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeOrphanRequest' when calling Auth->PostAuthTokenRevokeOrphan");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeOrphanRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{token_mount_path}/revoke-orphan", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenRevokeOrphan", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the token and orphan its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenRevokeOrphanRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthTokenRevokeOrphanAsync(TokenRevokeOrphanRequest tokenRevokeOrphanRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'tokenRevokeOrphanRequest' is set
            if (tokenRevokeOrphanRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRevokeOrphanRequest' when calling Auth->PostAuthTokenRevokeOrphan");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenRevokeOrphanRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{token_mount_path}/revoke-orphan", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenRevokeOrphan", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the token used to call it and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthTokenRevokeSelf(string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{token_mount_path}/revoke-self", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenRevokeSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint will delete the token used to call it and all of its child tokens. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthTokenRevokeSelfAsync(string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{token_mount_path}/revoke-self", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenRevokeSelf", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenRolesRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthTokenRolesRoleName(string roleName, TokenRolesRequest tokenRolesRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthTokenRolesRoleName");

            // verify the required parameter 'tokenRolesRequest' is set
            if (tokenRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRolesRequest' when calling Auth->PostAuthTokenRolesRoleName");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenRolesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{token_mount_path}/roles/{role_name}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenRolesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="roleName">Name of the role</param>
        /// <param name="tokenRolesRequest"></param>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthTokenRolesRoleNameAsync(string roleName, TokenRolesRequest tokenRolesRequest, string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'roleName' is set
            if (roleName == null)
                throw new VaultApiException(400, "Missing required parameter 'roleName' when calling Auth->PostAuthTokenRolesRoleName");

            // verify the required parameter 'tokenRolesRequest' is set
            if (tokenRolesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'tokenRolesRequest' when calling Auth->PostAuthTokenRolesRoleName");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("role_name", ClientUtils.ParameterToString(roleName)); // path parameter
            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }
            requestOptions.Data = tokenRolesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{token_mount_path}/roles/{role_name}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenRolesRoleName", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthTokenTidy(string tokenMountPath = "token", TimeSpan? wrapTTL = null)
        {
            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{token_mount_path}/tidy", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// This endpoint performs cleanup tasks that can be run if certain error conditions have occurred. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;token&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthTokenTidyAsync(string tokenMountPath = "token", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            if (tokenMountPath != null)
            {
                requestOptions.PathParameters.Add("token_mount_path", ClientUtils.ParameterToString(tokenMountPath)); // path parameter
            }

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{token_mount_path}/tidy", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthTokenTidy", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username of the user.</param>
        /// <param name="userpassLoginRequest"></param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthUserpassLoginUsername(string username, UserpassLoginRequest userpassLoginRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->PostAuthUserpassLoginUsername");

            // verify the required parameter 'userpassLoginRequest' is set
            if (userpassLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassLoginRequest' when calling Auth->PostAuthUserpassLoginUsername");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            if (userpassMountPath != null)
            {
                requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter
            }
            requestOptions.Data = userpassLoginRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{userpass_mount_path}/login/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthUserpassLoginUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Log in with a username and password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username of the user.</param>
        /// <param name="userpassLoginRequest"></param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthUserpassLoginUsernameAsync(string username, UserpassLoginRequest userpassLoginRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->PostAuthUserpassLoginUsername");

            // verify the required parameter 'userpassLoginRequest' is set
            if (userpassLoginRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassLoginRequest' when calling Auth->PostAuthUserpassLoginUsername");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            if (userpassMountPath != null)
            {
                requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter
            }
            requestOptions.Data = userpassLoginRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{userpass_mount_path}/login/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthUserpassLoginUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersRequest"></param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthUserpassUsersUsername(string username, UserpassUsersRequest userpassUsersRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->PostAuthUserpassUsersUsername");

            // verify the required parameter 'userpassUsersRequest' is set
            if (userpassUsersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassUsersRequest' when calling Auth->PostAuthUserpassUsersUsername");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            if (userpassMountPath != null)
            {
                requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter
            }
            requestOptions.Data = userpassUsersRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{userpass_mount_path}/users/{username}", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthUserpassUsersUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Manage users allowed to authenticate. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersRequest"></param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthUserpassUsersUsernameAsync(string username, UserpassUsersRequest userpassUsersRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->PostAuthUserpassUsersUsername");

            // verify the required parameter 'userpassUsersRequest' is set
            if (userpassUsersRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassUsersRequest' when calling Auth->PostAuthUserpassUsersUsername");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            if (userpassMountPath != null)
            {
                requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter
            }
            requestOptions.Data = userpassUsersRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{userpass_mount_path}/users/{username}", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthUserpassUsersUsername", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Reset user&#39;s password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersPasswordRequest"></param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthUserpassUsersUsernamePassword(string username, UserpassUsersPasswordRequest userpassUsersPasswordRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->PostAuthUserpassUsersUsernamePassword");

            // verify the required parameter 'userpassUsersPasswordRequest' is set
            if (userpassUsersPasswordRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassUsersPasswordRequest' when calling Auth->PostAuthUserpassUsersUsernamePassword");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            if (userpassMountPath != null)
            {
                requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter
            }
            requestOptions.Data = userpassUsersPasswordRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{userpass_mount_path}/users/{username}/password", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthUserpassUsersUsernamePassword", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Reset user&#39;s password. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersPasswordRequest"></param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthUserpassUsersUsernamePasswordAsync(string username, UserpassUsersPasswordRequest userpassUsersPasswordRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->PostAuthUserpassUsersUsernamePassword");

            // verify the required parameter 'userpassUsersPasswordRequest' is set
            if (userpassUsersPasswordRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassUsersPasswordRequest' when calling Auth->PostAuthUserpassUsersUsernamePassword");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            if (userpassMountPath != null)
            {
                requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter
            }
            requestOptions.Data = userpassUsersPasswordRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{userpass_mount_path}/users/{username}/password", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthUserpassUsersUsernamePassword", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Update the policies associated with the username. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersPoliciesRequest"></param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <returns>VaultResponse of Object(void)</returns>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        public VaultResponse<Object> PostAuthUserpassUsersUsernamePolicies(string username, UserpassUsersPoliciesRequest userpassUsersPoliciesRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null)
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->PostAuthUserpassUsersUsernamePolicies");

            // verify the required parameter 'userpassUsersPoliciesRequest' is set
            if (userpassUsersPoliciesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassUsersPoliciesRequest' when calling Auth->PostAuthUserpassUsersUsernamePolicies");

            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            if (userpassMountPath != null)
            {
                requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter
            }
            requestOptions.Data = userpassUsersPoliciesRequest;

            // make the HTTP request
            var response = this.Client.Post<Object>("/auth/{userpass_mount_path}/users/{username}/policies", requestOptions);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthUserpassUsersUsernamePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }


        /// <summary>
        /// Update the policies associated with the username. 
        /// </summary>
        /// <exception cref="VaultApiException">Thrown when fails to make API call</exception>
        /// <param name="username">Username for this user.</param>
        /// <param name="userpassUsersPoliciesRequest"></param>
        /// <param name="userpassMountPath">Path where the backend was mounted; the endpoint path will be offset by the mount path (optional, default to &quot;userpass&quot;)</param>
        /// <param name="wrapTTL">
        /// Sets the X-Vault-Wrap-TTL Header
        /// <remarks>
        /// This will take precedence over client level wrapTTL value
        /// </remarks>
        /// <see href="See https://www.vaultproject.io/docs/concepts/response-wrapping">Vault Response Wrapping</see>
        /// </param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VaultResponse</returns>
        public async Task<VaultResponse<Object>> PostAuthUserpassUsersUsernamePoliciesAsync(string username, UserpassUsersPoliciesRequest userpassUsersPoliciesRequest, string userpassMountPath = "userpass", TimeSpan? wrapTTL = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'username' is set
            if (username == null)
                throw new VaultApiException(400, "Missing required parameter 'username' when calling Auth->PostAuthUserpassUsersUsernamePolicies");

            // verify the required parameter 'userpassUsersPoliciesRequest' is set
            if (userpassUsersPoliciesRequest == null)
                throw new VaultApiException(400, "Missing required parameter 'userpassUsersPoliciesRequest' when calling Auth->PostAuthUserpassUsersUsernamePolicies");


            RequestOptions requestOptions = new RequestOptions();

            if (wrapTTL != null)
            {
                requestOptions.HeaderParameters.Add("X-Vault-Wrap-TTL", wrapTTL.Value.TotalSeconds.ToString());
            }

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var contentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (contentType != null) requestOptions.HeaderParameters.Add("Content-Type", contentType);

            var accept = ClientUtils.SelectHeaderAccept(_accepts);
            if (accept != null) requestOptions.HeaderParameters.Add("Accept", accept);

            requestOptions.PathParameters.Add("username", ClientUtils.ParameterToString(username)); // path parameter
            if (userpassMountPath != null)
            {
                requestOptions.PathParameters.Add("userpass_mount_path", ClientUtils.ParameterToString(userpassMountPath)); // path parameter
            }
            requestOptions.Data = userpassUsersPoliciesRequest;

            // make the HTTP request
            var response = await this.AsynchronousClient.PostAsync<Object>("/auth/{userpass_mount_path}/users/{username}/policies", requestOptions, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception exception = this.ExceptionFactory("PostAuthUserpassUsersUsernamePolicies", response);
                if (exception != null) throw exception;
            }

            return ClientUtils.ToVaultResponse<object>(response.RawContent);
        }

    }
}
